{"version":3,"sources":["../../../libs/mdb-firebase/index.js","../../../libs/scenario-data/constants.js","../../../libs/scenario-data/index.js","../../../libs/scenario-data/intvPrompts.js","../../../libs/scenario-data/intvMenuItems.js","routes/LogList.js","../../../libs/feedback-data/c1Data.js","../../../libs/feedback-data/c2Data.js","../../../libs/feedback-data/analysisData.js","components/debriefingUtils.js","utils.js","components/scenarioDataAccesors.js","components/summarizeAnalysis.js","components/analyzeEvents.js","components/MDBNavBar.js","components/DisplayBaseDebriefing.js","components/AnalyzeDebriefing.js","routes/Log.js","routes/DisplayDebriefing.js","components/UnauthedLayout.js","App.js","reportWebVitals.js","index.js"],"names":["userApp","getOrInitializeApp","appCfg","name","app","appID","matches","firebase","apps","filter","options","appId","length","getApp","initializeApp","process","REACT_APP_APP_ENV","console","log","apiKey","authDomain","projectId","storageBucket","messagingSenderId","measurementId","prodApp","db","auth","firestore","ASSESS","ASSESS_OPTION","AWO","DECISION","DECISION_OPTION","INTERV","PHASE","REQUIRED","SUB_PHASE","MDB_TYPES","Object","freeze","ASSESSO","CL_HEADING","CL_PROMPT","DIST_PROMPT","NESTED_CHECKLIST","REQURED","PROMPT_SET","PROMPT","ANSWER","SELECTION_TYPES","ONE","OOM","NONE","CHECKLIST_STEP_TYPES","AW","BR","BL","SH","OPTION_TYPES","ANALYSIS_TYPES","MIN","OPT","REQ","CONTRA","UNN","IR","getPublishedScenarioByID","ST","interventionID","scenarioID","collection","doc","get","then","data","verifyDocument","collectionId","documentId","a","where","set","empty","getLog","logID","id","getDebriefLog","LogList","useState","logs","setLogs","logsLoaded","setLogsLoaded","useEffect","querySnapshot","docs","map","label","scenario","scenarioName","userName","timestamp","result","catch","error","Table","striped","borderless","size","hover","to","colorTypes","iconTypes","assessmentEntries","phaseStatusList","absent","errors","good","leafStatusList","misordered","misorderedErrors","exceptionDefs","exceptions","globalConstraints","before","beforeOp","after","afterOp","type","conditionalConstraints","scenarioConstraintIDs","intvChecks","intvStatusNeeded","vitalsNeeded","pushNew","elt","array","includes","push","getPhaseStatus","statuses","itemStatuses","phaseStatuses","forEach","status","entries","key","value","getStatesForStatus","stateList","state","getAssessmentEntry","currentEntry","aIndex","assessmentEntry","displayColor","getColor","fixStrSp","textString","newString","textArray","split","lenTextArray","item","i","newItem","trim","getFeedback","intvStatus","intvStatusFB","fb","checked","notChecked","entry","foundCk","generateIntvStatusFB","feedbackString","feedbackArray","firstChar","charAt","substring","previousString","slice","nextString","toUpperCase","scenarioConstraints","getEvents","events","field","val","getEventsByIdTime","_","require","saveAnalysisLog","actions","hierAssessResults","hierProblemResults","constraintsViolated","docRef","ObserverFileCreater","ObserverFileName","commenter","schemaVersion","Date","toLocaleString","newActionsList","newObj","filterUnknown","logObj","index","undefined","pickBy","getTimestamp","seconds","toISOString","substr","groupByKey","listOfObjs","fldName","reduce","hash","obj","concat","getChecklistItemsByType","itemType","checkListMetaData","e","allAssessResults","allProblemResults","getEntriesUnderHeader","headerID","level","populate","header","mergeHeaderStatuses","results","itemIDs","filtered","eventItems","inPhase","phaseID","subtype","overallStatus","headerStatuses","headerItems","translateEvent","event","newEvent","labelID","expertPhase","fld","summarizeAnalysis","finalActions","problems","requiredPhaseAndSubPhases","requiredPhaseNames","prob","probLabel","headerObject","entryToModify","origAction","section","subLevel","topLevel","constraint","arg1","workingPhase","phaseOrderStatus","arg2","summary","newStatus","updateTopHeaders","assess","probs","bogusAnalysis","top","table","topHier","othersToInclude","summarize_topLevel","requiredSubphases","itemByID","itemByLabel","checklistHierarchy","problemStates","cautionStates","subPhases","initGlobals","scen","constraintIDs","initializeConstraints","initializeItemLookupByID","initializeItemLookupByLabel","phases","clSteps","stepOptions","step","phChecklistSteps","subPhase","spChecklistSteps","sp","items","phSubphases","ph","getChecklistHierarchy","findPhaseSubphasesOrdered","intvLookupByID","checklistLookupByID","interventions","intvMetaData","assign","intvLookupByLabel","checklistLookupByLabel","subPhIds","findNameNumID","names","occurrence","numericalID","numericalIDStart","numericalIDEnd","unknownItem","getItem","findObjByNumerialID","phaseNames","phaseIndex","phaseObjects","phaseName","hasSubPhases","storeMisOrderedArgs","objToModify","saveFailedConstraint","lateArg","otherArg","constraintID","op","addToListOfFeedback","parPhFB","last","repeating","toLowerCase","checkAgainst2ndArgs","arg1st","args2nd","direction","entryNames","constraintType","endNum1st","startNum1st","label1st","phFB","par1PhFB","par2PhFB","counter","violations","arg","arg2nd","label2nd","startNum2nd","endNum2nd","FB","orderingFB","appendString","storeMisOrderedFB","checkAgainstKB","listOfNames","listOfEntries","uniqueListOfNames","startIndex","endIndex","phaseObjectNames","collectEntriesToCheckConstraints","uniqueEntryNames","firstArg","firstArgItem","constraints","getConstraint","checkConstraintsForArg","insertInPhaseInOrder","object","objIndex","phase","when","lastIndexOf","splice","getEndSubPhaseIndex","inPhaseId","subPhaseName","getSubPhases","reversedSubPhases","reverse","find","getEndSubPhase","phaseId","determineHLcolor","lowerColor","higherColor","newColor","evalForIncorrectAnswer","promptID","answerID","isIntervention","answers","associations","checkListCorrectness","Array","isArray","ansId","getCorrectAnswerLabel","metaData","answerLabels","answer","j","getAnswerLabel","answerLabel","insertMissingInterventions","confirmedEvents","indexCounter","action","k","phaseObject","phaseVal","assessments","assessmentsNeeded","protocols","protocol","actionDescription","suggestedPhase","string","protocolRelationship","orderedArrayObjects","objectsBefore","objectBefore","requiredObjectBefore","required","objectAfter","requiredObjectAfter","indexBefore","indexAfter","indexRequiredBefore","indexRequiredAfter","insertionIndex","findIndex","insertInPhaseRelativeToSuggestedOrder","analyzeEvents","problemDefs","problemActions","defs","sols","problemDef","problem","solutionID","solutions","sol","problemID","lifeThreat","vitals","actEntries","assessmentID","otherActions","actIDs","act","minimalWhy","contraindications","minimal","optional","allProblemProtocols","setupProblems","formattedActions","annotatedResults","interventionsConfirmed","trackForStatus","priorPhase","parentPhase","parentIndex","newPhaseStart","assessmentTypes","eventObj","eventType","processingState","prioreventObj","correctAnswerLabel","givenAnswerLabel","wrongAnswer","answerDetails","intervention","pop","answerCorrect","incorrectAnswersFB","vital","vitalType","vitalEntry","vitalEntries","updatedEntries","updateVital","PROBLEM_ACTION_FIELDS","statusChecking","intv","initialEntry","contra","incorrectAnswerFB","annotateInputEvents","intvsTracking","kbUpdates","updatedPhases","priorPh","insertMissingSubphases","postAssessmentReview","neededScenAssessments","collectScenAssessments","checklistSteps","md","exceptionDef","exception","why","cls","assessmentFB","assessmentFindings","checkForMissingAssessments","postInterventionReview","statusTracking","toUpdate","insertMissingIntvChecks","displayObjects","entryIndex","headerIndex","problemHeaderColor","subPhaseColor","subPhaseStatuses","newPhaseObjects","headerObj","subHeaderObj","priorHLPhaseItem","endEntry","iPhaseObjects","subheader","localPhaseName","localPhaseItem","highLevelPhase","highLevelPhaseItem","organizeLogDisplay","pActions","pNames","pIndex","pActIndex","indexOf","processedIds","pIds","pEntry","actionNeeded","minimalNeeded","found","allActionFound","allMinimalFound","numericalIDsChanged","foundId","z","candidateHeader","foundHeader","findHeaderFor","summaryResults","MDBNavBar","title","leftNav","rightNav","useContext","AuthContext","isAuthenticated","signOutUser","Navbar","color","dark","NavbarBrand","href","Nav","NavbarText","tag","Button","onClick","DisplayBaseDebriefing","context","showCommentColumn","setShowCommentColumn","setFormattedActions","getLabel","vitalLabel","regularLabel","getStatusLabel","metaEntry","me","findingsData","phaseLabel","finding","saveComment","orig","target","defaultValue","comment","entryID","newEntry","updateFormattedAction","dispDataRow","className","rows","cols","onBlur","record","rec","displayIt","style","overflowY","maxHeight","colSpan","AnalyzeDebriefing","useParams","observerLog","setObserverLog","setLog","setScenario","analyzed","setAnalyzed","loaded","setLoaded","checkOnOverwriting","window","confirm","analyzeEventsHook","observerLogData","alert","scenData","processEvents","logData","Log","DisplayDebriefing","processLog","UnauthedLayout","props","children","App","exact","path","authFlowLayout","component","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d3fd4384.chunk.js","sourcesContent":["import firebase from 'firebase/app'\nimport \"firebase/auth\";\nimport \"firebase/firestore\"\n\nconst prodFirebaseCfg = {\n    apiKey: \"AIzaSyBOgWAbXUGckpad2sk0IUo00hZsV4WxG0E\",\n    authDomain: \"meddbriefer-68cd4.firebaseapp.com\",\n    projectId: \"meddbriefer-68cd4\",\n    storageBucket: \"meddbriefer-68cd4.appspot.com\",\n    messagingSenderId: \"1087114796018\",\n    appId: \"1:1087114796018:web:679fbab38dbf78af0ce96b\",\n    measurementId: \"G-Q7QZKC9KHW\"\n}\n\nconst devFirebaseCfg = {\n    apiKey: \"AIzaSyBqnEMwEstp4D7Mvtbw9OTAiNJ7qza0Ses\",\n    authDomain: \"meddbriefer-dev.firebaseapp.com\",\n    projectId: \"meddbriefer-dev\",\n    storageBucket: \"meddbriefer-dev.appspot.com\",\n    messagingSenderId: \"144940722070\",\n    appId: \"1:144940722070:web:4de179ebb58d84a7679fb7\"\n};\n\n\nconst pamFirebaseCfg = {\n    apiKey: \"AIzaSyB9eVT-fu4TOjxHoPAXqsnz9tCcbTJkTOw\",\n    authDomain: \"pamdev-ea800.firebaseapp.com\",\n    projectId: \"pamdev-ea800\",\n    storageBucket: \"pamdev-ea800.appspot.com\",\n    messagingSenderId: \"366450927885\",\n    appId: \"1:366450927885:web:caa5f022ef1de182a0e844\",\n    measurementId: \"G-JC5XZEPYT1\"\n  };\n\n  const scottFirebaseConfig = {\n  apiKey: \"AIzaSyBEhbIdVW2F2vvvfvpNb2SsCDP9Yoc__z8\",\n  authDomain: \"scottdev-f6528.firebaseapp.com\",\n  projectId: \"scottdev-f6528\",\n  storageBucket: \"scottdev-f6528.appspot.com\",\n  messagingSenderId: \"447730403122\",\n  appId: \"1:447730403122:web:1727020dbac4ad4cf6f92b\"\n\n};\n\n// console.log(`NODE_ENV: ${process.env.NODE_ENV}`)\n\nlet userApp\n\nconst getApp = (appID) => {\n    const matches = firebase.apps.filter(app => app.options.appId === appID)\n    // console.log(\"matches\", matches)\n    return (matches.length === 1) ? matches[0] : null\n}\n\nconst getOrInitializeApp = (appCfg, name) => {\n    const app = getApp(appCfg.appId)\n    // console.log(`${appCfg.appId} already exists: ${!!app}`)\n    return (!!app) ? app : firebase.initializeApp(appCfg, name)\n}\n\n// don't reinitialize app if it already exists\n// const prodApp = !firebase.apps.length ? firebase.initializeApp(prodFirebaseCfg) : firebase.app()\n//const prodApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\nif (\"pam\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using pjordan config\")\n    userApp = getOrInitializeApp(pamFirebaseCfg, \"pam\")\n} else if (\"scott\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using scott config\")\n    userApp = getOrInitializeApp(scottFirebaseConfig)\n}\nelse {\n    console.log(\"using production config\")\n    userApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\n}\n\nconst prodApp = userApp;\n// const devApp = function() {\n//     if (process.env.NODE_ENV !== \"production\") {\n//         return getOrInitializeApp(devFirebaseCfg, \"development\")\n//      }\n//      return null\n// }()\n\n// console.log(firebase.apps)\n\n\n\n\nexport const auth = prodApp.auth()\nexport const db = prodApp.firestore()\n\n// export const db = function() {\n//     return process.env.NODE_ENV !== \"production\" ? devApp.firestore() : prodApp.firestore()\n// }()\n","// the following constants are deprecated (need to figure out how to handle this)\n// use MDB_TYPES, SELECTION_TYPES, PREFIXES, and SYSTEMS instead\nexport const ANSWER = \"answer\"\nexport const ASSESS = \"assessment\"\nexport const ASSESSO = \"assessment-option\"\nexport const ASSESS_OPTION = \"assessment-option\"\nexport const AWO = \"assessment-with-options\"\nexport const CB = \"checkbox\"\nexport const CL_HEADING = \"checklist-heading\"\nexport const CL_PROMPT = \"checklist-prompt\"\nexport const CRIT_FAIL = \"critical-criteria\"\nexport const DECISION = \"decision\"\nexport const DECISION_OPTION = \"decision-option\"\nexport const DIST_PROMPT = \"distinguishing-prompt\"\nexport const HEADING = \"heading\" //not a leaf node, simply a step which has child steps\nexport const INTERV = \"intervention\" // an action performed on the patient\nexport const INTV_FORM = \"intervention-form\"\nexport const NESTED_CHECKLIST = \"nested-checklist\"\nexport const NONE = \"none\"\nexport const ONE = \"one\"\nexport const OOM = \"one-or-more\"\nexport const OPTION = \"option\"\nexport const PHASE = \"phase\"\nexport const PROMPT = \"prompt\"\nexport const PROMPT_SET = \"prompt-set\"\nexport const REQUIRED = \"required-action\"   // an action the EMT performs, but not on the patient\n// keeping as I had a typo. need to deprecate somehow\nexport const REQURED = REQUIRED\nexport const SUB_PHASE = \"sub-phase\"\n\nexport const MDB_TYPES = Object.freeze({\n    PHASE: PHASE,\n    SUB_PHASE: SUB_PHASE,\n    ASSESS: ASSESS,\n    AWO: AWO,\n    ASSESS_OPTION: ASSESS_OPTION,\n    ASSESSO: ASSESS_OPTION,\n    CL_HEADING: CL_HEADING,\n    CL_PROMPT: CL_PROMPT,\n    DECISION: DECISION,\n    DECISION_OPTION: DECISION_OPTION,\n    DIST_PROMPT: DIST_PROMPT,\n    NESTED_CHECKLIST: NESTED_CHECKLIST,\n    REQUIRED: REQUIRED,\n    REQURED: REQUIRED,\n    INTERV: INTERV,\n    PROMPT_SET: PROMPT_SET,\n    PROMPT: PROMPT,\n    ANSWER: ANSWER,\n})\nexport const SELECTION_TYPES = Object.freeze({\n    ONE: ONE,\n    OOM: OOM,\n    NONE: NONE\n})\nexport const SELECTION_TYPE_LABELS = Object.freeze({\n    ONE: \"One\",\n    OOM: \"One or more\",\n    NONE: \"None\"\n})\nexport const PREFIXES = Object.freeze({\n    PHASE: \"\",\n    SUB_PHASE: \"\",\n    ANSWER: \"answer-\",\n    ASSESS: \"assess-\",\n    AWO: \"assessment-with-options-\",\n    ASSESS_OPTION: \"assess-option-\",\n    CL_PROMPT: \"cl-prompt-\",\n    DECISION: \"decision-\",\n    DECISION_OPTION: \"decision-option-\",\n    INTERV: \"intv-\",\n    PROMPT_SET: \"prompt-set-\",\n    PROMPT: \"prompt-\",\n    REQUIRED: \"required-action-\",\n})\n\nexport const SYSTEMS = Object.freeze({\n    AW: \"airway\",\n    BR: \"breathing\",\n    BL: \"bleeding\",\n    SH: \"shock\",\n})\nexport const SYSTEM_LABELS = Object.freeze({\n    AW: \"Airway\",\n    BR: \"Breathing\",\n    BL: \"Bleeding\",\n    SH: \"Shock\"\n})\n\nexport const CHECKLIST_STEP_TYPES = [ASSESS, AWO, DECISION, REQUIRED]\nexport const OPTION_TYPES = [ASSESS_OPTION, DECISION_OPTION]\nexport const ANALYSIS_TYPES = [ASSESS, AWO, DECISION, REQUIRED, INTERV, PHASE, SUB_PHASE]\n\nexport const PROTOCOL_RELATIONSHIPS = Object.freeze({\n    NONE: \"\",\n    MIN: \"minimal\",\n    OPT: \"optional\",\n    REQ: \"required\",\n    CONTRA: \"contraindicated\",\n    UNN: \"unnecessary\",\n    IR: \"irrelevant\"\n})","\nimport _ from \"lodash\"\n\nimport { MDB_TYPES } from \"./constants.js\"\nimport { ScenarioType, PublishedScenario } from \"./types.js\"\n\n// the rest of these imports can go away soon. simply allows me to delete objects form the db\n// and reload with files. not used if records exist in db\nimport INTVS from \"./intvs.js\"\nimport INTV_PROMPTS from \"./intvPrompts.js\"\nimport INTV_PROMPT_ANSWERS from \"./intvPromptAnswers.js\"\nimport INTV_MENU_CATS from \"./intvMenusCats.js\"\nimport INTV_MENU_ITEMS from \"./intvMenuItems.js\"\n\nexport const loadIntvs = () => {\n    const tmp = INTVS.map(e => {\n        const rec = {...e}\n        if (!e.abbrLabel) {\n            rec.abbrLabel = e.label\n        }\n        if (!e.distPrompts) {\n            rec.distPrompts = []\n        }\n        if (!e.prompts) {\n            rec.prompts = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPrompts = () => {\n    const tmp = INTV_PROMPTS.map(e => {\n        const rec = {...e}\n        if (!!e.interventionID) {\n            const found = INTVS.find(i => i.id === e.interventionID)\n            if (!found) {\n                console.log(`loadIntvPrompts(${e.id}) ${e.interventionID} not found`)\n            }\n        }\n        if (!e.abbrLabel) {\n            rec.abbrLabel = \"\"\n        }\n        if (!e.feedback) {\n            rec.feedback = rec.label\n        }\n        if (!e.answers) {\n            rec.answers = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPromptAnswers = () => {\n    const tmp = INTV_PROMPT_ANSWERS.map(e => {\n        if (!e.abbrLabel) {\n            e.abbrLabel = \"\"\n        }\n        const found = INTV_PROMPTS.find(p => p.id === e.promptID)\n        if (!found) {\n            console.log(`loadIntvPromptAnswers(${e.id}) ${e.promptID} not found`)\n        }\n        return e\n    })\n    return tmp\n}\n\nexport const getScenarios = (db, scenarioType, schemaVersion) => {\n    const query = db.collection(\"scenarios\")\n             .where(\"scenarioType\", \"==\", scenarioType)\n             .where(\"schemaVersion\", \"==\", schemaVersion)\n    return query.get()\n        .then(snapShot => {\n            const scenarios = []\n            if (snapShot.size > 0) {\n                snapShot.docs.forEach(doc => {\n                    const data = doc.data()\n                    scenarios.push({\n                        id: data.id,\n                        name: data.name,\n                        scenarioType: data.scenarioType,\n                        schemaVersion: data.schemaVersion\n                    })\n                })\n            }\n            return scenarios\n        })\n}\n\nexport const getPublishedScenarioObjectByID = async (db, scenarioID) => {\n    const data = await getPublishedScenarioByID(db, scenarioID)\n    return new  PublishedScenario(data)\n}\n\nexport const getPublishedScenarioByID = (db, scenarioID) => {\n    return db.collection(\"published-scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByID = (db, scenarioID) => {\n    return db.collection(\"scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByName = (db, scenarioName, schemaVersion) => {\n    return db.collection(\"scenarios\")\n    .where(\"name\", \"==\", scenarioName)\n    .where(\"schemaVersion\", \"==\", schemaVersion)\n    .limit(1)\n    .get()\n    .then(snapShot => {\n        if (snapShot.size === 1) {\n            return snapShot.docs[0].data()\n        } else {\n            throw new Error(\"document not found\")\n        }\n    })\n}\n\nconst addMissingScenarioTypeFields = (scenTypeData) => {\n    const msgs = []\n    if (!scenTypeData.interventions) {\n        msgs.push(\"loading intvs from file\")\n        scenTypeData.interventions = loadIntvs()\n    }\n    if (!scenTypeData.interventionPrompts) {\n        const errs = []\n        const tmpPrompts = loadIntvPrompts()\n        tmpPrompts.forEach(e => {\n            if (e.type === MDB_TYPES.PROMPT) {\n                // ignore this check if distinguishing prompt (not associated with a single intv)\n                if (undefined === scenTypeData.interventions.find(rec => rec.id === e.interventionID)) {\n                    errs.push(`bad interventionID ${e.interventionID}`)\n                }\n            }\n        })\n        let msg = \"loading intv prompts from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPrompts = tmpPrompts\n    }\n    if (!scenTypeData.interventionPromptAnswers) {\n        const errs = []\n        const tmpPromptAnswers = loadIntvPromptAnswers()\n        tmpPromptAnswers.forEach(e => {\n            if (undefined === scenTypeData.interventionPrompts.find(rec => rec.id === e.promptID)) {\n                errs.push(`bad promptID ${e.promptID}`)\n            }\n        })\n        let msg = \"loading intv prompt answers from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPromptAnswers = tmpPromptAnswers\n    }\n    if (!scenTypeData.interventionMenuCategories) {\n        msgs.push(\"loading intv menu categories from file\")\n        scenTypeData.interventionMenuCategories = INTV_MENU_CATS\n    }\n    if (!scenTypeData.interventionMenuItems) {\n        const errs = []\n        const tmpIntvMenuItems = INTV_MENU_ITEMS.map(e => {\n            const found = scenTypeData.interventionMenuCategories.find(cat => cat.id === e.intvCategoryID)\n            if (!found) {\n                errs.push(`bad intvCategoryID ${e.intvCategoryID}`)\n            } else {\n                if (e.type === MDB_TYPES.INTERV) {\n                    const intv = scenTypeData.interventions.find(i => i.id === e.interventionID)\n                    if (!intv) {\n                        errs.push(`bad interventionID ${e.interventionID}`)\n                    } else {\n                        e.label = intv.label\n                    }\n                }\n                return e\n            }\n        })\n        let msg = \"loading intv menu items from file...\"\n\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionMenuItems = tmpIntvMenuItems\n    }\n    if (msgs.length > 0) {\n        msgs.forEach(m => console.log(m))\n    } else {\n        console.log(\"all data loaded from db. files not needed\")\n    }\n    return scenTypeData\n}\n\nexport const getScenarioTypeObjectByID = async (db, scenarioTypeID) => {\n    const data = await getScenarioTypeByID(db, scenarioTypeID)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeObject = async (db, scenarioType, schemaVersion) => {\n    const data = await getScenarioType(db, scenarioType, schemaVersion)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeByID = (db, scenarioTypeID) => {\n    return db.collection(\"scenario-types\")\n        .doc(scenarioTypeID)\n        .get()\n        .then(doc => {\n        const data = doc.data()\n        data.id = doc.id\n        return addMissingScenarioTypeFields(data)\n        })\n        .catch(error => {\n            console.log(error)\n            return error\n        })\n}\n\nexport const getScenarioType = (db, scenarioType, schemaVersion) => {\n    return db.collection(\"scenario-types\")\n            .where(\"name\", \"==\", scenarioType)\n            .where(\"schemaVersion\", \"==\", schemaVersion)\n            .limit(1)\n            .get()\n            .then(snapShot => {\n                if (snapShot.size === 1) {\n                    return addMissingScenarioTypeFields(snapShot.docs[0].data())\n                } else {\n                    throw new Error(\"document not found\")\n                }\n            })\n}\n\n\n\n// FIXME: this needs to go away, although I need to figure out if it's in use anywhere first\nexport const getPromptAndOptions = (scenarioTypeOrPubScenario, promptID) => {\n    const scenType = scenarioTypeOrPubScenario\n    const prompt = scenType.interventionPrompts.find(e => e.id === promptID)\n    if (!!prompt) {\n        const options = prompt.answers.map(ansID => scenType.interventionPromptAnswers.find(a => a.id === ansID))\n        prompt.options = options.map(opt => {\n            return {...opt, prompt: prompt.label}\n        })\n    }\n    return prompt\n}\n\n// moved over from apps/data-entry/src/scripts/connect-firebase\n// added 'db' as first param so that these functions can be used either from web or server firebase APIs\n/**\n * Verify document doesn't already exist in database.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns True if document with given ID doesn't exist yet.\n */\nexport const verifyDocument = async (db, collectionId, documentId) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    return set.empty;\n};\n\n// returns true if combo of name and schemaVersion fields is unique\nexport const verifyDocNameUniqueness = async (db, collectionID, candidateName, dbNameField, schemaVersion) => {\n    const snapshot = await db.collection(collectionID)\n        .where(dbNameField, \"==\", candidateName)\n        .where(\"schemaVersion\", \"==\", schemaVersion)\n        .get()\n    return snapshot.empty\n}\n\n// Upload document object to database\nexport const publishDocument = async (db, collectionId, documentObject, documentId) => {\n    documentId\n        ?\n        await db.collection(collectionId).doc(documentId).set(documentObject) :\n        await db.collection(collectionId).doc().set(documentObject);\n};\n\n// Update document with given id\nexport const updateDocument = async (db, collectionId, documentId, documentObject) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    set.empty ?\n        publishDocument(collectionId, documentObject) :\n        await db.collection(collectionId).doc(set.docs[0].id).set(documentObject);\n};\n\n/**\n * Will save document, using auto-generated IDs if documentObject doesn't have\n * an 'id' attribute.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {object} documentObject\n */\nexport const saveDocument = async (db, collectionId, documentObject) => {\n    const doc = (!documentObject.id) ?\n        db.collection(collectionId).doc() :\n        db.collection(collectionId).doc(documentObject.id);\n    documentObject.id = doc.id;\n    await doc.set(documentObject);\n    return documentObject.id\n}\n\n/**\n * Query collection for document with id\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns {object} Object containing document data.\n */\nexport const getDocument = async (db, collectionId, documentId) => {\n    const doc = await db.collection(collectionId).doc(documentId).get();\n    return doc.data();\n};\n\n/**\n * Query collection for document with name\n * @param {string} collectionId\n * @param {string} documentName\n * @returns {object} Object containing document data.\n */\nexport const getDocumentWithName = async (db, collectionId, documentName) => {\n    const set = await db.collection(collectionId).where(\"name\", \"==\", `${documentName}`).get();\n    return set.docs[0]?.data();\n};\n\n/**\n * Delete document from collection\n * @param {string} collectionId\n * @param {string} documentId\n */\nexport const deleteDocument = async (db, collectionId, documentId) => {\n    await db.collection(collectionId).doc(documentId).delete();\n};\n\n/**\n * Pull collection from database as array of document objects\n * @param {string} collectionId\n * @returns {object[]} An array containing all of the document in the collection.\n */\nexport const getCollection = async (db, collectionId) => {\n    const collection = await db.collection(collectionId).get();\n    return collection.docs?.map(item => item.data());\n};\n\n// copied over from /apps/debriefer/src/scripts/connect-firebase and 'db' param added as first param\n\n// Get a list of document names and a copy of each document\nexport const listDocumentNames = async (db, collectionId) => {\n    let documentList = db.collectionGroup(collectionId);\n    let documentDictionary = {};\n    documentList.get().then((querySnapshot) => {\n        querySnapshot.forEach((doc) => {\n            documentDictionary[doc.id] = doc.data();\n        });\n    });\n    return documentDictionary;\n}\n\nexport const getLogs = (db) => {\n    return db.collection(\"logs\").get()\n        .then(querySnapshot => {\n            return querySnapshot.docs.map(doc => {\n                const data = doc.data()\n                return {\n                    id: doc.id,\n                    label: data.label,\n                    scenario: data.scenarioName,\n                    userName: data.userName,\n                    timestamp: data.timestamp\n                }\n            })\n        })\n}\n\n\nexport const getLog = (db, logID) => {\n    return db.collection(\"logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const getDebriefLog = (db, logID) => {\n    return db.collection(\"debriefing-feedback-logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const createInterventionVariant = (distPromptIds2OptIds) => {\n    // the list of opt IDs mapped to each distPromptID needs to be sorted in order\n    // to make them comparable\n    const retVal = {}\n    Object.entries(distPromptIds2OptIds).forEach(([distPromptID, optionsArray]) => {\n        retVal[distPromptID] = optionsArray.sort()\n    })\n    return retVal\n}\n\nexport const interventionVariantsAreEqual = (intvVariant1, intvVariant2) => {\n    return _.isEqual(intvVariant1, intvVariant2)\n}\n\n","import { MDB_TYPES, SELECTION_TYPES as ST } from \"@meddbriefer/scenario-data/constants.js\"\n\nconst INTV_PROMPTS = [\n    {\n        \"id\": \"prompt-wound-location\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.ONE,\n        label: \"Where is the wound located?\",\n        abbrLabel: \"Wound location?\",\n        answers: [\n            \"answer-wound-location-head\",\n            \"answer-wound-location-neck\",\n            \"answer-wound-location-chest\",\n            \"answer-wound-location-abdomen-pelvis\",\n            \"answer-wound-location-posterior\",\n            \"answer-wound-location-genitalia\",\n            \"answer-wound-location-left-lower-extremity\",\n            \"answer-wound-location-right-lower-extremity\",\n            \"answer-wound-location-left-upper-extremity\",\n            \"answer-wound-location-right-upper-extremity\",\n            \"answer-wound-location-other\"\n        ]\n    },\n    {\n        \"id\": \"prompt-wound-locations\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.OOM,\n        label: \"Where are the wound(s) located?\",\n        abbrLabel: \"Wound location(s)?\",\n        answers: [\n            \"answer-wound-locations-head\",\n            \"answer-wound-locations-neck\",\n            \"answer-wound-locations-chest\",\n            \"answer-wound-locations-abdomen-pelvis\",\n            \"answer-wound-locations-posterior\",\n            \"answer-wound-locations-genitalia\",\n            \"answer-wound-locations-left-lower-extremity\",\n            \"answer-wound-locations-right-lower-extremity\",\n            \"answer-wound-locations-left-upper-extremity\",\n            \"answer-wound-locations-right-upper-extremity\",\n            \"answer-wound-locations-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-airway-patency-suction-device\",\n        \"interventionID\": \"intv-airway-patency-technique-suction-airway\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What kind of suction catheter will you use?\",\n        \"abbrLabel\": \"Suction catheter type?\",\n        \"answers\": [\n            \"answer-airway-patency-suction-yankauer\",\n            \"answer-airway-patency-suction-long-multiuse\",\n            \"answer-airway-patency-suction-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-advanced-airway-adjunct-type\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of advanced airway adjunct would you use?\",\n        \"abbrLabel\": \"Which advanced airway?\",\n        \"answers\": [\n            \"answer-alternative-rescue-airway-type-ett\",\n            \"answer-alternative-rescue-airway-type-combitube\",\n            \"answer-alternative-rescue-airway-type-lta\",\n            \"answer-alternative-rescue-airway-type-lma\",\n            \"answer-alternative-rescue-airway-type-igel\",\n            \"answer-alternative-rescue-airway-type-other\"\n        ]\n    }, {\n        \"id\": \"prompt-advanced-airway-tube-size\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\":\"one\",\n        \"label\": \"What tube size for advanced airway?\",\n        \"abbrLabel\": \"What size?\",\n        \"answers\": [\n            \"answer-alternative-airway-tube-size-7\",\n            \"answer-alternative-airway-tube-size-8\",\n            \"answer-alternative-airway-tube-size-age-div-4-plus-4\",\n            \"answer-alternative-airway-tube-size--age-div-4-plus-4-minus-5\",\n            \"answer-alternative-airway-tube-size-37f\",\n            \"answer-alternative-airway-tube-size-41f\",\n            \"answer-alternative-airway-tube-size-0\",\n            \"answer-alternative-airway-tube-size-1\",\n            \"answer-alternative-airway-tube-size-1-5\",\n            \"answer-alternative-airway-tube-size-2\",\n            \"answer-alternative-airway-tube-size-2-5\",\n            \"answer-alternative-airway-tube-size-3\",\n            \"answer-alternative-airway-tube-size-4\",\n            \"answer-alternative-airway-tube-size-5\",\n            \"answer-alternative-airway-tube-size-6\",\n            \"answer-alternative-airway-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-orotracheal-intubation-tube-insertion-depth\",\n        \"interventionID\": \"intv-orotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what depth would you insert the tube?\",\n        \"abbrLabel\": \"Tube insertion depth?\",\n        \"answers\": [\n            \"answer-orotracheal-intubation-tube-insertion-depth-21cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-23cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-3-times-tube-size\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasotracheal-intubation-tube-size\",\n        \"interventionID\": \"intv-nasotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What tube size would you use?\",\n        \"abbrLabel\": \"Tube size?\",\n        \"answers\": [\n            \"answer-nasotracheal-intubation-tube-size-6-to-6-5\",\n            \"answer-nasotracheal-intubation-tube-size-7-to-7-5\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus1\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus0-5\",\n            \"answer-nasotracheal-intubation-tube-size-0-5-1cm-less-than-oro-size\",\n            \"answer-nasotracheal-intubation-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasal-cannula-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-nasal-cannula-flow-rate-1-6-lpm\",\n            \"answer-nasal-cannula-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-nasal-cannula-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-nasal-cannula-target-saturation-gt-90-pct\",\n            \"answer-nasal-cannula-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-non-rebreather-mask-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-flow-rate-10-15-liters-min\",\n            \"answer-non-rebreather-mask-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-non-rebreather-mask-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-target-saturation-gt-90-pct\",\n            \"answer-non-rebreather-mask-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-bvm-ventilation-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what rate will you ventilate the patient?\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n            \"answer-bvm-ventilation-rate-10-12-bpm\",\n            \"answer-bvm-ventilation-rate-other\",\n        ]\n    }, {\n        \"id\": \"prompt-bvm-flow-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What flow rate would you administer?\",\n        \"abbrLabel\": \"Flow rate?\",\n        \"answers\": [\n            \"answer-bvm-flow-rate-15-ltm-or-gt\",\n            \"answer-bvm-flow-rate-other\",\n        ]\n    },{\n        \"id\": \"prompt-bvm-target-saturation\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-bvm-target-saturation-rate-gt-90-pct\",\n            \"answer-bvm-target-saturation-rate-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-tourniquet-placement-close-to-core-far-from-wound\",\n            \"answer-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-2nd-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the second tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-2nd-tourniquet-placement-adjacent-to-initial-tourniquet\",\n            \"answer-2nd-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-occlusive-dressing-injury-type\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-occulsivive-dressing-injury-type-open-pneumothorax\",\n            \"answer-occulsivive-dressing-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-occlusive-dressing-method\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How would you create a release valve on an occlusive dressing?\",\n        \"abbrLabel\": \"How would you create a release valve?\",\n        \"answers\": [\n            \"answer-occulsive-dressing-method-leave-one-side-untaped\",\n            \"answer-occulsive-dressing-method-leave-dressing-with-one-way-valve\",\n            \"answer-occulsive-dressing-method-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-pleural-decompression-injury-type\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-pleural-decompression-injury-type-tension-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-open-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-side-of-the-body\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"On which side of the body would you place the needle?\",\n        \"abbrLabel\": \"Which side would you place the needle?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-right\",\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-left\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-anatomical-landmark\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what anatomical landmark?\",\n        \"abbrLabel\": \"At what anatomical landmark?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-2nd-or-3rd-intercostal-space-mid-clavicular\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-4th-or-5th-intercostal-space-mid-axillary\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-size\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What size needle do you want to use?\",\n        \"abbrLabel\": \"Needle size?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-size-large-bore\",\n            \"answer-pleural-decompression-needle-size-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-length\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How long a needle would you use?\",\n        \"abbrLabel\": \"Needle length?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-length-2-inches-or-longer\",\n            \"answer-pleural-decompression-needle-length-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-transport-facility-choice\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of care facility will you transport the patient to?\",\n        \"abbrLabel\": \"Type of receiving facility\",\n        \"answers\": [\n            \"answer-transport-facility-choice-level-1-or-2-trauma-center\",\n            \"answer-transport-facility-choice-level-3-or-4-trauma-center\",\n            \"answer-transport-facility-choice-closest\",\n            \"answer-transport-facility-choice-other\"\n        ]\n    },{\n        \"id\": \"prompt-transport-method\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you transport this patient by air or ground ambulance?\",\n        \"abbrLabel\": \"Air or ground ambulance?\",\n        \"answers\": [\n            \"answer-transport-method-ambulance\",\n            \"answer-transport-method-helicopter\"\n        ]\n    },{\n        \"id\": \"prompt-transport-lights-siren-decision\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you use lights and sirens with this patient?\",\n        \"abbrLabel\": \"Lights and sirens?\",\n        \"answers\": [\n            \"answer-transport-lights-sirens-yes\",\n            \"answer-transport-lights-sirens-no\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-splint-type\",\n        \"interventionID\": \"intv-splint-fractures\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of splint would you use?\",\n        \"abbrLabel\": \"Type of splint?\",\n        \"answers\": [\n            \"answer-splint-type-board\",\n            \"answer-splint-type-moldable\",\n            \"answer-splint-type-traction\",\n            \"answer-splint-type-pelvic-binder\",\n            \"answer-splint-type-other\"\n        ]\n    },\n\n]\n/*\n    {\n        \"id\": \"\",\n        \"interventionID\": \"\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n        ]\n    },\n*/\nexport default INTV_PROMPTS","const INTV_MENU_ITEMS = [\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-als\",\n        \"label\": \"ALS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-amputation\",\n        \"label\": \"Manage amputation\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-bls\",\n        \"label\": \"BLS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-crico\",\n        \"label\": \"Cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-establish-patency\",\n        \"label\": \"Establish patency\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-insert-adjunct\",\n        \"label\": \"Insert adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-intubation\",\n        \"label\": \"Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-internal-bleeding\",\n        \"label\": \"Manage suspected internal bleeding\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-shock\",\n        \"label\": \"Manage hemorrhagic shock\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-medication-facilitated-intubation\",\n        \"label\": \"Medication Facilitated Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-open-airway\",\n        \"label\": \"Open airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-remove-foreign-body-obstructions\",\n        \"label\": \"Remove foreign body obstructions\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n         \"depth\": 1,\n         \"type\": \"heading\",\n         \"id\": \"heading-severe-external-bleeding\",\n         \"label\": \"Manage severe external bleeding\",\n         intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transfer\",\n        \"label\": \"Transfer patient to EMS vehicle\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transport\",\n        \"label\": \"Transport to care facility\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-advanced-airway-adjunct\",\n        interventionID: \"intv-advanced-airway-adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-airway-patency-technique-suction-airway\",\n        interventionID: \"intv-airway-patency-technique-suction-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-apply-sterile-dressings\",\n        interventionID: \"intv-apply-sterile-dressings\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-back-blows-and-chest-thrusts\",\n        interventionID: \"intv-back-blows-and-chest-thrusts\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-direct-pressure\",\n        interventionID: \"intv-control-severe-bleeding-technique-direct-pressure\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-2nd-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        interventionID: \"intv-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pressure-bandage\",\n        interventionID: \"intv-control-severe-bleeding-technique-pressure-bandage\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-load-and-go\",\n        interventionID: \"intv-control-severe-bleeding-technique-load-and-go\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-keep-patient-warm\",\n        interventionID: \"intv-control-shock-technique-keep-patient-warm\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-high-concentration-o2\",\n        interventionID: \"intv-control-shock-technique-administer-high-concentration-o2\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-place-patient-supine-position\",\n        interventionID: \"intv-control-shock-technique-place-patient-supine-position\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-iv-boluses\",\n        interventionID: \"intv-control-shock-technique-administer-iv-boluses\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-heimlich-maneuver\",\n        interventionID: \"intv-heimlich-maneuver\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-keep-body-part-cool\",\n        interventionID: \"intv-keep-body-part-cool\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-magill-forceps-assisted\",\n        interventionID: \"intv-magill-forceps-assisted\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-manual-finger-sweep\",\n        interventionID: \"intv-manual-finger-sweep\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasopharyngeal-airway\",\n        interventionID: \"intv-nasopharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-needle-cricothyrotomy\",\n        interventionID: \"intv-needle-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-occlusive-dressing\",\n        interventionID: \"intv-occlusive-dressing\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-head-tilt\",\n        interventionID: \"intv-open-airway-method-head-tilt\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-modified-jaw-thrust\",\n        interventionID: \"intv-open-airway-method-modified-jaw-thrust\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-oropharyngeal-airway\",\n        interventionID: \"intv-oropharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-orotracheal-intubation\",\n        interventionID: \"intv-orotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-body-part-in-bag\",\n        interventionID: \"intv-place-body-part-in-bag\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-immobilized-patient-on-stretcher\",\n        interventionID: \"intv-place-immobilized-patient-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-pleural-decompression\",\n        interventionID: \"intv-pleural-decompression\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-pain-nausea-vomiting-medications\",\n        interventionID: \"intv-prepare-and-administer-pain-nausea-vomiting-medications\",\n        intvCategoryID: \"intv-cat-manage-pain-nausea-vomiting\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-sedative\",\n        interventionID: \"intv-prepare-and-administer-sedative\",\n        intvCategoryID: \"intv-cat-sedate-agitated-or-combatitive-patient\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-retrieve-amputated-body-part\",\n        interventionID: \"intv-retrieve-amputated-body-part\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sedation-assisted-intubation\",\n        interventionID: \"intv-sedation-assisted-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-slat\",\n        interventionID: \"intv-slat\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-attach-cid\",\n        interventionID: \"intv-spinal-immobilization-technique-attach-cid\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-cervical-collar\",\n        interventionID: \"intv-spinal-immobilization-technique-cervical-collar\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-manual-c-spine-stabilization\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine2\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-transfer-to-device\",\n        interventionID: \"intv-spinal-immobilization-technique-transfer-to-device\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures2\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sterile-dressing-soft-tissue\",\n        interventionID: \"intv-sterile-dressing-soft-tissue\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-nasal-cannula\",\n        interventionID: \"intv-supplemental-oxygen-device-nasal-cannula\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-non-rebreather-mask\",\n        interventionID: \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-surgical-cricothyrotomy\",\n        interventionID: \"intv-surgical-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-walk-patient\",\n        interventionID: \"intv-transfers-patient-method-walk-patient\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-place-directly-on-stretcher\",\n        interventionID: \"intv-transfers-patient-method-place-directly-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport\",\n        interventionID: \"intv-transport\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport-body-part-to-receiving-facility\",\n        interventionID: \"intv-transport-body-part-to-receiving-facility\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-ventilation-technique-bag-valve-mask\",\n        interventionID: \"intv-ventilation-technique-bag-valve-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-wrap-body-part-in-saline-soaked-gauze\",\n        interventionID: \"intv-wrap-body-part-in-saline-soaked-gauze\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    }\n]\n\nexport default INTV_MENU_ITEMS","import { useEffect, useState } from \"react\"\n\nimport { Link } from \"react-router-dom\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLogs } from \"@meddbriefer/scenario-data/index\"\n\nimport { Table } from \"reactstrap\"\nconst LogList = () => {\n    const [logs, setLogs] = useState([])\n    const [logsLoaded, setLogsLoaded] = useState(false)\n\n    useEffect(\n        () => {\n            getLogs(db)\n            .then(result => {\n                setLogs(result)\n                // console.log(result)\n                setLogsLoaded(true)\n            })\n            .catch(error => console.log('error fetching logs', error))\n        },\n        []\n    )\n\n    if (!logsLoaded) {\n        return (<h4>fetching log data</h4>)\n    }\n    return (\n        <Table striped={true} borderless size=\"sm\" hover>\n            <thead>\n                <tr>\n                    <th>Label</th>\n                    <th>Scenario</th>\n                    <th>Username</th>\n                    <th>Timestamp</th>\n                </tr>\n            </thead>\n            <tbody>\n                {logs.map(log => (\n                    <tr key={log.id}>\n                        <td>{log.label}</td>\n                        <td>{log.scenario}</td>\n                        <td>{log.userName}</td>\n                        <td>{log.timestamp}</td>\n                        <td>\n                            <Link to={`/logs/${log.id}`}>Analyze</Link>&nbsp;&nbsp;&nbsp;&nbsp;\n                            <Link to={`/debriefing-feedback-logs/${log.id}`}>Review</Link>\n                        </td>\n                    </tr>\n                ))}\n            </tbody>\n        </Table>\n    )\n\n}\n\nexport default LogList","\n\n  export const colorTypes = {\n    \"Good\": \"text-success\",\n    \"Caution\": \"text-warning\",\n    \"Problem\": \"text-danger\",\n    \"Not implemented\": \"text-muted\"\n}\n\nexport const iconTypes = {\n    \"Good\": \"sentiment_satisfied\",\n    \"Caution\": \"report_problem\",\n    \"Problem\": \"highlight_off\",\n    \"Not implemented\": \"sentiment_neutral\"\n}\n\n//Feedback substitute commands for feedback template\n//@ means substitute this entry field into the feedback template and if no value in field say this in feedback, \n//? means substitute this entry field into the feedback template if the value exists,\n//+bos adds period to end sentence, two spaces and capitalizes first letter of what follows\n//+eos adds a period with no preceding spaces\n\n//assessmentEntries states are used by analyzeEvents, condition1 and condition2, but the rest is used only by condition 1\nexport const assessmentEntries = {\n    // state: [categorization for feedback, feedback template for condition 1]\n    \"contraindicated\": [\"Problem\", \"You should not have done this action because it is contraindicated in this case +bos ?contraindicatedWhy +bos ?why +eos\"],\n    \"irrelevant\": [\"Problem\", \"You should not have done this action because it is irrelevant in this case +bos ?why +eos\"],\n    \"unnecessary\": [\"Problem\", \"You should not have done this action because it is unnecessary in this case +bos ?why +eos\"],\n    \"missingMinimal\": [\"Problem\", \"You did not do this action +bos ?why +eos\"],\n    \"missingOptional\": [\"Caution\", \"You did not do this action +bos but it was optional in this case +bos ?why +eos\"],\n    \"missingRequired\": [\"Problem\", \"You did not do this action +bos ?why +eos\"],\n    \"missingRequiredAssessment\": [\"Problem\", \"You did not do this action +bos ?assessmentFB +eos\"],\n    \"notNecessary\": [\"Caution\", \"You should not have done this action because it was unnecessary +bos ?why +eos\"],  //applies only to assessment items\n\n    //note that missing/wrong items cannot be an argument in a misordering of events so there states will not get combined with misOrdered states\n\n    //not yet implemented\n   // \"missedProblem\": [\"Problem\", \"The following should alert you to @problem: +items @problemAssessments\"],  //need to add status and fields to analysis code still and +item formatting below\n \n    \"assessment\": [\"Good\", \"\"],\n    \"assessment-option\": [\"Good\", \"\"],\n    \"decision-option\": [\"Good\", \"\"],\n    \"required-action\": [\"Good\", \"\"],\n    \"goodIntv\": [\"Good\", \"?intvStatusFB +eos \"],\n    \n\n    \"misOrdered-assessment\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-assessment-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-decision-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-required-action\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-goodIntv\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n\n    \"misOrdered-phase-assessment\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-assessment-option\": [\"Good\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-decision-option\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n    \"misOrdered-phase-required-action\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n    \"misOrdered-phase-goodintv\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n\n    //doubt that status checks can be misordered\n    \"intvCheckWNoIntvFound\": [\"Caution\", \"You didn't do this intervention so it doesn't make sense to check the status of it at this point.\"],\n    \"unexpectedPatientIntvCheck\": [\"Caution\", \"This status check is not likely to reveal any useful information.\"],  //nothing indicates a need to check that this intv worked\n    \"patientIntvCheck\": [\"Good\", \"\"], //as long as the intervention was done it is fine to request it\n    \"patientVitalCheck\": [\"Good\", \"\"],  //currently any patient vital check that is done is fine\n\n\n    \"assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],  \n    \"incorrect-answers\": [\"Problem\", \"Doing this action is correct but there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal-incorrect-answers\": [\"Problem\", \"Doing this action was correct and would solve the problem but you did not follow protocol +bos ?minimalWhy +bos also there is a problem with how you planned to do this intervention +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal\": [\"Caution\", \"Doing this action is correct and solves the problem but you did not follow protocol +bos @minimalWhy +bos ?intvStatusFB +eos \"],\n\n   \n    \"misOrdered-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos @minimalWhy +bos ?intvStatusFB +eos\"],\n        \n    \n    \"misOrdered-phase-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-incorrect-answers\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos ?minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos ?minimalWhy +bos ?intvStatusFB +eos\"],\n    \n    \"green\": [\"Good\", \"\"],  //just for headers\n    \"red\": [\"Problem\", \"\"], //just for headers\n    \"yellow\": [\"Caution\", \"\"], //just for headers\n    //\"notFound\": [\"Not implemented\", \"Assessment knowledge is not yet specified\", []],\n    \"default\": [\"Not implemented\", \"This action was not expected.  There could be an issue with how this scenario is represented within the system.\"]\n}\n","export const phaseStatusList = {\n    absent: [\"absent\", \"missingMinimal\", \"missingRequired\", \"missingRequiredAssessment\"],\n    errors: [\"misOrdered-assessment\", \"misOrdered-assessment-option\", \"misOrdered-decision-option\", \"misOrdered-required-action\", \"misOrdered-goodIntv\",\n    \"assessment-option-incorrect\", \"decision-option-incorrect\", \"incorrect-answers\", \"minimal-incorrect-answers\", //\"minimal\", \n    \"misOrdered-assessment-option-incorrect\", \"misOrdered-decision-option-incorrect\", \"misOrdered-incorrect-answers\", \"misOrdered-minimal-incorrect-answers\",\n    \"misOrdered-minimal\", \n    \"misOrdered-phase-assessment-option-incorrect\", \"misOrdered-phase-decision-option-incorrect\", \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\",\n        ],\n    good: [\"good\", \"assessment\", \"assessment-option\", \"decision-option\", \"required-action\", \"goodIntv\", \n        //condition 2 does not address these so put them in the good category\n        \"patientIntvCheck\", \"patientVitalCheck\", \"irrelevant\", \"unnecessary\", \"contraindicated\", \"notNecessary\",\n        \"intvCheckWNoIntvFound\", \"unexpectedPatientIntvCheck\",  \"default\",\n        //condition 2 does not need to address minimal as an error nor misordered-phase as that error appears as misordered at the phase or subphase level\n        //condition 1 uses misOrdered-Phase as that error feedback goes on the first line in the phase/subphase\n        //so without misOrdered-phase and/or minimal, these are good status values\n        \"minimal\", \"misOrdered-phase-minimal\",\n        \"misOrdered-phase-assessment\", \"misOrdered-phase-assessment-option\", \"misOrdered-phase-decision-option\", \"misOrdered-phase-required-action\", \"misOrdered-phase-goodIntv\",\n        ]  \n}\n\nexport const leafStatusList = {\n    absent: [\"missingMinimal\", \"missingRequired\", \"missingRequiredAssessment\"],\n    misordered: [\"misOrdered-assessment\", \"misOrdered-assessment-option\", \"misOrdered-decision-option\", \"misOrdered-required-action\", \"misOrdered-goodIntv\", \"misOrdered-minimal\"],\n    misorderedErrors: [\"misOrdered-assessment-option-incorrect\", \"misOrdered-decision-option-incorrect\", \"misOrdered-incorrect-answers\", \"misOrdered-minimal-incorrect-answers\",\n    \"misOrdered-phase-assessment-option-incorrect\", \"misOrdered-phase-decision-option-incorrect\", \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\"],\n    errors: [\"assessment-option-incorrect\", \"decision-option-incorrect\", \"incorrect-answers\", \"minimal-incorrect-answers\"],\n    good: [\"assessment\", \"assessment-option\", \"decision-option\", \"required-action\", \"goodIntv\", \n        //condition 2 does not address these so put them in the good category\n        \"patientIntvCheck\", \"patientVitalCheck\", \"irrelevant\", \"unnecessary\", \"contraindicated\", \"notNecessary\",\n        \"intvCheckWNoIntvFound\", \"unexpectedPatientIntvCheck\",  \"default\",\n        //condition 2 does not need to address minimal as an error nor misordered-phase as that error appears as misordered at the phase or subphase level\n        //condition 1 uses misOrdered-Phase as that error feedback goes on the first line in the phase/subphase\n        //so without misOrdered-phase and/or minimal, these are good status values\n        \"minimal\", \"misOrdered-phase-minimal\",\n        \"misOrdered-phase-assessment\", \"misOrdered-phase-assessment-option\", \"misOrdered-phase-decision-option\", \"misOrdered-phase-required-action\", \"misOrdered-phase-goodIntv\",\n        ]  \n}\n","// defines which assessment steps are not required per scenario.  Provides feedback on\n// why the step is not required.\nexport const exceptionDefs = \n[{scenarioName: \"M2CA\", exceptions: [\n    [\"required-action-obtain-OPQRST\", \"This cannot be assessed when GCS < 15\"],\n    [\"assess-opqrst-info\", \"This cannot be assessed when GCS < 15\"]\n    ]}\n  ]\n  \n/* This starts section on defining temporal constraints, conditional constraints and implications.*/\n\n/*temporal constraints are an\nindex of event labels with two lists as values.\nThe first value is a list of event labels that the indexed event\nshould precede (if any) and the second value is a list of event\nlabels that the indexed event should follow after (if any)\n*/\n\nexport const globalConstraints = {\n    // event < list of other events, > list of other events\n    // lookup by event id to see the list of event ids that it should go before\n    // and after, and the type of constraint. \n    // included constraints type with values of policy, commonSense and both.  These may be used in future to\n    // decide any lead in to feedback about a constraint violation\n    // type policy operators are usually \"ands\", type commonsense operators are ususally \"ors\" because\n    // the ordering is looser than with policy ordering.  An operator can be blank if only one item is listed for the\n    // before or for the after.  No software should be written to expect\n    // this tendency between type and operators to hold.\n\n    //Note that: \n    //- for now the software will use either the label or id to lookup constraints but id\n    // is preferred.\n    //- a key (first item on each line) is the first arg in the constraints and is\n    //  assumed to have just one constraint applicable to\n    //  it but may appear as the second arg in a constraint multiple times (2nd args are\n    //  lists under before or after fields)\n    //- when something is a phase or subphase with multiple actions then we look for the begining\n    //  and ending actions for constraint checking.  If overlap in phases is to be allowed the constraint should\n    //  be amongst lower level items and no higher level constraint should be included\n    //= there is no check to make sure the constraints expressed do not conflict.  For example,\n    //  saying a whole phase should be before another phase and that a particular item in the second\n    //  phase can go before some other item in the first phase are in conflict with one another\n\n\n    // Note: looks like I may need to allow multiple constraints to be listed under an arg1 key.  Shouldn't be\n    // difficult to do but waiting to see if it is truly necessary first.  While most constraints for arg1 could\n    // be combined in the list below, there is an issue with adding in scenario specific conditional constraints\n    // that are expressed in a different structure.\n\n    //\"\": {id: \"T\", before: [\"\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \n    // T1\n    \"scene-size-up\": {id: \"T1\", before: [\"primary-survey\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T2\n    \"primary-survey\": {id: \"T2a\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    //listing the below any intervention that I think are always going to address a life threat\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"T2b\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {id: \"T2c\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {id: \"T2d\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T3\n    \"ints-call-for-helicopter\": {id: \"T3\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T4\n    \"required-action-obtains-vitals\": {id: \"T4\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T5\n    \"required-action-attempt-obtain-sample\": {id: \"T5a\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"required-action-obtain-OPQRST\": {id: \"T5b\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T6 is in scenario specific constraints\n    // T7\n    \"intv-transfer\": {id: \"T7\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\", \"breathing\", \"circulation\"], afterOp: \"\", type: \"policy\"},\n    // T8\n    \"trauma-expose\": {id: \"T8\", before: [\"chest\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T9\n    \"general-impression\": {id: \"T9\", before: [\"airway\", \"breathing\", \"circulation\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    // T10\n    \"intv-spinal-immobilization-technique-manual-c-spine\": {id: \"T10a\", before: [\"airway\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-spinal-immobilization-technique-cervical-collar\": {id: \"T10b\", before: [\"airway\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T11 was deleted per discussion with Sandy\n    // T12 is in scenario specific constraints\n    // T13\n    \"intv-airway-patency-technique-suction-airway\": {id: \"T13\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\"], afterOp: \"\", type: \"policy\"},\n    // T14\n    \"intv-airway-patency-technique-suction-airway\": {id: \"T14\", before: [\"intv-oropharyngeal-airway\", \"intv-nasopharyngeal-airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T15\n    \"intv-oropharyngeal-airway\": {id: \"T15a\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \n                                  \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-nasopharyngeal-airway\": {id: \"T15b\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \n                                  \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T16 awaiting observer interface implementation decisions on how contacting medical command will be recorded\n    // T17\n    \"intv-ventilation-technique-bag-valve-mask\": {id: \"T17\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T18 and T19 are constraints involving intervention checks and need to be discussed in a group meeting\n    \n    //used during testing\n    //state that ongoing management plan should go after the entirety of everything listed in after\n    //\"ongoing-mgmt-plan\": {id: \"c2\", before: [ ], beforeOp: \"\", after: [\"bsi\", \"scene-size-up\", \"primary-survey\", \"history-taking\",\"secondary-assessment\"], afterOp: \"and\", type: \"commonSense\"},\n    // have two second args in below because some of Observer logs have one of these ids and some have the other\n    //\"assess-injury-mechanism\": {id: \"c7\", before: [\"required-action-consider-stabilization-of-spine\", \"required-action-considers-stabilize-spine\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"commonSense\"},\n    //\"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"c8\", before: [\"intv-control-severe-bleeding-technique-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n    //\"intv-control-severe-bleeding-technique-tourniquet\": {id: \"c9\", before: [\"intv-control-severe-bleeding-technique-2nd-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n     \n}\n\n//constraints that depend on whether certain conditions hold within a scenario\n//based on the scenario and the constraint ids listed under the scenario in\n//scenarioConstraintIDs, the constaints defined here with the ids for the current\n//scenario will be added to the general constraints about for temporal constraint testing\n\n// Used convention of appended -c and a one up number just to indicate it is a conditional constraint.  No software\n// requires this convention for the ids so it can be changed\n\nexport const conditionalConstraints = {\n    // first is a hold over from testing for M2CA\n    \"assess-major-bleeding\": {id: \"c1\", before: [\"airway\",\"breathing\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-transport\" : {id: \"T2-c1\", before: [\"into-establish-IV\", \"intv-control-shock-technique-administer-iv-boluses\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"}, \n    \"secondary-assessment\": {id: \"T6-c1\", before: [\"intv-transfer\", \"ongoing-mgmt-plan\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"pulse-checks\": {id: \"T12-c1\", before: [\"airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"}\n    \n    \n}\n\n\n// used to simulate conditional constraints, i.e. we hardcode which conditional constraint ids as\n// defined under conditionalConstraints (above) are relevant to each scenario\n\n// although one could put global constraint ids under scenarios here, it would be redundant and may cause software\n// issues\nexport const scenarioConstraintIDs = {\n    \"M2CA\": [\"c1\", \"T6-c1\"],\n    \"B4CA\": [],\n    \"B7CA\": [],\n    \"SC8CP\": [\"T2-c1\",\"T6-c1\", \"T12-c1\"],\n    //\"\": [],\n    //\"\": []\n}\n\n\n//below are examples of interventions in which status should be checked.  The key intvStatusNeeded\n//is true or false.  If true it means should have requested status of this intervention.  If vitals key is\n//not empty then should have checked all of these vitals as well.  Will only check entries after an intervention\n//up until something other than an intervention check is done\n\n//updates wrt SC8CP-combined-goals-4-4\nexport const intvChecks = {\n    \"intv-nasopharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-oropharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-orotracheal-intubation\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-ventilation-technique-bag-valve-mask\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\" ]},\n    \"intv-sedation-assisted-intubation\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\"]},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},\n    //test cases for now.  First 3 are likely to become relevant for scenarios like M2CA\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []}, \n    //\"intv-control-shock-technique-administer-iv-boluses\": {intvStatusNeeded: false, vitalsNeeded: [\"BP\"]},\n        \n    }\n\n","import { formatAsMinSecs } from \"../utils\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport {colorTypes, iconTypes, assessmentEntries, phaseStatusList} from \"@meddbriefer/feedback-data\"\nimport { scenarioConstraintIDs, conditionalConstraints, globalConstraints } from \"@meddbriefer/feedback-data\"\n\n   \nexport const pushNew = (elt,array) => {\n    if (!array.includes(elt)) {\n        array.push(elt)\n    }\n}\n\nexport const getPhaseStatus = (statuses) => {\n    //for collecting first unique item statuses and then\n    //unique phase statuses\n    let itemStatuses = []\n    let phaseStatuses = []\n\n    //get a unique list of item status values\n    statuses.forEach(status => {\n        pushNew(status,itemStatuses)\n        /* if (!itemStatuses.includes(status)){\n            itemStatuses.push(status)\n        } */\n    })\n    \n    //turn the item status values into phase level status values\n    let res\n    for (const [key, val] of Object.entries(phaseStatusList)) {\n        res = val.filter(value => itemStatuses.includes(value))\n        //if there is an intersection, save the key (i.e. is unique)\n        if (res.length !== 0)\n            pushNew(key,phaseStatuses)\n            /* if (!phaseStatuses.includes(key)){\n                phaseStatuses.push(key)} */\n        }\n\n    if (phaseStatuses.length === 1){return phaseStatuses[0]}  // to be absent or good, all entries must be good or absent\n    else {return \"errors\"}  //otherwise they are not all good to that translates to errors\n       \n    }\n\n\n\n// functions that extract info from above or create the feedback from the above \n\n//returns a list of all the state values associated with the input status (e.g. status is one of \"Problem\", \"Good\", \"Caution\")\nexport const getStatesForStatus = (status) => {\n    let stateList = []\n    for (const [state, entry] of Object.entries(assessmentEntries)) {\n        let stateStatus = entry[0]\n        if (stateStatus === status){\n            stateList.push(state)}\n        }\n    //console.log(\"In getStatesForStatus\", stateList)\n    return (stateList)}\n        \n\n//returns the entry under that state\nconst getAssessmentEntry = (currentEntry,aIndex) => {\n    let assessmentEntry = \"\"\n    if (currentEntry.type === \"header\"){\n        assessmentEntry = assessmentEntries[currentEntry.displayColor] \n        if (!assessmentEntry) {assessmentEntry = assessmentEntries[currentEntry.status]}\n    }\n    else{\n        if (!assessmentEntries[currentEntry.status]){\n            assessmentEntry = assessmentEntries[\"default\"]}\n        else{assessmentEntry = assessmentEntries[currentEntry.status]}}\n    if (assessmentEntry){\n        return assessmentEntry[aIndex]}\n}\n\n//returns the html icon to use in condition 1 for the state\nexport const getAssessmentIcon = (currentEntry) => {  \n    let val = iconTypes[getAssessmentEntry(currentEntry,0)]\n    return val;\n}\n\n//returns the html color to use in condition 1 for the state\nexport const getColor = (currentEntry) => {\n    return colorTypes[getAssessmentEntry(currentEntry,0)];\n}\n\n//add protexted spaces after a . except for the very last .  \n//Otherwise html reduces continguous regular spaces to a single space.\n//Need this for text strings that will appear in one array entry because\n//of substitution\nconst fixStrSp = (textString) => {\n    if (!!textString){\n        let textArray = textString.split(\" \");\n        let lenTextArray = textArray.length;\n        textArray.forEach((item, i) => {\n            let newItem = item.trim()\n            if (newItem[item.length-1] === \".\" && i < lenTextArray-1){\n                //add protected space to the string\n                newItem = newItem + \"\\xa0\\xa0\"}\n            textArray[i] = newItem \n        })\n        let newString\n        for (let item of textArray){\n            if (!!newString){\n            newString = newString + \" \" + item;}\n            else{newString = item}\n\n     }\n        //console.log(newString, textArray)\n        return newString}\n    else {return \"\"}\n}\n\nconst generateIntvStatusFB = (currentEntry) => {\n    let checked = []\n    let notChecked = []\n    let fb\n    for (let entry of currentEntry.intvStatus){\n        if (entry.foundCk){\n            checked.push(entry.label)}\n        else {notChecked.push(entry.label)}\n    }\n    if (notChecked.length > 0){\n        fb = \"Remember to check the effect of this action by asking for: \" + notChecked + \".\"\n        if (checked.length > 0){\n            fb = fb + \" That is in addition to what you did ask for: \" + checked + \".\"\n        }\n    }\n    return fb\n}\n\n\n\n\nexport const getFeedback = (currentEntry) => {\n    if (!!currentEntry.intvStatus && currentEntry.intvStatus.length > 0){\n        //add our generated feedback string to the currentEntry\n        currentEntry.intvStatusFB = generateIntvStatusFB(currentEntry)\n    }\n    let feedbackTemplate = fixStrSp(getAssessmentEntry(currentEntry,1)).trim()\n    //Find any @ actions in the template and substitute with the indicated entry field\n    let feedbackArray = feedbackTemplate.split(\" \");\n    //Process all @ substitutions first since +eos does one forward action\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let newString = item.substring(1)\n        //trim off excess blanks before and after each word\n        feedbackArray[i] = feedbackArray[i].trim()\n        switch(firstChar){\n            case \"@\":\n                if (!!currentEntry[newString])\n                    //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"[value for \" + newString + \" is missing]\" }\n                break\n            case \"?\":\n                if (!!currentEntry[newString])\n                //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"\"  \n                    if (feedbackArray[i-1]  === \"+bos\"){\n                        feedbackArray[i-1] = \"\"\n                        if (feedbackArray[i-2][feedbackArray[i-2].length-1] !== \".\"){\n                            feedbackArray[i-2] = feedbackArray[i-2] + \".\\xa0\"}\n                    }\n                    if (feedbackArray[i+1]  === \"+eos\"){feedbackArray[i+1] = \"\"}\n                }\n                break  \n            default:\n        }\n    })\n    //Now address the + actions in the template\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let previousString = \"\"\n        switch(firstChar){\n        case \"+\":\n            let afterPlusChar = item.substring(1)\n            switch(afterPlusChar){\n            case \"eos\":\n                //removes existing/redundant . if present so can be certain putting in single . \n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence and a protected space.  When stiched back into\n                //a single string a protected space will be added between each substring\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\"  //get rid of the command since was applied\n                break\n            case \"bos\":\n                //removes existing/redundant . if present so can put in single .\n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence .\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\" //get rid of the command since was applied\n                //Captitalize the beginning of the sentence\n                let nextString = feedbackArray[i+1].trim()\n                feedbackArray[i+1] = nextString.charAt(0).toUpperCase() + nextString.slice(1);\n                break\n            default:\n            }\n            break\n        default:\n    }}\n    )\n    //stitch back into a single string\n    let feedbackString\n    for (let item of feedbackArray){\n        if (!!feedbackString) {\n            if (item !== \"\"){\n                feedbackString = feedbackString + \"\\xa0\" + item;}} \n        else {if (item !== \"\"){feedbackString = item}}\n    }\n    //console.log(feedbackString)\n    return feedbackString\n}\n\n//built by the function initializeConstraints\nvar scenarioConstraints = {}\n\n// adds on scenario specific constraints where the constraint is only applicable if certain patient\n// conditions hold.  Since assessment callouts are text and have no associated representation, we\n// can yet implement true conditional constraints.\nexport const initializeConstraints = (scenarioName) => {\n    // look up applicable conditional constraints from const structure scenarioConstraintIDs \n    let constraintIDs = scenarioConstraintIDs[scenarioName] \n    scenarioConstraints = globalConstraints\n    for (const [key, val] of Object.entries(conditionalConstraints)) {\n            if (constraintIDs.includes(val.id)){\n                scenarioConstraints[key] = val\n            }\n        }\n}\n\n\n\n//gets one constraint since each id/label would be a key\n//in the constraints definitions\nexport const getConstraint = (item) => {\n    let id = item.id\n    let label = item.label\n    let constraints = scenarioConstraints[id] \n    if (!constraints){constraints = scenarioConstraints[label]}\n    return constraints \n}\n\n\n// This section is for looking up items in the analysis log\n\nexport const getEvents = (events,field,val) => {\n    return events.filter(entry => entry[field] === val)\n}\n\nexport const getEventsByIdTime = (events,id,timestamp) => {\n    return getEvents(getEvents(events,\"timestamp\",timestamp),\"id\",id)\n}\n\n// This ends the section for looking up items in the analysis log\n\n\n\n//This starts section for saving/loading the debriefing log\n    \nconst _ = require(\"lodash\"); \n\nexport const saveAnalysisLog = (log, actions, hierAssessResults, hierProblemResults, constraintsViolated) => {\n    console.log(\"In savingDebriefingLog\")\n    const docRef = db.collection(\"debriefing-feedback-logs\").doc(log.id)\n    let data = {\n        userName: log.userName,\n        ObserverFileCreater: log.userName,\n        label: log.label,\n        ObserverFileName: log.label,\n        commenter: \"\",\n        scenarioID: log.scenarioID,\n        scenarioName: log.scenarioName,\n        schemaVersion: log.schemaVersion,\n        timestamp: Date().toLocaleString(),\n        hierAssessResults: hierAssessResults,\n        hierProblemResults: hierProblemResults,\n        constraintsViolated: constraintsViolated\n    }\n\n    let newActionsList = [];\n    let newObj = {};\n    let filterUnknown = false;\n\n    //included for debugging puposes only\n    actions.forEach(function (logObj, index){\n        for (let [key, val] of Object.entries(logObj)) {\n            if (undefined === val) {\n                console.log(\"filtered out from events; index: \", index, \" key: \", key, \" value: \", val)\n                filterUnknown = true;}\n             }\n        }\n    )\n        \n    if (filterUnknown) {\n        actions.forEach(function (logObj, index) {\n            newObj = _.pickBy(logObj, function (value, key) {\n                return !(value === undefined);\n            });\n            newActionsList.push(newObj)\n        })\n        data[\"events\"] = newActionsList\n    }\n    else (data[\"events\"] = actions);\n\n\n    //data[\"events\"] = formattedActions;\n    //console.log(JSON.stringify(data, null, 4))\n    docRef.set(data) \n}\n\n//not in use\n\nexport const retrieveDebriefing = (log) => { \n    //console.log(log.events) \n    return (log.events)  \n}  \n\n//This ends section for saving/loading the debriefing log\n\n\n\nexport const getTimestamp = (currentEntry) => {\n    if (currentEntry.status === \"criticalActionHeader\") {\n        return \"\";\n    }\n    if (currentEntry.timestamp === -1) {\n        return \"\\xa0\\xa0\";  // formatAsMinSecs would convert this to 59:59\n    }\n    return formatAsMinSecs(currentEntry.timestamp);\n}\n\n\n","export const formatAsMinSecs = (seconds) => {\n    return new Date(seconds * 1000).toISOString().substr(14, 5)\n}","import { MDB_TYPES, CHECKLIST_STEP_TYPES, OPTION_TYPES } from \"@meddbriefer/scenario-data/constants\";\n\n// input: list of objects and a fieldName\n// returns: an object who's attributes are the distinct values for that fieldName mapped to the subset\n// of list items which share that field value\nexport const groupByKey = (listOfObjs, fldName) => listOfObjs.reduce(\n    (hash, obj) => ({ ...hash, [obj[fldName]]: (hash[obj[fldName]] || []).concat(obj) }),\n    {}\n)\n\nexport const getChecklistItemsByType = (scenario, itemType) => {\n    return scenario.checkListMetaData.filter(e => e.type === itemType)\n}\n\nexport const getChecklistItems = (scenario) => {\n  return scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(MDB_TYPES.PHASE, MDB_TYPES.SUB_PHASE))  \n}\n\nexport const getChecklistHierarchy = (scenario) => {\n    const phases = getChecklistItemsByType(scenario, MDB_TYPES.PHASE)\n    const subPhases = getChecklistItemsByType(scenario, MDB_TYPES.SUB_PHASE)\n    // filters out items which are display only\n    const clSteps = scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(e.type))\n    // get the options which are associated with some certain types of steps (decisions, assess w/options)\n    const options = scenario.checkListMetaData.filter(e => OPTION_TYPES.includes(e.type))\n    // map the options to their stepId\n    const stepOptions = groupByKey(options, \"parentID\")\n    // if a step has options, add them to that step\n    clSteps.forEach(step => {\n        if (step.id in stepOptions) {\n            step.options = stepOptions[step.id]\n        }\n    })\n    // figure out which checklist items belong to phases or subphases and group them by\n    // the their corresponding phase/subphase ids\n    const phChecklistSteps = groupByKey(clSteps.filter(e => undefined === e.subPhase), \"phase\")\n    const spChecklistSteps = groupByKey(clSteps.filter(e => !!e.subPhase), \"subPhase\")\n    // assign subphase steps to the appropriate subphase\n    subPhases.forEach(sp => {\n        sp.items = spChecklistSteps[sp.id]\n    })\n    // map subphases to their phase\n    const phSubphases = groupByKey(subPhases, \"phase\")\n    // phases have either items or subphases -not both. assign the appropriate stuff\n    // to each phase\n    phases.forEach(ph => {\n        if (ph.id in phChecklistSteps) {\n            ph.items = phChecklistSteps[ph.id]\n        } else {\n            ph.subPhases = phSubphases[ph.id]\n        }\n    })\n    return phases\n}","import { getPhaseStatus, pushNew} from \"./debriefingUtils\"\nimport {leafStatusList} from \"@meddbriefer/feedback-data\"\n\nlet allAssessResults = []\nlet allProblemResults = []\n\nconst getEntriesUnderHeader = (headerID,events,level,populate) => {\n    let header = mergeHeaderStatuses(headerID,events)\n    if (!!header) { \n        let results = [header]\n        let itemIDs = []\n        let filtered = []\n        if (populate){\n            let eventItems\n            if (level === 2){\n                eventItems = events.filter(e => (e.inPhase === headerID && e.type !== \"header\"))}\n            if (level === 1){\n                eventItems = events.filter (e => (e.phaseID === header.id && e.type === \"header\" && e.subtype === \"assessmentSubHeader\"))\n                //need to filter out duplicate subphases because may be some in the original events list\n                for (const item of eventItems){\n                    if (!itemIDs.includes(item.id)){\n                        itemIDs.push(item.id)\n                        filtered.push(item)}   \n                    }\n                eventItems = filtered\n                }\n            results = results.concat(eventItems)}\n       return results}\n    else {return false}\n }\n\n//merges header for a phase or subphase that is temporally split\nconst mergeHeaderStatuses = (headerID, events) => {\n    let overallStatus = \"unk\"\n    let headerStatuses = []\n    let headerItems = events.filter(e => e.type === \"header\" && e.id === headerID)\n    let header = headerItems[0]    \n    for (const item of headerItems){\n        //pushNew(item.phaseOrderStatus, headerStatuses)\n        pushNew(item.status, headerStatuses)}\n    if (headerStatuses.length > 0) {\n        if (headerStatuses.length === 1){overallStatus = headerStatuses[0]}\n        else {overallStatus = \"errors\"}  //must be all good or all absent for either of those to hold\n    }\n    if (!!header) {header.status = overallStatus}\n    return header \n}\n\n    // after phaseOrderStatus updated need to add that result to subphases status value\nconst updateTopHeaders = (summary) => {\n    let statuses = [\"good\"]\n    let newStatus\n    // eslint-disable-next-line no-unused-vars\n    for (const [key, entry] of Object.entries(summary)) {\n        if (entry[0].subtype === \"assessmentHeader\" && entry[0].status === \"good\") {\n            for (const item of entry.slice(1)) {\n                if (!!item.phaseOrderStatus){\n                    pushNew(item.phaseOrderStatus, statuses)}\n            }\n            if (statuses.length === 1) { newStatus = statuses[0] }\n            else { newStatus = \"errors\" }\n            if (!!newStatus){entry[0].status = newStatus}\n        }\n    }\n}\n\nfunction translateEvent(event) {\n    if ([\"irrelevant\", \"unnecessary\"].includes(event.status)) {\n        return {}}\n    else {\n        let newEvent = {}\n        //regularize some field names across headers and checklist events\n        if (event.labelID) {\n            newEvent.id = event.labelID}\n        else { newEvent.id = event.id }\n        if (event.type === \"header\") {\n            newEvent.subtype = event.id}\n        if (!!event.expertPhase) {\n            newEvent.inPhase = event.expertPhase}\n\n        //now copy over these fields\n        [\"label\", \"status\", \"phaseOrderStatus\", \"phase\", \"subPhase\", \"labelID\", \"phaseID\", \"probLabel\", \"answerCorrect\", \"answerDetails\", \"timestamp\", \"type\"].forEach(fld => {\n            if (!!event[fld]) {\n                newEvent[fld] = event[fld]}\n        })\n\n        //regularize status values in the case of good and absent\n        //did not regularize status values for errors yet, not sure if\n        //the details matter to condition 2\n        if (leafStatusList[\"good\"].includes(newEvent.status)) {\n            newEvent.status = \"good\"}\n        if (leafStatusList[\"absent\"].includes(newEvent.status)) {\n            newEvent.status = \"absent\"}\n        return newEvent\n    }\n}\n\n    \nexport const summarizeAnalysis = (finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated) => {\n    allAssessResults = []\n    allProblemResults = []\n    let hierAssessResults = {}\n    let hierProblemResults = {}\n    finalActions.forEach(event => {\n        if (event.type !== \"intervention\" && event.type !== \"answer\"){\n            allAssessResults.push(translateEvent(event))}\n        else {allProblemResults.push(translateEvent(event))}\n\n    }) \n    problems.forEach(prob => {\n        //let intvHeaderIndex = 1\n        let entries = allProblemResults.filter(e => (e.probLabel === prob.probLabel && e.type !== \"header\"))\n        let statuses = entries.map(e => e.status)\n        let status = getPhaseStatus(statuses)\n        let headerObject = {\n            \"id\": prob.probLabel,\n            \"probLabel\": prob.probLabel,\n            \"status\": status,\n            \"phaseOrderStatus\": \"good\",\n            \"subtype\": \"interventionHeader\",\n            \"type\": \"header\"\n        //    \"numericalID\": intvHeaderIndex++/2000,\n        //    \"displayColor\": \"green\",\n        //    \"why\": \"\",\n        //    \"protocol\": \"\"\n        };\n        if (entries){\n            hierProblemResults[prob.probLabel] = [headerObject].concat(entries)}\n\n    })\n\n    let subLevel = requiredPhaseAndSubPhases\n    let topLevel = requiredPhaseNames.filter(e => !subLevel.includes(e))\n    \n    //need to update status in headers for lower level first since those\n    //values will percolate upwards\n\n    subLevel.forEach(headerID  => {\n        let entries = getEntriesUnderHeader(headerID,allAssessResults,2,true)\n        //console.log(\"header = \", header, \"entries = \", entries)\n        if (entries){\n            hierAssessResults[headerID] = entries}})\n\n    topLevel.forEach(headerID => {\n        let entries = getEntriesUnderHeader(headerID,allAssessResults,1,true)\n        if (entries){\n            hierAssessResults[headerID] = entries}})\n        \n            \n    // store phase level contraint feedback at the header level for condition 2 \n    // (Note that for condition 1 it was stored during the analysis at the first\n    // event entry for a phase and is prefaced by misOrderedPhase in status so that\n    // it alone won't count as an error later for condition 2)\n    let entryToModify \n    let origAction\n    let section\n    let actions = {\n        ...hierAssessResults,\n        ...hierProblemResults}\n    constraintsViolated.forEach(constraint => {\n        origAction = finalActions.filter(e => ((!!e.labelID && e.labelID === constraint.arg1.id) || (e.id === constraint.arg1.id)))[0]\n\n        if (origAction.type === \"header\"){\n            section = actions[origAction.labelID]\n            entryToModify = section[0]}\n        else {\n            if (origAction.type === \"intervention\"){\n                section = actions[origAction.probLabel]\n            }\n            else {\n                section = actions[origAction.workingPhase]} \n            entryToModify = section.filter(e => e.id === constraint.arg1.id)[0]\n        }\n        if (!!entryToModify){\n            if (constraint.type === \"phase\"){\n                entryToModify.phaseOrderStatus = \"misOrdered\"\n                if (!entryToModify.arg2){\n                    entryToModify.arg2 = [constraint.arg2.id]}\n                else {entryToModify.arg2 = entryToModify.arg2.concat([constraint.arg2.id])}}\n            else{\n                if (!entryToModify.arg2){\n                    entryToModify.arg2 = [constraint.arg2.id]}\n                else {entryToModify.arg2 = entryToModify.arg2.concat([constraint.arg2.id])}}}\n    })\n    updateTopHeaders(hierAssessResults)\n\n    console.log(\"top-level-analysis: \", summarize_topLevel(hierAssessResults, hierProblemResults))\n\n    return [hierAssessResults, hierProblemResults]\n\n}\n\nconst topHier = [\"scene-size-up\", \"Manage a potential head and/or spinal injury\", \"primary-survey\", \"ongoing-mgmt-plan\"]\nconst othersToInclude = [\"airway\", \"breathing\"]\n\nfunction summarize_topLevel(assess,probs) {\n    let bogusAnalysis = {}\n    let top = []\n    let val\n    let table = {\n        ...assess,\n        ...probs}\n    let headerObject = {\n        \"id\": \"top\",\n        \"probLabel\": \"top\",\n        \"status\": \"errors\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\"}\n    top.push(headerObject)\n    topHier.forEach(key => {\n        val = table[key]\n        if (!!val){\n            bogusAnalysis[key] = val\n            top.push(val[0])}\n    })\n    othersToInclude.forEach(key => {\n        val = table[key]\n        if (!!val){\n            bogusAnalysis[key] = val}\n    })\n    bogusAnalysis[\"top\"] = top\n\nreturn bogusAnalysis\n}","import { MDB_TYPES, ANALYSIS_TYPES } from '@meddbriefer/scenario-data/constants.js';\nimport { getPhaseStatus, initializeConstraints, getConstraint, getStatesForStatus, saveAnalysisLog, getEventsByIdTime, //pushNew\n} from \"./debriefingUtils\"\nimport { intvChecks, exceptionDefs } from \"@meddbriefer/feedback-data/analysisData\"\nimport { getChecklistItemsByType, getChecklistHierarchy, groupByKey } from './scenarioDataAccesors';\nimport { summarizeAnalysis } from './summarizeAnalysis';\n//import { foo } from \"@meddbriefer/feedback-data\"\n\n//console.log(foo())\n\nconst problemStates = getStatesForStatus(\"Problem\")\nconst cautionStates = getStatesForStatus(\"Caution\")\nlet hierAssessResults \nlet hierProblemResults \nlet constraintsViolated \nlet insertInterventionHeader = false  //setting to true helps during debugging analysis, shows headers for problems\n//index of subphase names and value is phase id to which belongs\nlet subPhases = {}\n// list of all subphase IDs\nlet requiredSubphases\nlet requiredPhaseNames\nlet requiredPhaseAndSubPhases\nlet scenario\nexport var itemByID\nexport var itemByLabel\n// sts 1/23/22 - added as global\nlet checklistHierarchy\n\nfunction initGlobals(scen) {\n    scenario = scen\n    initializeConstraints(scen.name)\n    itemByID = initializeItemLookupByID(scen)\n    itemByLabel = initializeItemLookupByLabel(scen)\n    requiredPhaseNames = getChecklistItemsByType(scen, MDB_TYPES.PHASE).map(e => e.id).concat([\"Unknown\"])\n    requiredSubphases = getChecklistItemsByType(scen, MDB_TYPES.SUB_PHASE).map(e => e.id)\n    checklistHierarchy = getChecklistHierarchy(scen)\n    requiredPhaseAndSubPhases = findPhaseSubphasesOrdered(checklistHierarchy)\n    checklistHierarchy.forEach(ph => {\n        if (undefined === ph.subPhases) {\n            subPhases[ph.id] = ph.label} \n        else {\n            ph.subPhases.forEach(sp => {\n                subPhases[sp.id] = ph.label})}})\n    subPhases[\"Unknown\"] = \"Unknown\"\n    hierAssessResults = {}\n    hierProblemResults = {}\n    constraintsViolated = []\n}\n\n//This starts section for accessing checklist and intervention components by id or label\nconst initializeItemLookupByID = (scenario) => {\n    let checklistLookupByID = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let intvLookupByID \n    if (!!scenario.interventions){\n        intvLookupByID = groupByKey(scenario.interventions,\"id\")}\n    else {intvLookupByID = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")}\n    let result = Object.assign(checklistLookupByID, intvLookupByID)\n    return result}\n\nconst initializeItemLookupByLabel = (scenario) => {\n        let checklistLookupByLabel = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let intvLookupByLabel\n        if (!!scenario.interventions){\n            intvLookupByLabel = groupByKey(scenario.interventions,\"label\")}\n        else {intvLookupByLabel = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")}\n        let result = Object.assign(checklistLookupByLabel, intvLookupByLabel)\n        return result}\n\n\nconst findPhaseSubphasesOrdered = (phases) => {\n    let result = []\n    phases.forEach(ph => {\n        if (!!ph.subPhases){\n            let subPhIds = ph.subPhases.map(e => e.id)\n            //not currently useful to collect parent phases unless there were no subphases\n            //if parent phase included subphases and steps then it should be in this result\n            //result = result.concat(ph.id)\n            result = result.concat(subPhIds)\n        }\n        else {result = result.concat(ph.id)}})\n    return result\n}\n\nconst collectScenAssessments = (problems) => {\n    let assessments = []\n    problems.forEach(prob => {\n        if (prob.assessments !== \"\"){\n            assessments = assessments.concat(prob.assessments)}})\n    return assessments\n}\n\n//will need to update to comply with any relevant constraints on phases and subphases\n//currently looks for missing phases/subphases and inserts them into the analysis list\n//based on where last preceding phase appeared\nconst insertMissingSubphases = (phases,phaseNames) => {\n    let priorPh\n    requiredPhaseAndSubPhases.forEach((phase, i) => {\n        if (!phaseNames.includes(phase)) {\n            //find last index for phase before and splice that    \n            if (i === 0){\n                priorPh = requiredPhaseAndSubPhases[0]\n            }\n            else {priorPh = requiredPhaseAndSubPhases[i-1]}\n\n            let insertionIndex = 0\n            if (priorPh !== phase){\n                insertionIndex = phaseNames.lastIndexOf(priorPh)  //if prior phase was missing it will have been inserted earlier\n                insertionIndex = insertionIndex + 1}\n            \n            phaseNames.splice(insertionIndex, 0, phase); //insert it where it should have appeared\n            phases.splice(insertionIndex, 0, []); //add the empty array for phase objects\n        }});\n    return[phases,phaseNames]\n}\n\n\n//as vital requests and intervention requests are made, update that it was requested\n//if it is one that we are tracking for post intervention success.  \nconst updateVital = (vitalEntries, timestamp) => {\n    let updatedEntries = []\n    vitalEntries.forEach(vitalEntry => {\n        if (vitalEntry.timestamp < timestamp){\n            vitalEntry[\"foundCk\"] = true}\n        updatedEntries.push(vitalEntry)\n    })\nreturn updatedEntries\n}\n\n//initial review of observer log to add annotations to what was found in the observer log.  Filters out things not useful to\n//analysis or is not yet being analyzed in the codep.  It also\n// pulls together interventions and prompt answers into one event and adds fields to each event that will fill in in later analysis,\n// fills in problem information for interventions found in observer log and\n// sets up the phases and phaseNames structures for events in the observation log and initiates\n// record of what have encountered so far in the observations in order to recognize what is missing in later stages of analysis\nconst annotateInputEvents = (events,problems) => {\n    let confirmedEvents = [];\n    let interventionsConfirmed = [];  //needed for vital checking\n    //instead of a multi-dimensional array, am using an array of phase and subphase names e.g. \"BSI\", \"prinary\" ...\n    let phaseNames = [];\n    let phases = []; //and another array with the actual content for each phase.  I can search phaseNames for the index into phases\n    let phaseObjects = [];\n    let trackForStatus = {};  //save correct interventions that were done that require status checks later\n    \n\n    // phases entry of that name and then use that index to retrieve the appropriate phase entried to\n    //add on the missing items (assessment or intervention) for that phase\n    let priorPhase = \"\";\n    let parentPhase = \"\"\n    let parentIndex = 0\n    let phaseIndex = 0;\n    let newPhaseStart = true\n    let assessmentTypes = [\"assessment\", \"required-action\", \"decision-option\", \"assessment-option\"]\n\n    // created annotated object for each event\n    events.forEach((event, i) => {\n        // Each eventObj is one of the lines in the displayed base log\n        // Set up fields for extra annotations for this event after analyzing each event\n        let eventObj = {\n            \"comment\": \"\",\n            \"numericalID\": i,\n            \"status\": \"\",\n            \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n            \"contraindicatedWhy\": \"\",\n            \"minimalWhy\": \"\",\n            \"why\": \"\",\n            \"answerCorrect\": true,\n            \"answerDetails\": {},\n            \"expertPhase\": \"\",  //filled in only for interventions\n            \"workingPhase\": \"\",  //is subphase or if no suphase then the phase\n            \"suggestedPhase\": \"\", //mostly for interventions so don't override info on when was originally done\n            \"protocol\": \"\",\n            \"protocolRelationship\": \"\",\n            \"probLabel\": \"\",\n            \"assessments\": \"\",\n            \"required\": false,\n            \"actionDescription\": \"\",\n            \"assessmentFB\": \"\",\n            \"incorrectAnswersFB\": \"\",\n            \"orderingFB\": \"\",\n            \"processingState\": \"good\" // values of good/bad used to filter out events not needed for analysis or displaying\n        };\n\n        // copy over the event fields that exist in the input log from observer UI (which is type dependent)\n        const EVENT_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"vitalType\", \"vital\", \"value\", \"type\", \"prompt\", \"promptID\", \"intervention\", \"timestamp\"];\n        EVENT_FIELDS.forEach(fldName => {\n            if (!!event[fldName]) {\n                eventObj[fldName] = event[fldName];\n            }\n        });\n\n        //copy event fields if defined to initialize some of the above annotation fields\n        if (!!event.label) { eventObj.actionDescription = event.label; }\n        if (!!event.type) { eventObj.status = event.type; }\n        // prefer subPhase if available\n        if (!!event.subPhase) { eventObj.workingPhase = event.subPhase; }\n        else {\n            if (!!event.phase) { eventObj.workingPhase = event.phase; }}\n        eventObj.expertPhase = eventObj.workingPhase;\n\n        //if current phase same as prior then keep on with the current phase\n        // otherwise initialize for a new phase but don' let an intervention\n        // or intervention answer set a new phase since this info in event is\n        // not reliable  \n            \n        if (priorPhase !== eventObj.workingPhase || parentPhase !== eventObj.phase){ \n            if (priorPhase !== \"\" && assessmentTypes.includes(eventObj.type)) {  \n                //have a non initial phase change and we have an assessment type (i.e. we can't base phase changes on interventions)\n                newPhaseStart = true\n                phases[phaseIndex] = phaseObjects;\n                if (phaseIndex !== parentIndex){\n                    phases[parentIndex] = phases[parentIndex].concat(phaseObjects);  \n                }\n                phaseIndex++\n                \n                //if upcoming parent phase is different than current parent phase then set up\n                //for a new parent phase\n                if (eventObj.phase !== parentPhase){ \n                    parentPhase = eventObj.phase\n                    parentIndex = phaseIndex\n                    // if the upcoming is truly a parent with subphases \n                    // then add an extra entry for the new parent phase \n                    if (eventObj.phase !== eventObj.workingPhase) {\n                        //create the new parent phase\n                        phases[parentIndex] = []\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++\n                    }}}\n            else {\n                if (priorPhase === \"\" && assessmentTypes.includes(eventObj.type)){\n                // first item in events so initialize\n                    parentPhase = eventObj.phase\n                    // if the event parent phase is not the same as the subPhase\n                    // then we need to save that parent phase in phases and phaseNames\n                    if (parentPhase !== eventObj.workingPhase) {\n                        parentPhase = eventObj.phase\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++;}}\n                \n                else{ \n                    if (priorPhase === \"\"){\n                        //did an intervention before doing any assessments\n                        //so make up an initial phase of unknown\n                        parentPhase = \"Unknown\"\n                        eventObj.workingPhase = parentPhase\n                        eventObj.phase = parentPhase\n                        eventObj.subPhase = \"\" }\n                    else {newPhaseStart = false}}}\n\n                \n            \n            //now setup for collecting for the current phase if not skipping new phase start\n            if(newPhaseStart){\n                priorPhase = eventObj.workingPhase;\n                phaseObjects = [];\n                phaseNames[phaseIndex] = priorPhase;\n                phases[phaseIndex] = []}\n            else {newPhaseStart = true}\n            }\n        \n\n        let eventType = eventObj.type;\n        // List of types in log that are currently processed.  Rest are filtered out.\n        let processedTypes = [\"assessment\", \"required-action\", \"intervention\", \"answer\", \"obtain-vital-sign\", \"decision-option\", \"assessment-option\"];\n\n        //skip over adding anything not of these types to the debriefing display for now\n        if (!processedTypes.includes(eventType)) {\n            eventObj.processingState = \"bad\";\n        }\n\n        // when get an answer for an intervention prompt, grade the response.  The intervention itself is later in the event log, so\n        // accumulate the answers and grading and then when an intervention is later found we can use the intervention\n        // event itself and move all the answer results into it\n        let prioreventObj = [];\n        if (eventType === \"answer\") {\n            //make sure we have answer info for this promptID\n            let correctAnswerLabel = getCorrectAnswerLabel(event.promptID, true);\n            let givenAnswerLabel = getAnswerLabel(event.id, true);\n            //if we don't have answer info for this prompt ID then just ignore this entry\n            if (!correctAnswerLabel) {\n                eventObj.processingState = \"bad\"}\n            else {\n                //currently returns correct answer-id if has answered incorrectly or false if answered correctly\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, true);\n                //store details of this answer and its grading\n                let answerDetails = {\"correctAnswer\": correctAnswerLabel, \"givenAnswer\": givenAnswerLabel, \"correct\": !wrongAnswer}\n                \n                //have answer to prior question for this intervention \n                //(i.e. there is more than one question associated with this intervention)\n                if (confirmedEvents.includes(eventObj.intervention)) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    //add the answer student gave to the action description\n                    eventObj.actionDescription = prioreventObj.actionDescription + \", \" + givenAnswerLabel;\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        if (prioreventObj.incorrectAnswersFB === \"\") {\n                            eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                            }\n                        else {eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB + \", and \" + correctAnswerLabel;\n                            }}\n                    else {\n                        eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                        eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    }}\n                //first answer for this intervention\n                else { \n                    //put the answer student gave in the action description\n                    //responding to first question for the intervention\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                    }\n                    else { eventObj.incorrectAnswersFB = \"\"; }\n                    //pushNew(eventObj.intervention,confirmedEvents)\n                    confirmedEvents.push(eventObj.intervention)\n                }\n                //storing the prompt/answer details \n                eventObj.answerDetails[event.promptID] = answerDetails}}\n\n        if (eventType === \"intervention\") {\n            prioreventObj = phaseObjects.slice(-1)[0]; //slice returns an array rather than the last object in array\n            //check to find if prior phaseObjects contains an answer and if it does then consolidate that answer\n            //event into the associated intervention\n            if (prioreventObj && prioreventObj.type === \"answer\"){\n                if (prioreventObj.intervention === eventObj.id) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                    eventObj.actionDescription = eventObj.actionDescription + \".\\xa0\\xa0\" + prioreventObj.actionDescription}\n                else {\n                    prioreventObj = phaseObjects.pop();  //discard this answer, it is for an intervention that was not done\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                 }}\n        }\n\n        if (eventObj.processingState === \"good\") {\n\n            if (eventObj.type === \"obtain-vital-sign\"){\n                //if it is an intervention status check then the vital field contains\n                //the intervention id and otherwise the vital label\n                let vital = eventObj.vital \n                let type = \"\"\n                if (eventObj.vitalType === \"intervention-status\"){\n                    if (interventionsConfirmed.includes(vital)){\n                        type = \"intv\"}\n                    else {type = \"noIntv\"}\n                    }\n                else {type = \"vital\"}\n                \n                //update trackForStatus relative to this \"vital\"\n                let vitalEntry = trackForStatus[vital]  \n                //set the status for this particular vital (i.e. makes sense to ask for it or not)\n                switch (type){\n                    case \"intv\": \n                        eventObj.status = \"patientIntvCheck\"\n                        if (vitalEntry && (vitalEntry.timestamp < eventObj.timestamp)){\n                            vitalEntry[\"foundCk\"] = true\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    case \"noIntv\":\n                        eventObj.status = \"intvCheckWNoIntvFound\"\n                        break\n                    case \"vital\":\n                        eventObj.status = \"patientVitalCheck\" \n                        if (vitalEntry){\n                            vitalEntry = updateVital(vitalEntry,eventObj.timestamp)\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    default: eventObj.status = \"unexpectedPatientIntvCheck\"}\n\n\n                    \n            }\n            // add additional annotations per type\n            if (eventObj.type === \"intervention\") {\n                // iterate through all problem actions looking how to format the\n                // data structue for the current \"event\"\n                problems.forEach((prob, j) => {\n                    // We're going through intervention actions in the order required/needed and then other since\n                    // it is possible but unlikely to have multiple matches and we want the last one to win.\n                    // Also, we are assuming minimal is always a subset of goodintv\n                    const PROBLEM_ACTION_FIELDS = [\"why\", \"probLabel\", \"protocolRelationship\"];\n                    \n                    // check for this action to be an intervention for a problem\n                    prob.actions?.forEach((action, k) => {\n                        if (action.id === eventObj.id) {\n                            //see if this is an event whose status should be checked by the student\n                            //and initialize its tracking.  Not yet limiting to event id when\n                            //defining what needs to be tracked in the structure intvChecks\n                            //so also checking event label\n                            let statusChecking  //the entry retrieve from intvChecks\n                            let intv = eventObj.id\n                            statusChecking = intvChecks[eventObj.label]\n                            if (!statusChecking){\n                                statusChecking = intvChecks[eventObj.id]}\n\n                            if (!!statusChecking){\n                                let initialEntry = {\"intervention\": intv, \"timestamp\": eventObj.timestamp, \"foundCk\": false}\n                                //put the intervention on the list if there is a direct status check possible for it\n                                if (statusChecking.intvStatusNeeded){\n                                    trackForStatus[intv] = Object.assign({}, initialEntry)}\n                                //if any vitals are listed for this intervention as a way of checking its status then\n                                //put those on the statusChecking list.  Anytime a vital is checked after the timestamp\n                                //it will count towards checking the status of the intervention\n                                statusChecking.vitalsNeeded.forEach(vital => {\n                                    if (!trackForStatus[vital]){trackForStatus[vital] = [Object.assign({}, initialEntry)]}\n                                    else {trackForStatus[vital].push(Object.assign({}, initialEntry))}})}\n                                \n                            // fill out problem related fields in the action event\n                            if (!!action.assessments) {eventObj.assessmentsNeeded = action.assessments}\n                            if (!!action.phase) {\n                                eventObj.when = action.phase\n                                eventObj.suggestedPhase = action.phase};\n                            if (!!prob.protocols) {eventObj.protocol = prob.protocols}\n                            if (eventObj.answerCorrect) {\n                                eventObj.status = \"goodIntv\";}\n                            else { eventObj.status = \"incorrect-answers\"; }\n                            eventObj.probLabel = prob.probLabel;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!action[fldName]) {\n                                    eventObj[fldName] = action[fldName];\n                                }});\n                            if (!!action[\"id-label\"]) { eventObj[\"label\"] = action[\"id-label\"]; }  //dealing with name changes in incoming data so software stays the same\n                        }});\n\n                    // check for this action to be a contraindication for a problem solution\n                    prob.otherActions?.forEach((contra, j) => {\n                        if (contra.id === eventObj.id) {\n                            eventObj.status = prob.protocolRelationship;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!contra[fldName]) {\n                                    eventObj[fldName] = contra[fldName];\n                                }});\n                            if (!!prob.probLabel) { eventObj.probLabel = prob.probLabel; }\n                        }}) \n                    })}\n\n            if (eventObj.type === \"decision-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"decision-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n\n            if (eventObj.type === \"assessment-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"assessment-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n            // add the formatted object to our list of formatted objects for the current phase and the id to our set of confirmed ids\n            if (eventObj.type === \"intervention\"){\n                confirmedEvents.push(eventObj.id + \"+\" + eventObj.probLabel)\n                interventionsConfirmed.push(eventObj.id)\n            }\n            else {confirmedEvents.push(eventObj.id)}\n            phaseObjects.push(eventObj)}});\n\n    // store the last phase processed\n    phases[phaseIndex] = phaseObjects;\n    if (phaseIndex !== parentIndex){\n        phases[parentIndex] = (phases[parentIndex]).concat(phaseObjects)};\n    return [phases,phaseNames,confirmedEvents,trackForStatus]\n}\n\n//start support functions for constraint checking\n\nconst findNameNumID = (names, entries, item, occurrence) => {\n    let result = undefined\n    let index = undefined\n    for (let i = 0; i < names.length; i++) {\n        if (item.id === names[i]) {\n            result = entries[i]\n            if (occurrence === \"start\") {\n                break}}}\n    if (!!result) {\n        if (result.numericalID === -1) {\n            if (occurrence === \"start\") {\n                index = result.numericalIDStart}\n            else { index = result.numericalIDEnd }}\n        else { index = result.numericalID }}\n\n    return index\n}\n\nlet unknownItem = {id: \"Unknown\", label: \"Unknown\"}\n\nconst getItem = (val) => {\n    if (val === \"Unknown\"){return unknownItem}\n    let item = itemByID[val]\n    if (!item){\n        item = itemByLabel[val]}\n    if (item){return item[0]}\n}\n\nconst findObjByNumerialID = (numericalID,phases,phaseNames) => {\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            for (let entry of phaseObjects){\n                if (entry.numericalID === numericalID){\n                    return entry}\n            }}}}\n\n\nconst storeMisOrderedArgs = (numericalID, arg2, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (!objToModify.arg2){\n            objToModify.arg2 = [arg2.id]}\n        else {objToModify.arg2 = objToModify.arg2.concat([arg2.id])}}\n}\n\nconst storeMisOrderedFB = (numericalID, FB, constraintType, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (objToModify.orderingFB !== \"\") {\n            objToModify.orderingFB = objToModify.orderingFB + \".\\xa0\\xa0\" + FB}\n        else { objToModify.orderingFB = FB }\n        let status\n        \n        let appendString = \"\"\n        if (constraintType === \"phase\"){\n            appendString = \"misOrdered-phase-\"}\n        if (constraintType === \"item\"){\n            appendString = \"misOrdered-\"}\n        if (!(objToModify.status.includes(appendString)))\n                {status = appendString + objToModify.status \n                objToModify.status = status}}\n}\n\n\n//flattens out the phases and phaseNames data structures so that all phase and subphase\n//names have their own entry and each item under a phase or subphase has its own entry.\n//Collect and return unique names because phase and subphase names can appear multiple times in the \n//phases and phaseNames ds.  Having a unique list of names means that a constraint will only be checked once.\n\n\nconst collectEntriesToCheckConstraints = (phases, phaseNames) => {\n    let listOfNames = []\n    let listOfEntries = []\n    let uniqueListOfNames = []\n    let counter = -1\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let startIndex = phaseObjects[0].numericalID\n        let endIndex = phaseObjects[phaseObjects.length-1].numericalID\n\n        //handle phases and subphases first\n    \n        if (requiredPhaseNames.includes(phaseName) || requiredSubphases.includes(phaseName)) {\n            listOfEntries.push({ id: phaseName, numericalID: counter, numericalIDStart: startIndex, numericalIDEnd: endIndex })\n            listOfNames.push(phaseName)\n            if (!uniqueListOfNames.includes(phaseName)){uniqueListOfNames.push(phaseName)}}\n\n        //can't be an else to above because a phase can have entries but a subphase cannot\n        \n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            let phaseObjectNames = phaseObjects.map(obj => obj.id)\n            listOfEntries = listOfEntries.concat(phaseObjects)\n            uniqueListOfNames = uniqueListOfNames.concat(phaseObjectNames)\n            listOfNames = listOfNames.concat(phaseObjectNames)\n        }\n    }\nreturn [listOfNames, uniqueListOfNames, listOfEntries]\n\n}\n\nconst saveFailedConstraint = (lateArg, otherArg, constraintID) => {\n    let type\n    if ([\"phase\", \"sub-phase\"].includes(lateArg.type)){\n        type = \"phase\"}\n    else {type = \"item\"}\n    constraintsViolated.push({constraintID: constraintID, arg1: lateArg, op: \"before\", arg2: otherArg, type: type}) \n    return type\n}\n\nconst addToListOfFeedback = (parPhFB, last, label, repeating) => {\n    //feedback for nonphase\n    if (repeating){\n        if (last) {\n            parPhFB = parPhFB + \" and \"\n        }\n        else {parPhFB = parPhFB +  \", \"}}\n    parPhFB = parPhFB + label.toLowerCase()\n    return parPhFB\n}\n\n\n\nconst checkAgainst2ndArgs = (arg1st,args2nd,op,direction,constraintID,entryNames,entries,phases,phaseNames) => {\n    let endNum1st = findNameNumID(entryNames, entries, arg1st, \"end\")\n    let startNum1st = findNameNumID(entryNames, entries, arg1st, \"start\")\n    let label1st = arg1st.label\n    let phFB = \"\"\n    let par1PhFB = \"\"\n    let par2PhFB = \"\"\n    let repeating\n    let constraintType\n    if (args2nd.length > 0) {\n        let counter = 0\n        let violations = 0\n        for (let arg of args2nd) {\n            let last = false\n            let arg2nd = getItem(arg)\n            if (!!arg2nd) {\n                counter++\n                if (counter === args2nd.length){\n                    last = true}\n                let label2nd = arg2nd[\"label\"]\n                let startNum2nd = findNameNumID(entryNames, entries, arg2nd, \"start\")\n                let endNum2nd = findNameNumID(entryNames, entries, arg2nd, \"end\")\n                \n                switch (direction){\n                case \"before\":\n                    if (!!endNum1st && !!startNum2nd) {\n                        if (!(endNum1st < startNum2nd)) {  //if failed constraint i.e. arg1 is late\n                            //result = collectFB (constraintID, counter, arg1st, arg2nd, startNum1st, startNum2nd, endNum1st, endNum2nd, label1st, label2nd, last, constraintType, phases, phaseNames)\n                            //feedback for item\n                            violations++\n                            if (par1PhFB === \"\"){\n                                if (startNum1st === endNum1st) { \n                                    par1PhFB = \"You should have done \"\n                                    par1PhFB = addToListOfFeedback(par1PhFB, last, label1st, false)}     \n                                //feedback for phase\n                                else { \n                                    par1PhFB = \"You should have completed \"\n                                    par1PhFB = addToListOfFeedback(par1PhFB, last, label1st, false)}} \n                            if (startNum2nd === endNum2nd) {\n                                if (par2PhFB === \"\"){\n                                        par2PhFB = par2PhFB + \" before you did \"}  //feedback for item\n                                    if (violations > 1){repeating = true}\n                                    else {repeating = false}\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label2nd, repeating)}\n                            else { \n                                if (par2PhFB === \"\"){\n                                    par2PhFB = par2PhFB + \" before starting \"}  //feedback for phase\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par2PhFB = addToListOfFeedback(par2PhFB, last, label2nd, repeating)}\n                            storeMisOrderedArgs(startNum1st, arg2nd, phases, phaseNames)\n                            constraintType = saveFailedConstraint(arg1st, arg2nd, constraintID)\n                        }\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                case \"after\":  //for after just reverse 1st and 2nd args\n                    if (!!startNum1st && !!endNum2nd) {\n                        if (!(startNum1st > endNum2nd)) { //if failed constraint  i.e. arg2 is late  \n                            violations++                         \n                            if (startNum1st === endNum1st){\n                                //feedback for item \n                                if (par1PhFB === \"\")                              \n                                    {par1PhFB = \"You should have done \"}\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par1PhFB = addToListOfFeedback(par1PhFB, last, label2nd, repeating)}\n                            //feedback for phase \n                            else{\n                                if (par1PhFB === \"\")                               \n                                    {par1PhFB = \"You should have completed \"}\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par1PhFB = addToListOfFeedback(par1PhFB, last, label2nd, repeating)}\n                            if (par2PhFB === \"\"){\n                                if (startNum2nd === endNum2nd){     \n                                    par2PhFB = par2PhFB + \" before you did \"\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label1st, false)}\n                                else {                                 \n                                    par2PhFB = par2PhFB + \" before starting \" //feedback for nonphase\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label1st, false)}}\n                            storeMisOrderedArgs(startNum2nd, arg1st, phases, phaseNames)   //feedback for phase\n                            constraintType = saveFailedConstraint(arg2nd, arg1st, constraintID)}\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                default: break\n                }\n            }     \n        }        \n        phFB = par1PhFB + par2PhFB\n        if (phFB !== \"\") {\n            storeMisOrderedFB(startNum1st, phFB, constraintType, phases, phaseNames)}    \n    }\n}\n\n\n\nconst checkConstraintsForArg = (arg1st, constraint, phases, phaseNames, entryNames, entries) => {\n    \n    let args2nd = constraint.before\n    let op = constraint.beforeOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"before\",constraint.id,entryNames,entries,phases,phaseNames)\n\n    args2nd = constraint.after\n    op = constraint.afterOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"after\",constraint.id,entryNames,entries,phases,phaseNames)}\n    \n    \n  //end support functions for constraint checking              \n                        \n\n\n//To DO: filter constraints in/out based on findings available for this scenario\n\n//main function for constraint checking \nconst checkAgainstKB = (phases, phaseNames) => {\n\n    let result = collectEntriesToCheckConstraints(phases, phaseNames)\n    let entryNames = result[0]\n    let uniqueEntryNames = result[1]\n    let entries = result[2]\n    uniqueEntryNames.forEach(firstArg => {\n        let firstArgItem = getItem(firstArg)\n        if (!!firstArgItem) {        \n            let constraint = getConstraint(firstArgItem)  //will find only one constraint per 1st arg\n            if (!!constraint) {\n                checkConstraintsForArg(firstArgItem, constraint, phases, phaseNames, entryNames, entries)}}})            \n    //only expect to change objects in phases\n    return [phases, phaseNames]\n}\n\n\n//main function for dealing with missing assessment steps\n\nconst checkForMissingAssessments = (problems,events,confirmedEvents,phaseNames,phases) => {\n    let neededScenAssessments = collectScenAssessments(problems)\n    let indexCounter = events.length;\n    var checklistSteps = scenario.checkListMetaData.filter(md => [MDB_TYPES.ASSESS, MDB_TYPES.REQUIRED].includes(md.type));\n\n    // before evaluating assessment steps, deal with exceptional cases where one or more steps is not\n    // necessary for a given scenario.  Because GCS value is a string and not a formatted object\n    // we can't reliably parse out values and units to do more general checks so can only set what\n    // steps should not be assessed for a particular scenario.  Requires info on feedback to give as\n    // well.\n    // Get any exceptional steps associated with the current scenario\n    var exceptions = [];\n    for (let exceptionDef of exceptionDefs) {\n        if (exceptionDef.scenarioName === scenario.name) {\n            exceptions = exceptionDef.exceptions;\n            break;\n        }\n    }\n\n    exceptions.forEach((exception, j) => {\n        // remove the step from the checklist as it is not required\n        checklistSteps = checklistSteps.filter(entry => entry.id !== exception[0]);\n\n        // if the step was done during the observation then mark it as an issue\n        if (confirmedEvents.includes(exception[0])) {\n            // it could appear in any phase so check all phases and mark\n            // each instancs as unnecessary\n            phases.forEach((phaseObjects, j) => {\n                phaseObjects.forEach((action, i) => {\n                    if (action.id === exception[0]) {\n                        action.why = exception[1];\n                        action.status = \"notNecessary\";\n                    }\n                });\n            });\n        }\n\n    });\n\n    // iterate through all checklist steps for ones for which we don't have formated objects\n    checklistSteps.forEach((cls, i) => {\n        if (!confirmedEvents.includes(cls.id)) {\n            // add so we don't check for the missing checklist item again\n            confirmedEvents.push(cls.id);\n            let phaseObject = {\n                \"comment\": \"\",\n                \"numericalID\": indexCounter,\n                \"status\": \"missingRequiredAssessment\",\n                \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                \"expertPhase\": \"\",\n                \"workingPhase\": \"\",\n                \"contraindicatedWhy\": \"\",\n                \"minimalWhy\": \"\",\n                \"why\": \"\",\n                \"probLabel\": \"\",\n                \"protocol\": \"\",\n                \"actionDescription\": \"\",\n                \"assessmentFB\": \"\",\n                \"timestamp\": -1\n            };\n\n            //copy over the step fields that exist (type dependent)\n            const STEP_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"type\", \"prompt\"];\n            STEP_FIELDS.forEach(fldName => {\n                if (!!cls[fldName]) {\n                    phaseObject[fldName] = cls[fldName];\n                }\n            });\n            if (!!cls.subPhase) { phaseObject.workingPhase = cls.subPhase; }\n            else { if (!!cls.phase) { phaseObject.workingPhase = cls.phase; } }\n            phaseObject.when = phaseObject.workingPhase;\n            phaseObject.expertPhase = phaseObject.workingPhase;\n\n            if (!!phaseObject.label) { phaseObject.actionDescription = phaseObject.label; }\n            \n            //let findings = scenario.assessmentFindings[cls['id']]\n            //if (!!findings & findings !== \"Unremarkable\" & findings !== \"Stable\"){\n\n            if (neededScenAssessments.includes(cls['id'])){\n                phaseObject.assessmentFB = \"Thus you missed finding: \" + scenario.assessmentFindings[cls['id']]}\n            if (phaseObject.type === \"required-action\"){\n                phaseObject.status = \"missingRequiredAssessment\"\n            }\n            insertInPhaseInOrder(phaseNames, phases, phaseObject, i);\n            indexCounter++;\n        }\n    });\n    return[confirmedEvents, phaseNames, phases, indexCounter]\n}\n\n//support functions for updating and searching the phaseNames and phases data structures\nconst insertInPhaseInOrder = (phaseNames, phases, object, objIndex) => {\n    let phase\n    phase = object.when;  //what phase should it be added to\n    let phaseIndex = phaseNames.lastIndexOf(phase); //get the index for the last instance of the phase\n    let phaseObjects = phases[phaseIndex];  //get the objects associated with that phase\n    if (!phaseObjects) { phaseObjects = []; }\n    phaseObjects.splice(objIndex - 1, 0, object);  //insert it at the place indicated by input objIndex\n    phases[phaseIndex] = phaseObjects;\n};\n\nconst getEndSubPhase = (inPhaseId, phaseNames) => {\n    let subPhases = getSubPhases(inPhaseId);\n    let subPhaseName;\n    let reversedSubPhases = [...subPhases].reverse();\n    for (let subPhase of reversedSubPhases) {\n        subPhaseName = phaseNames.find(id => id === subPhase.id);\n        if (!!subPhaseName) { break; }\n    }\n    return subPhaseName;\n};\n\nconst getEndSubPhaseIndex = (inPhaseId, phaseNames) => {\n    let subPhaseName = getEndSubPhase(inPhaseId, phaseNames);\n    let index = phaseNames.lastIndexOf(subPhaseName);\n    //console.log(subPhaseName,index)\n    return index;\n};\n\n// sts 01/23/22\nconst getSubPhases = (phaseId) => {\n    return checklistHierarchy.find(phase => phase.id === phaseId).subPhases\n    // let mainPhases = findPhases();\n    // let phaseEntry = mainPhases.find(phase => phase.id === phaseId);\n    // return (phaseEntry.subPhases);\n};\n\nconst hasSubPhases = (phaseId) => {\n    let phase = checklistHierarchy.find(phase => phase.id === phaseId)\n    if (!!phase && !!phase.subPhases){\n        return true}\n    else {return false}\n}\n\n  \n//given a numerical id, what is its parent phase or subphase\n//find the header under which the input numericalID appears\nconst findHeaderFor = (numericalID, log) => {\n    let candidateHeader = {};\n    let foundHeader = {};\n    for (let entry of log) {\n        if (entry.id === \"problemHeader\") {\n            candidateHeader = entry;\n        }\n        else {\n            if (entry.numericalID === numericalID) {\n                foundHeader = candidateHeader;\n                break;\n            }\n        }\n    }\n    return (foundHeader);\n};\n\n//rearrange the problem data structure for use during analysis\n\nconst setupProblems = (defs, sols, actions) => {\n    let problems = [];\n    for (let problemDef of defs) {\n        let problem = {};\n        let solutionID = problemDef.solutions[0];\n\n        //new interface\n        if (!!sols && !!actions){\n            let probSols = sols.filter(sol => sol.problemID === problemDef.id)\n            let sol = probSols.filter(sol => sol.id === solutionID)\n            problem.probLabel = problemDef.label;\n            problem.id = problemDef.id\n            problem.lifeThreat = problemDef.lifeThreat\n            problem.vitals = problemDef.vitals\n            let assessments = problemDef.assessments\n            problem.assessments = assessments.map(obj => obj.assessmentID)\n            problem.actions = []\n            problem.otherActions = []\n            let actEntries\n            let actIDs = sol[0].actions\n            actEntries = actions.filter(act => actIDs.includes(act.id))\n            \n            for (let entry of actEntries){\n                let act = Object.assign({}, entry)\n                act.id = act.interventionID\n                let item = itemByID[act.id]\n                if (!!item){\n                    act[\"id-label\"] = item[0].label}\n                else {act[\"id-label\"] = act.id}\n                switch (act.protocolRelationship){\n                    case \"contraindicated\":\n                    case \"irrelevant\":\n                    case \"unnecessary\":\n                        problem.otherActions.push(act)\n                        break\n                    case \"required\":\n                    case \"minimal\":\n                    case \"optional\":\n                        problem.actions.push(act)\n                        break\n                    default:\n                        break}\n            }\n            problem.minimalWhy = sol.minimalWhy\n            problem.protocols = sol.protocols\n        }\n        // old interface\n        else {\n            problem.probLabel = problemDef.problem;\n            problem.lifeThreat = problemDef.lifeThreat\n            problem.actions = solutionID.actions;\n            problem.minimalWhy = solutionID.minimalWhy;\n            problem.protocols = solutionID.protocols\n            problem.assessments = problemDef.assessments;\n            problem.otherActions = solutionID.contraindications;\n            problem.actions.forEach(act => {\n                if (act.minimal){act.protocolRelationship = \"minimal\"}\n                if (act.optional){act.protocolRelationship = \"optional\"}\n                if (!act.minimal && !act.optional){act.protocolRelationship = \"required\"}})\n            problem.otherActions.forEach(act => {\n                    act.protocolRelationship = \"contraindicated\"})\n        \n\n            //not in new interface\n            problem.allProblemProtocols = problemDef.protocol;\n            \n            }\n        problems.push(problem);\n        \n    }\n    return (problems);\n    //console.log(problems)\n};\n\n// this approximates the placement for a missing intervention based on ordering of interventions\n// in the problems definitions, what appears in the log that is just before and just after\n// the item to be inserted, and what is marked as required that is in the log just before and after.  An approach that\n// utilizes partial ordering constraints would be better.  Also it is not clear what to do for really badly ordered\n// actions on the part of the student.  Note that it only looks for two anchor points before and two anchor points after\n// rather than all potential anchor points.  Also it does not deal with a phase that is split into multiple time periods\n// within a log. It looks for the best placement in the last phase found.\n\n//input orderedArrayObjects is the interventions for a problem as ordered in the problem def\n// objIndex is the index in orderedArrayObjects for the intervention object that needs to be inserted in phases\nconst insertInPhaseRelativeToSuggestedOrder = (phaseNames, phases, object, orderedArrayObjects, objIndex) => {\n    // if expertPhase in object is a phase then find the last subphase and insert there instead of at the beginning\n    let phaseIndex = -1;\n    //console.log(object);\n    // if it is a subphase or a phase with no subphases then get the last entry for a proposed initial insertion point\n    // object.expertPhase is the phase recommended for this action to appear\n    if (object.expertPhase === \"\"){\n        /* let errorMsg = 'No phase specified in the problem defs for object: ' + object.actionDescription;\n        throw new Error(errorMsg) */\n        //just use the next to last phase if none is specified\n        object.expertPhase = requiredPhaseNames[requiredPhaseNames.length - 2]}\n        \n\n    if (requiredSubphases.includes(object.expertPhase) || !getSubPhases(object.expertPhase)) {\n        phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    }\n    // if it is a phase then get the last entry of the last suphase within it for a proposed intial insertion point\n    else {\n        phaseIndex = getEndSubPhaseIndex(object.expertPhase, phaseNames);}\n        \n    //update object when field which is mostly to see what gets computed for the insertion point\n    object.when = phaseNames[phaseIndex];\n        \n    \n\n    let objectsBefore = orderedArrayObjects.slice(0, objIndex - 1);\n    let objectBefore = orderedArrayObjects[objIndex - 1];\n    // console.log(\"Objects before in def\", {...objectsBefore})\n    let requiredObjectBefore = [...objectsBefore].reverse().find(entry => entry.required);\n    let objectAfter = orderedArrayObjects[objIndex + 1];\n    let objectsAfter = orderedArrayObjects.slice(objIndex + 1);\n    let requiredObjectAfter = objectsAfter.find(entry => entry.required);\n    //let phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    let phaseObjects = [...phases[phaseIndex]]; //trying for a deep copy of the array mainly for debug via console.log\n\n    //console.log(phaseObjects)\n    let indexBefore = -1;\n    let indexAfter = -1;\n    let indexRequiredBefore = -1;\n    let indexRequiredAfter = -1;\n    let insertionIndex = false;\n    if (objectBefore) { indexBefore = phaseObjects.findIndex(entry => entry.id === objectBefore.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    if (requiredObjectBefore) { indexRequiredBefore = phaseObjects.findIndex(entry => entry.id === requiredObjectBefore.id); }\n    if (requiredObjectAfter) { indexRequiredAfter = phaseObjects.findIndex(entry => entry.id === requiredObjectAfter.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    // There is a more compact way to do the below but this made\n    // it easier for me to get the logic right\n    // insert according to required before first as we want to follow something that was required\n    if (indexRequiredBefore !== -1) {\n        insertionIndex = indexRequiredBefore + 2;\n        // but if the just before object is greater then insert relative to it\n        if (indexBefore > indexRequiredBefore) { insertionIndex = indexBefore + 2; }\n    }\n    //if no required before and not required after then insert relative to\n    //required item after in actions definition\n    if (!insertionIndex && indexRequiredAfter !== -1) {\n        insertionIndex = indexRequiredAfter + 1;\n        // unless the just after is smaller then override and insert relative to it\n        if (indexAfter < indexRequiredAfter) { insertionIndex = indexAfter + 1; }\n    }\n    //otherwide if have a just before insert relative to it\n    if (!insertionIndex && indexBefore !== -1) {\n        insertionIndex = indexBefore + 2;\n    }\n    //otherwise if have a just after insert relative to it\n    if (!insertionIndex && indexAfter !== -1) {\n        insertionIndex = indexAfter + 1;\n    }\n    //otherwise put at end of phase\n    if (!insertionIndex) {\n        insertionIndex = phaseObjects.length + 2;\n    }\n    insertInPhaseInOrder(phaseNames, phases, object, insertionIndex);\n\n};\n\nconst determineHLcolor = (lowerColor, higherColor) => {\n    let newColor = higherColor\n    if (lowerColor === \"red\") {\n        newColor = \"red\"\n    }\n    if (lowerColor === \"yellow\" && newColor !== \"red\") {\n        newColor = \"yellow\"\n    }\n    return newColor\n}\n\n//to display the log using the phase structures accumulated\n// i.e. puts the phases data together in the order in which\n// should be displayed in debriefing log\nconst organizeLogDisplay = (phaseNames, phases) => {\n    let displayObjects = [];\n    let entryIndex = 1;\n    let headerIndex = 1;\n    let problemHeaderColor = \"green\"\n    let subPhaseColor = \"green\"\n    let subPhaseStatuses = []\n    let phaseStatuses = []\n    let newPhaseObjects = []\n    let headerObj = {\n        \"id\": \"assessmentHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"protocol\": \"\"\n    };\n    let subHeaderObj = {\n        \"id\": \"assessmentSubHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"phaseID\": \"\",\n        \"protocol\": \"\"\n    };\n    \n    let priorHLPhaseItem = \"\"\n    let endEntry = false\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let iPhaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let process = true\n        \n        if (requiredPhaseNames.includes(phaseName) && hasSubPhases(phaseName)) {\n            process = false}\n\n        if (iPhaseObjects.length > 0 && process) {\n                //for this set of objects, find the worst scoring item\n            let phaseObjects = phases[phaseIndex];\n            subPhaseColor = \"green\"\n            for (let phaseObject of phaseObjects) {\n                if (phaseObject.type !== \"intervention\"){\n                    subPhaseStatuses.push(phaseObject.status)}\n                //else {hierProblemResults.push(phaseObject)} \n                if (problemStates.includes(phaseObject.status)) {\n                    subPhaseColor = \"red\";     \n                }\n                // Red has a higher priority than yellow so will allow to override it\n                if (cautionStates.includes(phaseObject.status) && subPhaseColor !== \"red\") {\n                    subPhaseColor = \"yellow\";    \n                }               \n                phaseObject.numericalID = entryIndex++;\n                //entryIndex++;\n            };\n\n            let subheader = Object.assign({}, subHeaderObj)\n            let localPhaseName = phaseNames[phaseIndex]\n            let localPhaseItem = getItem(localPhaseName)\n            subheader.label = localPhaseItem.label\n            subheader.labelID = localPhaseItem.id\n            subheader.status = getPhaseStatus(subPhaseStatuses)\n            subheader.displayColor = subPhaseColor\n            let highLevelPhase = subPhases[localPhaseName]\n            let highLevelPhaseItem = getItem(highLevelPhase)\n            subheader.phaseID = highLevelPhaseItem.id\n\n            //Note that the inserted headers will have their own numerical id and\n            //am dividing by 1000 for headers so their numerical id will be unique\n            //to headers.  Am assuming we would never have more than 1000 events\n            //observed.  Will use the numerical ids for testing before and after\n            //constraints.       \n            \n            if (priorHLPhaseItem === \"\") {\n                priorHLPhaseItem = highLevelPhaseItem\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n            }\n            \n            if (phaseIndex === phaseNames.length - 1) {\n                //this closes out the prior phase and the new subphase \n                let header = Object.assign({}, headerObj)\n                if (highLevelPhase !== priorHLPhaseItem.label){    //ending with start of a new phase\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    newPhaseObjects = []}\n\n                header = Object.assign({}, subheader)\n                header.label = highLevelPhaseItem.label\n                header.labelID = highLevelPhaseItem.id\n                header.id = \"assessmentHeader\"\n                header.numericalID = headerIndex++ / 1000 \n                displayObjects.push(header)\n                      \n                if (highLevelPhase === subheader.label) { \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(...phaseObjects)}\n                else {\n                    subheader.numericalID = headerIndex++ / 1000 \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(subheader)\n                    displayObjects.push(...phaseObjects)}          \n                endEntry = true;\n            }\n\n            //save the accumulated high-level phase if the phase changes \n            if (!endEntry) {\n                if (highLevelPhase !== priorHLPhaseItem.label) {\n                    let header = Object.assign({}, headerObj)\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    phaseStatuses = []\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    //reinitialize for the new phase   \n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects = [...phaseObjects]\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects = [subheader]\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    priorHLPhaseItem = highLevelPhaseItem\n                    problemHeaderColor = determineHLcolor(subPhaseColor, \"green\")\n                }\n                else {\n                    problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects.push(subheader)\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                }\n            }\n        \n        }\n    }\n    return displayObjects;\n}\n\n\n\n\nconst evalForIncorrectAnswer = (promptID, answerID, isIntervention) => {\n        //check each prompt and if is the appropriate one then\n        let answers = undefined\n        if (isIntervention) {\n            answers = scenario.associations[promptID];\n        }\n        else { answers = scenario.checkListCorrectness[promptID]; }\n\n        if (answers === undefined) { console.log(\"didn't find answers for \", promptID); return (false) }  //can't grade if answers not found in spec\n\n        if (Array.isArray(answers)) {\n            //returns bool regarding whether answerID NOT in answers\n            return !(answers.find(ansId => ansId === answerID));\n\n        }\n        else {\n            return !(answers === answerID);\n        }\n};\n\n\nconst getCorrectAnswerLabel = (promptID, isIntervention) => {\n    let answers\n    let metaData\n    if (isIntervention){\n        answers = scenario.associations[promptID];\n        metaData = scenario.intvMetaData}\n    else {answers = scenario.checkListCorrectness[promptID];\n        metaData = scenario.checkListMetaData}\n    let answerLabels = false;\n    if (Array.isArray(answers)) {\n        answers.forEach((answer, j) => {\n            metaData.forEach((entry, i) => {\n                if (entry.id === answer) {\n                    if (answerLabels === false) {\n                        answerLabels = entry.label;\n                    }\n                    else { answerLabels = answerLabels + \", \"; }\n                    return;\n                }\n            });\n        });\n    }\n\n    else {\n\n        metaData.forEach((entry, i) => {\n            /* //needed to find out what the types are for debugging\n            let answertypes = []\n            if (!answertypes.find(type => type === entry.type)){\n                answertypes.push(entry.type)} */\n\n            if (entry.id === answers) {\n                answerLabels = entry.label;\n            }\n        });\n    }\n    //answerLabels = answerLabels.charAt(0).toLowerCase() + answerLabels.slice(1);\n    /* if (answerLabels){\n        answerLabels = \"'\" + answerLabels + \"'\";} */\n    return answerLabels\n};\n\nconst getAnswerLabel = (answerID, isIntervention) => {\n    let metaData\n    if (isIntervention){\n        metaData = scenario.intvMetaData}\n    else {metaData = scenario.checkListMetaData}\n    let answerLabel = \"\";\n    metaData.forEach((entry, i) => {\n            if (entry.id === answerID) {\n                answerLabel = entry.label;\n            }\n        });\n    return (answerLabel || false) ;\n}\n\n// create structure for tracking whether interventions are checked\nconst insertMissingIntvChecks = (events, statusTracking) => {\n    let toUpdate\n    for (const [key, entry] of Object.entries(statusTracking)) {\n        if (Array.isArray(entry)){\n            for (let obj of entry) {\n                let newObj = {\"label\": key, \"foundCk\": obj[\"foundCk\"]}\n                toUpdate = getEventsByIdTime(events,obj[\"intervention\"],obj[\"timestamp\"])\n                for (let intv of toUpdate) {\n                    if (!intv[\"intvStatus\"].includes(newObj)){\n                       intv[\"intvStatus\"].push(newObj)}\n                }}}\n        else {\n            let newObj = {\"label\": \"intervention status\", \"foundCk\": entry[\"foundCk\"]}\n            toUpdate = getEventsByIdTime(events,key,entry[\"timestamp\"])\n            toUpdate.forEach(intv => {\n                if (!intv[\"intvStatus\"].includes(newObj)){\n                    intv[\"intvStatus\"].push(newObj)}})}\n    }\n    return events\n}\n\nconst insertMissingInterventions = (problems,confirmedEvents,indexCounter,phaseNames,phases) => {\n    problems.forEach(prob => {\n        const actions = prob.actions\n        // now we just have to examine action ids to see what is missing\n        actions.forEach((action, k) => {\n            if (!confirmedEvents.includes(action.id + \"+\" + prob.probLabel)) {\n                confirmedEvents.push(action.id + \"+\" + prob.probLabel);\n                let phaseObject = {\n                    \"comment\": \"\",\n                    \"numericalID\": indexCounter,\n                    \"status\": \"\",\n                    \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                    \"required\": true,\n                    \"when\": \"\",\n                    \"suggestedPhase\": \"\",\n                    \"expertPhase\": \"\",\n                    \"probLabel\": \"\",\n                    \"minimalWhy\": \"\",\n                    \"assessmentsNeeded\": \"\",\n                    \"protocol\": \"\",\n                    \"protocolRelationship\": \"\",\n                    \"actionDescription\": \"\",\n                    \"type\": \"intervention\",\n                    \"timestamp\": -1\n                };\n\n                //copy over the step fields that exist (type dependent)\n                const ACTION_FIELDS = [\"id\", \"phase\", \"why\", \"protocolRelationship\"];\n                ACTION_FIELDS.forEach(fldName => {\n                    if (!!action[fldName]) {\n                        phaseObject[fldName] = action[fldName];\n                    }\n                });\n\n                //copy over the step fields that exist (type dependent)\n                const PROBLEM_FIELDS = [\"probLabel\", \"minimalWhy\"];\n                PROBLEM_FIELDS.forEach(fldName => {\n                    if (!!prob[fldName]) {\n                        phaseObject[fldName] = prob[fldName];\n                    }\n                });\n\n                //initialize some fields above that come from problem and action if they are defined\n                if (!!prob.assessments) {phaseObject.assessmentsNeeded = prob.assessments}\n                if (!!prob.protocols) {phaseObject.protocol = prob.protocols}\n                if (!!action[\"id-label\"]) { phaseObject.label = action[\"id-label\"]; }\n                if (!!action[\"id-label\"]) { phaseObject.actionDescription = action[\"id-label\"]; }\n                let phaseVal\n                if (!!action.subPhase){phaseVal = action.subPhase}\n                if (!!action.phase && !phaseVal) {phaseVal = action.phase}\n                if (phaseVal){\n                    phaseObject.when = phaseVal;\n                    phaseObject.expertPhase = phaseVal;\n                    phaseObject.suggestedPhase = phaseVal;\n                }\n\n                phaseObject.status = \"missing\" + capitalizeFirstLetter(phaseObject.protocolRelationship)\n                //assume actions are in the suggested order to solve a problem\n                if (![\"optional\", \"unnecessary\", \"irrelevant\"].includes(phaseObject.protocolRelationship)) {\n                    insertInPhaseRelativeToSuggestedOrder(phaseNames, phases, phaseObject, actions, k);\n                    indexCounter++;\n                }\n            }\n\n        });\n    });\nreturn [indexCounter,phaseNames,phases]}\n\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }\n\n//the main function for analyzing the observation log\nfunction analyzeEvents(scen, log) {\n    let events = log.events;\n    console.log(\"in analyzeEvents\")\n    // sts 1/23/22 moved the setting of the following into initGlobals()\n    // setScenario(scenario)\n    // setupSubphasePhaseLookup()\n    // findSubphases();\n    initGlobals(scen)\n\n    //preprocess some of data from problems/solutions\n    //and for now just flatten it some to set it up to\n    //look more like the original problem actions in scenario\n    // assumes there is just one solution per problem for now.\n    let problemDefs = scenario.problems;\n    let problemActions = scenario.actions;\n    let problemSolutions = scenario.solutions;\n    let problems = setupProblems(problemDefs, problemSolutions, problemActions);\n    \n    //In the remainder, just dealing with the first solution for each problem\n    //so if we ever have more than one solution for a problem this code needs to\n    //be updated.  Would need to consider the additional solutions to decide which\n    //solution is the best fit for the observer student\n\n\n    let formattedActions = [];\n    let annotatedResults = annotateInputEvents(events,problems)\n    //phaseNames and phases are two arrays synchronized be array indices\n    //phases contains just the steps under the phase (thus could be a phase or subphase in observer interface)\n    //phaseNames contains the label for each phase in phases.  Makes it a bit easier to search phaseNames to get the\n    //indice for last instance of a phase label and access its objects\n    let phases = annotatedResults[0];  \n    let phaseNames = annotatedResults[1]; \n    let confirmedEvents = annotatedResults[2]\n    let intvsTracking = annotatedResults[3]\n    \n\n    /* //now create some similar structures for the parents of the above phases\n    //so have all the associated event objects in parents and parentNames\n    //for easy lookup\n    let parentResults = collectParentPh(phaseNames)\n    let parents = parentResults[0]  //events under this parent\n    let parentNames = parentResults[1] */\n\n    //update relative to constraints and comprises definitions\n    //for now it just compares two constraint args of the same type\n    //for what currently exists\n    let kbUpdates = checkAgainstKB(phases,phaseNames)\n    phases = kbUpdates[0]\n    phaseNames = kbUpdates[1]\n    \n    //add missing phase names to phaseNames\n    //as do insertions should consider the temporal ordering constraints\n    \n    let updatedPhases = insertMissingSubphases(phases, phaseNames)\n    phases = updatedPhases[0]\n    phaseNames = updatedPhases[1]\n\n\n    // check for missing checklist steps\n    //as do insertions should consider the temporal ordering constraints\n    let postAssessmentReview = checkForMissingAssessments(problems,events,confirmedEvents,phaseNames,phases)\n    confirmedEvents = postAssessmentReview[0]\n    phaseNames = postAssessmentReview[1]\n    phases = postAssessmentReview[2]\n    let indexCounter = postAssessmentReview[3]\n\n\n\n    // this section could be moved into a separate function so that\n    // the parts of the main analysis are clearer\n\n    // start insert missing interventions\n\n    let postInterventionReview = insertMissingInterventions(problems,confirmedEvents,indexCounter,phaseNames,phases)\n    indexCounter = postInterventionReview[0]\n    phaseNames = postInterventionReview[1]\n    phases = postInterventionReview[2]\n    // search for missing interventions for each action\n    // Doing this separately from the earlier actions loop because\n    // we wanted to add in missing assessment steps first\n    // since interventions depend on appropriate assessments having \n    // been done\n\n\n\n   // end insert missing interventions\n    \n    \n    // put together the phases into a single array ordered as directed by phases\n    \n    formattedActions = organizeLogDisplay(phaseNames, phases);\n    //console.log(\"formattedActions after organizeLogDisplay = \", formattedActions)\n\n    // Now that it is all rejoined into a single list, do some updating with additional\n    // analysis results\n\n    formattedActions = insertMissingIntvChecks(formattedActions, intvsTracking)\n    \n    \n    let priorProb = \"N/A\";\n\n    let finalActions = [];\n    //console.log(\"formattedActions = \", formattedActions)\n\n    formattedActions.forEach((eventObj, j) => {\n        let intvHeaderIndex = 1\n\n        if (insertInterventionHeader && eventObj.type === \"intervention\" && eventObj.probLabel && !(priorProb === eventObj.probLabel)) {\n            priorProb = eventObj.probLabel;\n            let headerObject = {\n                \"id\": \"interventionHeader\",\n                \"status\": \"good\",\n                \"phaseOrderStatus\": \"good\",\n                \"labelID\": eventObj.probLabel,\n                \"type\": \"header\",\n                \"numericalID\": intvHeaderIndex++/3000,\n                \"displayColor\": \"green\",\n            //    \"why\": \"\",\n                \"probLabel\": eventObj.probLabel,\n                \"protocol\": \"\"\n            };\n            finalActions.push(headerObject);\n        }\n        finalActions.push(eventObj);\n    });\n\n    // start overall analysis to determine if all actions to solve a problem are present\n\n    // now we analyze all that we've found in the log to see whether\n    // all the actions were done for each problem and reset\n    // the status if not all are there but should be counted\n    // as minimal for the feedback.\n    let pActions = []; //here we will store the actual problem actions that student did\n    let pNames = []; //here we will store the problem names for the above with same order\n    let pIndex = 0;\n    let pActIndex = -1;\n\n    //console.log(\"finalActions before minimal check = \", finalActions)\n\n    finalActions.forEach((action, j) => {\n        if (action.type === \"intervention\") {\n            //good interventions can have these status values\n            if (!!action.status && action.status.includes(\"goodintv\", \"incorrect-answers\", \"minimal\", \"misOrdered-goodintv\", \n            \"misOrdered-incorrect-answers\", \"misOrdered-incorrect-answers\", \"minimal\", \"misOrdered-minimal\", \n            \"misOrdered-minimal-incorrect-answers\",\n            \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\", \"misOrdered-phase-minimal\")) {\n                if (!pNames.includes(action.probLabel)) {\n                    pActIndex = pIndex;\n                    pNames[pActIndex] = action.probLabel;\n                    pIndex++;}\n                else { pActIndex = pNames.indexOf(action.probLabel); }\n                let actions = pActions[pActIndex];\n                if (!actions) { actions = []; }\n                actions.push(action);\n                pActions[pActIndex] = actions;\n            }\n        }\n    });\n\n    // If all the minimal were found but not all the action were, then we\n    // need to re-mark the action objects created for the minimal events\n    // to be minimal instead of goodintv.  It isn't\n    // appropriate to give this feedback if all actions are present.\n    // Waited until now so that all the events are in one list instead of\n    // a list per phase,\n    let processedIds = formattedActions.map(event => event.id);\n    let pIds = problems.map(a => a.probLabel);\n    pNames.forEach((pEntry, j) => {\n        //get the action definition for this problem\n        let pIndex = pIds.indexOf(pEntry);\n        let prob = problems[pIndex];\n        let actionNeeded = prob.actions.filter(obj => obj.protocolRelationship === \"required\").map(obj => obj.id);\n        //collect statuses for these actions\n\n        let minimalNeeded = prob.actions.filter(obj => obj.protocolRelationship === \"minimal\").map(obj => obj.id);\n        if (minimalNeeded) { //no point in doing anything else if no minimals were defined\n            let foundActions = pActions[j];\n            let found = foundActions.map(a => a.id);\n            let allActionFound = true;\n            let allMinimalFound = true;\n            for (let item of actionNeeded) {\n                if (!found.includes(item)) {\n                    allActionFound = false;\n                    break;\n                }\n            }\n            for (let item of minimalNeeded) {\n                if (!found.includes(item)) {\n                    allMinimalFound = false;\n                    break;\n                }\n            }\n            let numericalIDsChanged = [];\n            if (!allActionFound && allMinimalFound) {\n                minimalNeeded.forEach((foundId, j) => {\n                    let pIndex = processedIds.indexOf(foundId);\n                    let object = formattedActions[pIndex];\n\n                    //find object to modify\n                    object.minimalWhy = prob.minimalWhy;\n                    switch (object.status){\n                        case \"incorrect-answers\":\n                            object.status = \"minimal-incorrect-answers\"\n                            break\n                        case \"goodintv\":\n                            object.status = \"minimal\"\n                            break\n                        case \"misOrdered-goodintv\":\n                            object.status = \"misOrdered-minimal\"\n                            break\n                        case \"misOrdered-incorrect-answers\":\n                            object.status = \"misOrdered-minimal-incorrect-answers\"\n                            break\n                        case \"misOrdered-phase-goodintv\":\n                            object.status = \"misOrdered-phase-minimal\"\n                            break\n                        case \"misOrdered-phase-incorrect-answers\":\n                            object.status = \"misOrdered-phase-minimal-incorrect-answers\"\n                            break\n                        default: \n                            break}\n\n                    numericalIDsChanged.push(object.numericalID);\n                    formattedActions[pIndex] = object;\n                });\n                //redo color for header if needed\n                let header = {};\n                numericalIDsChanged.forEach((numericalID, z) => {\n                    header = findHeaderFor(numericalID, formattedActions);\n                    if (header && header.displayColor === \"green\") { header.displayColor = \"yellow\"; }\n                });\n\n            }\n        }\n\n    });\n\n    // end of overall analysis\n\n    //create summaries for condition 2\n    let summaryResults = summarizeAnalysis(finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated)\n    hierAssessResults = summaryResults[0]\n    hierProblemResults = summaryResults[1]\n\n    \n    //save analysis and summaries for condition 2 to db\n\n    console.log(\"Phase Assessment Status Results\", hierAssessResults)\n    console.log(\"Intervention Status Results\", hierProblemResults)\n    console.log(\"Constraint Violation Results\", constraintsViolated)\n    //console.log(\"Final Analysis:\", finalActions);\n\n\n    // save final analysis in a file\n    saveAnalysisLog(log, finalActions, hierAssessResults, hierProblemResults, constraintsViolated);\n\n    //else {checkOnOverwriting(log, finalActions)}\n\n\n    return (finalActions);\n\n}\n\n\nexport {analyzeEvents}","import React, { useContext } from 'react';\n\nimport {\n    Button,\n    Nav,\n    Navbar,\n    NavbarBrand,\n    NavbarText,\n} from \"reactstrap\";\n\nimport { AuthContext } from \"@meddbriefer/mdb-auth\"\n\n// {/* <Button color=\"primary\" onClick={prefsToggler}>\n//     Preferences\n// </Button> */}\n\n\nconst MDBNavBar = ({title, leftNav = null, rightNav = null }) => {\n\n    const { isAuthenticated, userName, signOutUser } = useContext(AuthContext)\n\n    return (\n        <Navbar color=\"dark\" dark>\n\n            <NavbarBrand href=\"#\">\n                MedDBriefer\n            </NavbarBrand>\n\n            {!!leftNav &&\n                <Nav>\n                {leftNav}\n                </Nav>\n            }\n\n            {!!title &&\n                <NavbarText tag=\"h3\">{title}</NavbarText>\n            }\n\n            <Nav>\n                {isAuthenticated &&\n                <>\n                    <NavbarText>\n                        Welcome, {userName} &nbsp;\n                    </NavbarText>\n                    <Button\n                        color=\"danger\"\n                        onClick={signOutUser}\n                    >\n                        Sign Out\n                    </Button>\n                </>\n                }\n                {!!rightNav &&\n                    rightNav\n                }\n            </Nav>\n\n        </Navbar>\n    )\n}\n\nexport default MDBNavBar;\n","import React, { useState, useEffect } from 'react';\nimport { Button, Table } from 'reactstrap';\nimport MDBNavBar from \"./MDBNavBar\"\nimport { getAssessmentIcon, getColor, getFeedback, getTimestamp, saveAnalysisLog} from \"./debriefingUtils\"\n\n\n\nconst DisplayBaseDebriefing = ({log, actions, scenario, context}) => {\n    const [showCommentColumn, setShowCommentColumn] = useState(false);\n    // eslint-disable-next-line\n    //const [events, setEvents] = useState(log.events);\n    const [formattedActions, setFormattedActions] = useState(undefined);\n\n// const Debriefing = ({ log, metaData, criticalActions, associations }) => {\n    /* const toggleCommentColumn = () => {\n        setShowCommentColumn(!showCommentColumn);\n    } */\n    \n\n    const saveAnalysisLogLocally = () => {\n        saveAnalysisLog(log,formattedActions)\n    }\n\n    const toggleComments = () => {\n        setShowCommentColumn(!showCommentColumn)\n    }\n\n    const dispHeaderRow = (entry) => {\n        return (\n            <>\n                {entry.id ===  \"assessmentHeader\"  || entry.id === \"assessmentSubHeader\"\n                    ? <td colSpan=\"4\" className={getColor(entry)}>\n                        <b>{entry.label}</b>\n                    </td>\n                    : <td colSpan=\"10\" className={\"black\"} >\n                        <div><em>\n                        &nbsp;&nbsp;&nbsp;Intervention Group: {entry.probLabel}</em></div>\n                    </td>}\n            </>\n        )\n    }\n    \n    function getLabel(entry) {\n        return(\n            <>\n            {entry.type === \"obtain-vital-sign\"\n                ? vitalLabel(entry)\n                : regularLabel(entry)\n            }\n            </>\n    \n        )\n    }\n    \n    function getStatusLabel(entry){\n        let metaData = scenario.intvMetaData\n        let metaEntry = metaData.find(me => (entry.vital === me.id))\n        return(<>{metaEntry.label}</>)\n    }\n    \n    function vitalLabel(entry){\n        return(\n            <>\n            {entry.vitalType === \"intervention-status\"\n                ? <>Requested intervention status for: {getStatusLabel(entry)}, <p>Found: <i>{entry.value}</i></p></>\n                : <>Requested vital: {entry.vital}, <p>Found: <i>{entry.value}</i></p></>\n            }\n            </>\n        )\n    }\n    \n    function regularLabel(entry) {\n        return(\n            <>\n            {entry.subPhase && entry.type !== \"intervention\"\n                ? <><b>{entry.subPhase}:</b> {entry.actionDescription}.  {findingsData(entry)}</>\n                : <>{phaseLabel(entry)}</>\n        }\n            </>\n        )\n    }\n    \n    function phaseLabel(entry){\n        return(\n            <>\n            {entry.type === \"intervention\"\n                ? <><b>Intervention:</b> {entry.actionDescription}. {findingsData(entry)} </>\n                : <>{entry.actionDescription}.  {findingsData(entry)}</>\n                }\n            </>\n        )\n    }\n        \n    function findingsData(entry){\n        return(\n            <>\n            {entry.finding\n            ?<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Findings: <i>{entry.finding}</i></p>\n            :<></>\n        }\n            </>\n        )\n    \n    }\n    \n    \n     function saveComment(val) {\n        let orig = val.target.defaultValue;\n        let comment = val.target.value;\n        let entryID = val.target.id;\n        if (orig !== comment){\n            let entry = formattedActions.find(entry => (entry.id === entryID))\n            // if (entry) { entry.comment = comment }}\n            const newEntry = Object.assign({}, entry, {comment: comment})\n            updateFormattedAction(newEntry)\n        }\n    }\n    \n    const dispDataRow = (entry) => {\n        return (\n            <>\n                <td>{entry.numericalID}</td>\n                <td>{getTimestamp(entry)}</td>\n                <td className={getColor(entry)}>\n                    <span className=\"material-icons-outlined\">{getAssessmentIcon(entry)}</span>\n                    {getLabel(entry)}\n                </td>\n                <td>{getFeedback(entry)}</td>\n\n                {showCommentColumn && <td><textarea rows=\"2\" cols=\"50\" defaultValue={entry.comment} onBlur={saveComment} id={`${entry.id}`}/></td>}\n            </>\n        )\n    }\n\n    \n    const updateFormattedAction = (record) => {\n        const index = formattedActions.findIndex(rec => rec.id === record.id)\n        setFormattedActions([\n            ...formattedActions.slice(0, index),\n            record,\n            ...formattedActions.slice(index+1)\n        ])\n    }    \n\n\n    async function displayIt () {\n        \n        \n        if (context === \"review\"){\n            //console.log(\"displaying for review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(true)        \n        }\n        else {\n            //console.log(\"displaying for non-review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(false)\n              }\n\n        setFormattedActions(actions)\n    \n        \n    }\n\n    \n   \n\n\n// eslint-disable-next-line\nuseEffect(\n    () => {\n        displayIt()\n        // eslint-disable-next-line\n    }, [] // empty list means this code will only be run on initial render\n)\n\n\n\nif (undefined === formattedActions) {\n    return (<h3>processing</h3>)\n}\n\nreturn (\n        <>\n            {context === \"review\"\n                ? <><MDBNavBar\n                    title={`Review of: ${log.label}`}\n                    leftNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={saveAnalysisLogLocally}>Save Debriefing Log\n                        </Button>}\n                    rightNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={toggleComments}>Toggle Comments\n                        </Button>}\n                     /></>\n                : <><MDBNavBar\n                    title={`Analysis for: ${log.label}`}\n                    /></>\n            }\n            <form>\n            <div style={{ overflowY: \"auto\", maxHeight: \"700px\" }}>\n                <Table borderless size=\"sm\">\n                    <thead>\n                        <tr>\n                            <th className=\"table-header\"> ID </th>\n                            <th className=\"table-header\"> Timestamp </th>\n                            <th className=\"table-header\"> Action Description </th>\n                            <th className=\"table-header\"> Feedback </th>\n                            {showCommentColumn && <th className=\"table-header\"> Comments </th>}\n                        </tr>\n                    </thead>\n                    <tbody className=\"scrolling\">\n                        {formattedActions.map((currentEntry, index) => (\n                            <tr key={index}>\n                                {currentEntry.type === \"header\"\n                                    ? dispHeaderRow(currentEntry)\n                                    : dispDataRow(currentEntry)\n                                }\n                            </tr>\n                        ))}\n                    </tbody>\n                </Table>\n            </div>\n        </form>\n        </>\n\n    )\n}\n\nexport {saveAnalysisLog}  \nexport default DisplayBaseDebriefing\n","import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID } from '@meddbriefer/scenario-data/index'\nimport {analyzeEvents} from './analyzeEvents'\nimport DisplayBaseDebriefing from './DisplayBaseDebriefing';\n\n\n\nfunction AnalyzeDebriefing ()  {\n    const { logID } = useParams()\n    const [observerLog, setObserverLog] = useState (undefined)\n    const [log, setLog] = useState(undefined)\n    const [scenario, setScenario] = useState(undefined)\n    const [analyzed, setAnalyzed] = useState(false)\n    const [loaded, setLoaded] = useState(false)\n\n    // eslint-disable-next-line\n    \n    // Set to true once all performed actions have been displayed in the log\n    // const [finishedPerformedActions, setFinishedPerformedActions] = useState(false);\n\n    //console.log (\"logID:\", logID)\n\n    function checkOnOverwriting() {\n        if (window.confirm (\"Are you sure you want to overwrite the existing analysis?  Any prior comments previously added will be lost.\")){\n            analyzeEventsHook(scenario, observerLog) \n            \n        }\n\n    }\n\n    async function analyzeEventsHook(scenario, log) {\n      analyzeEvents(scenario, log)}\n\n    \n    async function processEvents ()  {\n        //console.log(\"in processEvents to process a new observer file\")\n        if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n            {analyzeEventsHook(scenario, observerLog)\n            setAnalyzed(true)} \n        else {checkOnOverwriting()} \n        setAnalyzed(true)\n        return (true)    \n    }\n\n    useEffect(\n        () => {\n          getLog(db,logID)\n            .then(observerLogData => {  \n              //console.log(\"retrieve observerLogData\", observerLogData) \n              setObserverLog(observerLogData)    \n            })\n            .catch(error => alert('error fetching observer log', error))   \n        // eslint-disable-next-line\n    }, []\n      )\n    \n      useEffect(\n        () => {\n          !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n            .then(scenData => {\n              console.log(\"retrieve scenario:\", scenData)\n              setScenario(scenData)\n            })\n    \n        }, [observerLog]\n      )\n    \n      useEffect(\n        () => {\n          !!scenario && processEvents()\n          //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n    \n      useEffect(\n        () => {\n          !!analyzed && getDebriefLog(db, logID)\n            .then(logData => {\n              //console.log(\"retrieve Debriefing result:\", logData)\n              setLog(logData)  \n            })\n            .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n    \n      useEffect(\n        () => {\n          !!log && setLoaded(true) \n        }, [log]\n      )\n    \n      if (!loaded) {\n        return (<h3>Loading</h3>)\n      }\n    \n\n\n    return (\n        <DisplayBaseDebriefing\n        log={log}\n        actions={log.events}\n        scenario={scenario}\n        context={\"initial-analysis\"}\n        />\n    )\n}\n\nexport default AnalyzeDebriefing","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLog , getPublishedScenarioByID } from \"@meddbriefer/scenario-data/index\"\nimport AnalyzeDebriefing from '../components/AnalyzeDebriefing'\n\nconst Log = () => {\n\n  const { logID } = useParams()\n  const [ log, setLog ] = useState(null)\n  const [ scenario, setScenario] = useState(null)\n  const [loaded, setLoaded] = useState(false)\n\n  useEffect(\n    () => {\n      getLog(db,logID)\n        .then(logData => {\n          setLog(logData)\n        })\n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      //!!log && getScenarioByName(db, log.scenarioName, \"V2\")\n      !!log && getPublishedScenarioByID(db, log.scenarioID)\n        .then(scenData => {\n          setScenario(scenData)\n          console.log(\"scenario\", scenData)\n        })\n\n    }, [log]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && setLoaded(true)\n    }, [scenario]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n  return ( \n      <AnalyzeDebriefing \n        log={logID} \n      /> \n    )\n\n\n}\n\nexport default Log;\n","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { analyzeEvents } from '../components/analyzeEvents'\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID} from \"@meddbriefer/scenario-data/index\"\nimport DisplayBaseDebriefing from '../components/DisplayBaseDebriefing'\n\n\n\nfunction DisplayDebriefing () {\n\n  const { logID } = useParams()\n  const [observerLog, setObserverLog] = useState(undefined)\n  const [log, setLog] = useState(undefined)\n  const [scenario, setScenario] = useState(undefined)\n  const [analyzed, setAnalyzed] = useState(false)\n  const [loaded, setLoaded] = useState(false)\n\n  \n  \n  async function processLog () {\n    //console.log(\"in processLog to display existing analysis\")\n    if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n          {analyzeEvents(scenario, observerLog) \n          }\n    setAnalyzed(true)\n    return (true)\n  }\n  \n\n  //get observer log first\n\n  useEffect(\n    () => {\n      getLog(db, logID)\n        .then(observerLogData => {  \n          //console.log(\"retrieve observerLogData\", observerLogData) \n          setObserverLog(observerLogData)    \n        })\n        .catch(error => alert('error fetching observer log', error))   \n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n        .then(scenData => {\n          console.log(\"scenario:\", scenData)\n          setScenario(scenData)\n        })\n\n    }, [observerLog]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && processLog()\n      //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n      \n  useEffect(\n      () => {\n        !!analyzed && getDebriefLog(db,logID)\n          .then(logData => {\n            //console.log(\"retrieve Debriefing result:\", logData)\n            setLog(logData)  \n          })\n          .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n\n  useEffect(\n    () => {\n      !!log && setLoaded(true) \n    }, [log]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n\n\n  return (\n    <DisplayBaseDebriefing\n      log={log}\n      actions={log.events}\n      scenario={scenario}\n      context={\"review\"} />\n  )\n\n\n}\n\nexport default DisplayDebriefing;\n","import React from \"react\"\n\nimport MDBNavBar from \"./MDBNavBar\"\n\nconst UnauthedLayout = (props) => {\n\n    return (\n        <>\n            <MDBNavBar\n                title=\"MedDBriefer Authentication\"\n            />\n            { props.children }\n        </>\n    )\n}\n\nexport default UnauthedLayout","import React from \"react\"\n\nimport {\n    HashRouter as Router,\n    Switch,\n} from \"react-router-dom\"\n\nimport { AuthProvider, PrivateRoute } from \"@meddbriefer/mdb-auth\"\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport \"./styles.css\";\n\nimport LogList from \"./routes/LogList\"\nimport Log from \"./routes/Log\"\nimport DisplayDebriefing from \"./routes/DisplayDebriefing\"\n\n\nimport UnauthedLayout from \"./components/UnauthedLayout\"\n\nconst App = (props) => {\n\n    return (\n        <AuthProvider>\n            <Router>\n\n                <Switch>\n                    <PrivateRoute\n                        exact path=\"/logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={Log}\n                    />\n                    <PrivateRoute\n                        exact path=\"/debriefing-feedback-logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={DisplayDebriefing}\n                    />\n                    {/*default (catchall) route*/}\n                    <PrivateRoute\n                        exact match=\"/\"\n                        authFlowLayout={UnauthedLayout}\n                        component={LogList}\n                    />\n                </Switch>\n            </Router>\n        </AuthProvider>\n    )\n}\n\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
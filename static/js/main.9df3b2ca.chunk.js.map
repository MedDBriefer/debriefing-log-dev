{"version":3,"sources":["../../../libs/mdb-firebase/index.js","../../../libs/scenario-data/constants.js","../../../libs/scenario-data/index.js","../../../libs/scenario-data/intvPrompts.js","../../../libs/scenario-data/intvMenuItems.js","routes/LogList.js","../../../libs/feedback-data/c1Data.js","../../../libs/feedback-data/c2Data.js","../../../libs/feedback-data/analysisData.js","components/debriefingUtils.js","components/analyzeEvents.js","utils.js","components/scenarioDataAccesors.js","components/summarizeAnalysis.js","components/MDBNavBar.js","components/DisplayBaseDebriefing.js","components/AnalyzeDebriefing.js","routes/Log.js","routes/DisplayDebriefing.js","components/UnauthedLayout.js","App.js","reportWebVitals.js","index.js"],"names":["userApp","getOrInitializeApp","appCfg","name","app","appID","matches","firebase","apps","filter","options","appId","length","getApp","initializeApp","process","REACT_APP_APP_ENV","console","log","apiKey","authDomain","projectId","storageBucket","messagingSenderId","measurementId","prodApp","db","auth","firestore","ASSESS","ASSESS_OPTION","AWO","DECISION","DECISION_OPTION","INTERV","PHASE","REQUIRED","SUB_PHASE","MDB_TYPES","Object","freeze","ASSESSO","CL_HEADING","CL_PROMPT","DIST_PROMPT","NESTED_CHECKLIST","REQURED","PROMPT_SET","PROMPT","ANSWER","SELECTION_TYPES","ONE","OOM","NONE","CHECKLIST_STEP_TYPES","AW","BR","BL","SH","OPTION_TYPES","ANALYSIS_TYPES","MIN","OPT","CONTRA","getPublishedScenarioByID","ST","interventionID","scenarioID","collection","doc","get","then","data","verifyDocument","collectionId","documentId","a","where","set","empty","getLog","logID","id","getDebriefLog","LogList","useState","logs","setLogs","logsLoaded","setLogsLoaded","useEffect","querySnapshot","docs","map","label","scenario","scenarioName","userName","timestamp","result","catch","error","Table","striped","borderless","size","hover","to","colorTypes","iconTypes","assessmentEntries","phaseStatusList","absent","errors","good","exceptionDefs","exceptions","globalConstraints","before","beforeOp","after","afterOp","type","conditionalConstraints","scenarioConstraintIDs","intvChecks","intvStatusNeeded","vitalsNeeded","requiredSubphases","requiredPhaseNames","requiredPhaseAndSubPhases","itemByID","itemByLabel","checklistHierarchy","pushNew","elt","array","includes","push","getPhaseStatus","statuses","itemStatuses","phaseStatuses","forEach","status","entries","key","value","getStatesForStatus","stateList","state","getAssessmentEntry","currentEntry","aIndex","assessmentEntry","displayColor","getColor","fixStrSp","textString","newString","textArray","split","lenTextArray","item","i","newItem","trim","getFeedback","intvStatus","intvStatusFB","fb","checked","notChecked","entry","foundCk","generateIntvStatusFB","feedbackString","feedbackArray","firstChar","charAt","substring","previousString","slice","nextString","toUpperCase","scenarioConstraints","getEvents","events","field","val","getEventsByIdTime","_","require","saveAnalysisLog","actions","hierAssessResults","hierProblemResults","constraintsViolated","docRef","ObserverFileCreater","ObserverFileName","commenter","schemaVersion","Date","toLocaleString","newActionsList","newObj","filterUnknown","logObj","index","undefined","pickBy","getTimestamp","seconds","toISOString","substr","groupByKey","listOfObjs","fldName","reduce","hash","obj","concat","getChecklistItemsByType","itemType","checkListMetaData","e","allAssessResults","allProblemResults","getEntriesUnderHeader","headerID","level","populate","header","mergeHeaderStatuses","eventItems","results","expertPhase","phaseID","labelID","overallStatus","headerStatuses","headerItems","summarizeAnalysis","finalActions","problems","event","prob","intvHeaderIndex","probLabel","headerObject","entryToModify","subLevel","topLevel","newStatus","subitems","updateHeader","constraint","arg1","phaseOrderStatus","arg2","problemStates","cautionStates","subPhases","initGlobals","scen","constraintIDs","initializeConstraints","initializeItemLookupByID","initializeItemLookupByLabel","phases","clSteps","stepOptions","step","phChecklistSteps","subPhase","spChecklistSteps","sp","items","phSubphases","ph","getChecklistHierarchy","findPhaseSubphasesOrdered","checklistLookupByID","intvLookupByID","intvMetaData","assign","checklistLookupByLabel","intvLookupByLabel","subPhIds","findNameNumID","names","occurrence","numericalID","numericalIDStart","numericalIDEnd","unknownItem","getItem","storeMisOrderedFB","FB","constraintType","phaseNames","objToModify","phaseIndex","phaseObjects","phaseName","hasSubPhases","findObjByNumerialID","orderingFB","appendString","saveFailedConstraint","lateArg","otherArg","constraintID","op","checkAgainst2ndArgs","arg1st","args2nd","direction","entryNames","endNum1st","startNum1st","label1st","parPhFB","arg","arg2nd","label2nd","startNum2nd","endNum2nd","checkAgainstKB","listOfNames","listOfEntries","uniqueListOfNames","startIndex","endIndex","phaseObjectNames","collectEntriesToCheckConstraints","uniqueEntryNames","firstArg","firstArgItem","constraints","getConstraint","checkConstraintsForArg","insertInPhaseInOrder","object","objIndex","phase","when","lastIndexOf","splice","getEndSubPhaseIndex","inPhaseId","subPhaseName","getSubPhases","reversedSubPhases","reverse","find","getEndSubPhase","phaseId","determineHLcolor","lowerColor","higherColor","newColor","evalForIncorrectAnswer","promptID","answerID","isIntervention","answers","associations","checkListCorrectness","Array","isArray","ansId","getCorrectAnswerLabel","metaData","answerLabels","answer","j","getAnswerLabel","answerLabel","insertMissingInterventions","confirmedEvents","indexCounter","action","k","phaseObject","assessments","assessmentsNeeded","protocols","protocol","optional","required","actionDescription","suggestedPhase","orderedArrayObjects","objectsBefore","objectBefore","requiredObjectBefore","objectAfter","requiredObjectAfter","indexBefore","indexAfter","indexRequiredBefore","indexRequiredAfter","insertionIndex","findIndex","insertInPhaseRelativeToSuggestedOrder","analyzeEvents","problemDefs","problemDef","problem","allProblemProtocols","lifeThreat","solution","solutions","contraindications","minimalWhy","setupProblems","formattedActions","annotatedResults","interventionsConfirmed","trackForStatus","priorPhase","parentPhase","parentIndex","newPhaseStart","assessmentTypes","eventObj","workingPhase","eventType","processingState","prioreventObj","correctAnswerLabel","givenAnswerLabel","wrongAnswer","answerDetails","intervention","pop","answerCorrect","incorrectAnswersFB","vital","vitalType","vitalEntry","vitalEntries","updatedEntries","updateVital","PROBLEM_ACTION_FIELDS","statusChecking","intv","initialEntry","contra","why","contraindicatedWhy","incorrectAnswerFB","annotateInputEvents","intvsTracking","kbUpdates","updatedPhases","priorPh","insertMissingSubphases","postAssessmentReview","neededScenAssessments","collectScenAssessments","checklistSteps","md","exceptionDef","exception","cls","assessmentFB","assessmentFindings","checkForMissingAssessments","postInterventionReview","statusTracking","toUpdate","insertMissingIntvChecks","displayObjects","entryIndex","headerIndex","problemHeaderColor","subPhaseColor","subPhaseStatuses","newPhaseObjects","headerObj","subHeaderObj","priorHLPhaseItem","endEntry","iPhaseObjects","subheader","localPhaseName","localPhaseItem","highLevelPhase","highLevelPhaseItem","organizeLogDisplay","pActions","pNames","pIndex","pActIndex","indexOf","processedIds","pIds","pEntry","actionNeeded","minimalNeeded","minimal","found","allActionFound","allMinimalFound","numericalIDsChanged","foundId","z","candidateHeader","foundHeader","findHeaderFor","summaryResults","MDBNavBar","title","leftNav","rightNav","useContext","AuthContext","isAuthenticated","signOutUser","Navbar","color","dark","NavbarBrand","href","Nav","NavbarText","tag","Button","onClick","DisplayBaseDebriefing","context","showCommentColumn","setShowCommentColumn","setFormattedActions","getLabel","vitalLabel","regularLabel","getStatusLabel","metaEntry","me","findingsData","phaseLabel","finding","saveComment","orig","target","defaultValue","comment","entryID","newEntry","updateFormattedAction","dispDataRow","className","rows","cols","onBlur","record","rec","displayIt","style","overflowY","maxHeight","colSpan","AnalyzeDebriefing","useParams","observerLog","setObserverLog","setLog","setScenario","analyzed","setAnalyzed","loaded","setLoaded","checkOnOverwriting","window","confirm","analyzeEventsHook","observerLogData","alert","scenData","processEvents","logData","Log","DisplayDebriefing","processLog","UnauthedLayout","props","children","App","exact","path","authFlowLayout","component","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9df3b2ca.chunk.js","sourcesContent":["import firebase from 'firebase/app'\nimport \"firebase/auth\";\nimport \"firebase/firestore\"\n\nconst prodFirebaseCfg = {\n    apiKey: \"AIzaSyBOgWAbXUGckpad2sk0IUo00hZsV4WxG0E\",\n    authDomain: \"meddbriefer-68cd4.firebaseapp.com\",\n    projectId: \"meddbriefer-68cd4\",\n    storageBucket: \"meddbriefer-68cd4.appspot.com\",\n    messagingSenderId: \"1087114796018\",\n    appId: \"1:1087114796018:web:679fbab38dbf78af0ce96b\",\n    measurementId: \"G-Q7QZKC9KHW\"\n}\n\nconst devFirebaseCfg = {\n    apiKey: \"AIzaSyBqnEMwEstp4D7Mvtbw9OTAiNJ7qza0Ses\",\n    authDomain: \"meddbriefer-dev.firebaseapp.com\",\n    projectId: \"meddbriefer-dev\",\n    storageBucket: \"meddbriefer-dev.appspot.com\",\n    messagingSenderId: \"144940722070\",\n    appId: \"1:144940722070:web:4de179ebb58d84a7679fb7\"\n};\n\n\nconst pamFirebaseCfg = {\n    apiKey: \"AIzaSyB9eVT-fu4TOjxHoPAXqsnz9tCcbTJkTOw\",\n    authDomain: \"pamdev-ea800.firebaseapp.com\",\n    projectId: \"pamdev-ea800\",\n    storageBucket: \"pamdev-ea800.appspot.com\",\n    messagingSenderId: \"366450927885\",\n    appId: \"1:366450927885:web:caa5f022ef1de182a0e844\",\n    measurementId: \"G-JC5XZEPYT1\"\n  };\n\n  const scottFirebaseConfig = {\n  apiKey: \"AIzaSyBEhbIdVW2F2vvvfvpNb2SsCDP9Yoc__z8\",\n  authDomain: \"scottdev-f6528.firebaseapp.com\",\n  projectId: \"scottdev-f6528\",\n  storageBucket: \"scottdev-f6528.appspot.com\",\n  messagingSenderId: \"447730403122\",\n  appId: \"1:447730403122:web:1727020dbac4ad4cf6f92b\"\n\n};\n\n// console.log(`NODE_ENV: ${process.env.NODE_ENV}`)\n\nlet userApp\n\nconst getApp = (appID) => {\n    const matches = firebase.apps.filter(app => app.options.appId === appID)\n    // console.log(\"matches\", matches)\n    return (matches.length === 1) ? matches[0] : null\n}\n\nconst getOrInitializeApp = (appCfg, name) => {\n    const app = getApp(appCfg.appId)\n    // console.log(`${appCfg.appId} already exists: ${!!app}`)\n    return (!!app) ? app : firebase.initializeApp(appCfg, name)\n}\n\n// don't reinitialize app if it already exists\n// const prodApp = !firebase.apps.length ? firebase.initializeApp(prodFirebaseCfg) : firebase.app()\n//const prodApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\nif (\"pam\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using pjordan config\")\n    userApp = getOrInitializeApp(pamFirebaseCfg, \"pam\")\n} else if (\"scott\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using scott config\")\n    userApp = getOrInitializeApp(scottFirebaseConfig)\n}\nelse {\n    console.log(\"using production config\")\n    userApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\n}\n\nconst prodApp = userApp;\n// const devApp = function() {\n//     if (process.env.NODE_ENV !== \"production\") {\n//         return getOrInitializeApp(devFirebaseCfg, \"development\")\n//      }\n//      return null\n// }()\n\n// console.log(firebase.apps)\n\n\n\n\nexport const auth = prodApp.auth()\nexport const db = prodApp.firestore()\n\n// export const db = function() {\n//     return process.env.NODE_ENV !== \"production\" ? devApp.firestore() : prodApp.firestore()\n// }()\n","// the following constants are deprecated (need to figure out how to handle this)\n// use MDB_TYPES, SELECTION_TYPES, PREFIXES, and SYSTEMS instead\nexport const ANSWER = \"answer\"\nexport const ASSESS = \"assessment\"\nexport const ASSESSO = \"assessment-option\"\nexport const ASSESS_OPTION = \"assessment-option\"\nexport const AWO = \"assessment-with-options\"\nexport const CB = \"checkbox\"\nexport const CL_HEADING = \"checklist-heading\"\nexport const CL_PROMPT = \"checklist-prompt\"\nexport const CRIT_FAIL = \"critical-criteria\"\nexport const DECISION = \"decision\"\nexport const DECISION_OPTION = \"decision-option\"\nexport const DIST_PROMPT = \"distinguishing-prompt\"\nexport const HEADING = \"heading\" //not a leaf node, simply a step which has child steps\nexport const INTERV = \"intervention\" // an action performed on the patient\nexport const INTV_FORM = \"intervention-form\"\nexport const NESTED_CHECKLIST = \"nested-checklist\"\nexport const NONE = \"none\"\nexport const ONE = \"one\"\nexport const OOM = \"one-or-more\"\nexport const OPTION = \"option\"\nexport const PHASE = \"phase\"\nexport const PROMPT = \"prompt\"\nexport const PROMPT_SET = \"prompt-set\"\nexport const REQUIRED = \"required-action\"   // an action the EMT performs, but not on the patient\n// keeping as I had a typo. need to deprecate somehow\nexport const REQURED = REQUIRED\nexport const SUB_PHASE = \"sub-phase\"\n\nexport const MDB_TYPES = Object.freeze({\n    PHASE: PHASE,\n    SUB_PHASE: SUB_PHASE,\n    ASSESS: ASSESS,\n    AWO: AWO,\n    ASSESS_OPTION: ASSESS_OPTION,\n    ASSESSO: ASSESS_OPTION,\n    CL_HEADING: CL_HEADING,\n    CL_PROMPT: CL_PROMPT,\n    DECISION: DECISION,\n    DECISION_OPTION: DECISION_OPTION,\n    DIST_PROMPT: DIST_PROMPT,\n    NESTED_CHECKLIST: NESTED_CHECKLIST,\n    REQUIRED: REQUIRED,\n    REQURED: REQUIRED,\n    INTERV: INTERV,\n    PROMPT_SET: PROMPT_SET,\n    PROMPT: PROMPT,\n    ANSWER: ANSWER,\n})\nexport const SELECTION_TYPES = Object.freeze({\n    ONE: ONE,\n    OOM: OOM,\n    NONE: NONE\n})\nexport const SELECTION_TYPE_LABELS = Object.freeze({\n    ONE: \"One\",\n    OOM: \"One or more\",\n    NONE: \"None\"\n})\nexport const PREFIXES = Object.freeze({\n    PHASE: \"\",\n    SUB_PHASE: \"\",\n    ANSWER: \"answer-\",\n    ASSESS: \"assess-\",\n    AWO: \"assessment-with-options-\",\n    ASSESS_OPTION: \"assess-option-\",\n    CL_PROMPT: \"cl-prompt-\",\n    DECISION: \"decision-\",\n    DECISION_OPTION: \"decision-option-\",\n    INTERV: \"intv-\",\n    PROMPT_SET: \"prompt-set-\",\n    PROMPT: \"prompt-\",\n    REQUIRED: \"required-action-\",\n})\n\nexport const SYSTEMS = Object.freeze({\n    AW: \"airway\",\n    BR: \"breathing\",\n    BL: \"bleeding\",\n    SH: \"shock\",\n})\nexport const SYSTEM_LABELS = Object.freeze({\n    AW: \"Airway\",\n    BR: \"Breathing\",\n    BL: \"Bleeding\",\n    SH: \"Shock\"\n})\n\nexport const CHECKLIST_STEP_TYPES = [ASSESS, AWO, DECISION, REQUIRED]\nexport const OPTION_TYPES = [ASSESS_OPTION, DECISION_OPTION]\nexport const ANALYSIS_TYPES = [ASSESS, AWO, DECISION, REQUIRED, INTERV, PHASE, SUB_PHASE]\n\nexport const PROTOCOL_RELATIONSHIPS = Object.freeze({\n    NONE: \"\",\n    MIN: \"mimimal\",\n    OPT: \"optional\",\n    CONTRA: \"contraindicated\"\n})","\nimport _ from \"lodash\"\n\nimport { MDB_TYPES } from \"./constants.js\"\nimport { ScenarioType, PublishedScenario } from \"./types.js\"\n\n// the rest of these imports can go away soon. simply allows me to delete objects form the db\n// and reload with files. not used if records exist in db\nimport INTVS from \"./intvs.js\"\nimport INTV_PROMPTS from \"./intvPrompts.js\"\nimport INTV_PROMPT_ANSWERS from \"./intvPromptAnswers.js\"\nimport INTV_MENU_CATS from \"./intvMenusCats.js\"\nimport INTV_MENU_ITEMS from \"./intvMenuItems.js\"\n\nexport const loadIntvs = () => {\n    const tmp = INTVS.map(e => {\n        const rec = {...e}\n        if (!e.abbrLabel) {\n            rec.abbrLabel = e.label\n        }\n        if (!e.distPrompts) {\n            rec.distPrompts = []\n        }\n        if (!e.prompts) {\n            rec.prompts = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPrompts = () => {\n    const tmp = INTV_PROMPTS.map(e => {\n        const rec = {...e}\n        if (!!e.interventionID) {\n            const found = INTVS.find(i => i.id === e.interventionID)\n            if (!found) {\n                console.log(`loadIntvPrompts(${e.id}) ${e.interventionID} not found`)\n            }\n        }\n        if (!e.abbrLabel) {\n            rec.abbrLabel = \"\"\n        }\n        if (!e.feedback) {\n            rec.feedback = rec.label\n        }\n        if (!e.answers) {\n            rec.answers = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPromptAnswers = () => {\n    const tmp = INTV_PROMPT_ANSWERS.map(e => {\n        if (!e.abbrLabel) {\n            e.abbrLabel = \"\"\n        }\n        const found = INTV_PROMPTS.find(p => p.id === e.promptID)\n        if (!found) {\n            console.log(`loadIntvPromptAnswers(${e.id}) ${e.promptID} not found`)\n        }\n        return e\n    })\n    return tmp\n}\n\nexport const getScenarios = (db, scenarioType, schemaVersion) => {\n    const query = db.collection(\"scenarios\")\n             .where(\"scenarioType\", \"==\", scenarioType)\n             .where(\"schemaVersion\", \"==\", schemaVersion)\n    return query.get()\n        .then(snapShot => {\n            const scenarios = []\n            if (snapShot.size > 0) {\n                snapShot.docs.forEach(doc => {\n                    const data = doc.data()\n                    scenarios.push({\n                        id: data.id,\n                        name: data.name,\n                        scenarioType: data.scenarioType,\n                        schemaVersion: data.schemaVersion\n                    })\n                })\n            }\n            return scenarios\n        })\n}\n\nexport const getPublishedScenarioObjectByID = async (db, scenarioID) => {\n    const data = await getPublishedScenarioByID(db, scenarioID)\n    return new  PublishedScenario(data)\n}\n\nexport const getPublishedScenarioByID = (db, scenarioID) => {\n    return db.collection(\"published-scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByID = (db, scenarioID) => {\n    return db.collection(\"scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByName = (db, scenarioName, schemaVersion) => {\n    return db.collection(\"scenarios\")\n    .where(\"name\", \"==\", scenarioName)\n    .where(\"schemaVersion\", \"==\", schemaVersion)\n    .limit(1)\n    .get()\n    .then(snapShot => {\n        if (snapShot.size === 1) {\n            return snapShot.docs[0].data()\n        } else {\n            throw new Error(\"document not found\")\n        }\n    })\n}\n\nconst addMissingScenarioTypeFields = (scenTypeData) => {\n    const msgs = []\n    if (!scenTypeData.interventions) {\n        msgs.push(\"loading intvs from file\")\n        scenTypeData.interventions = loadIntvs()\n    }\n    if (!scenTypeData.interventionPrompts) {\n        const errs = []\n        const tmpPrompts = loadIntvPrompts()\n        tmpPrompts.forEach(e => {\n            if (e.type === MDB_TYPES.PROMPT) {\n                // ignore this check if distinguishing prompt (not associated with a single intv)\n                if (undefined === scenTypeData.interventions.find(rec => rec.id === e.interventionID)) {\n                    errs.push(`bad interventionID ${e.interventionID}`)\n                }\n            }\n        })\n        let msg = \"loading intv prompts from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPrompts = tmpPrompts\n    }\n    if (!scenTypeData.interventionPromptAnswers) {\n        const errs = []\n        const tmpPromptAnswers = loadIntvPromptAnswers()\n        tmpPromptAnswers.forEach(e => {\n            if (undefined === scenTypeData.interventionPrompts.find(rec => rec.id === e.promptID)) {\n                errs.push(`bad promptID ${e.promptID}`)\n            }\n        })\n        let msg = \"loading intv prompt answers from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPromptAnswers = tmpPromptAnswers\n    }\n    if (!scenTypeData.interventionMenuCategories) {\n        msgs.push(\"loading intv menu categories from file\")\n        scenTypeData.interventionMenuCategories = INTV_MENU_CATS\n    }\n    if (!scenTypeData.interventionMenuItems) {\n        const errs = []\n        const tmpIntvMenuItems = INTV_MENU_ITEMS.map(e => {\n            const found = scenTypeData.interventionMenuCategories.find(cat => cat.id === e.intvCategoryID)\n            if (!found) {\n                errs.push(`bad intvCategoryID ${e.intvCategoryID}`)\n            } else {\n                if (e.type === MDB_TYPES.INTERV) {\n                    const intv = scenTypeData.interventions.find(i => i.id === e.interventionID)\n                    if (!intv) {\n                        errs.push(`bad interventionID ${e.interventionID}`)\n                    } else {\n                        e.label = intv.label\n                    }\n                }\n                return e\n            }\n        })\n        let msg = \"loading intv menu items from file...\"\n\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionMenuItems = tmpIntvMenuItems\n    }\n    if (msgs.length > 0) {\n        msgs.forEach(m => console.log(m))\n    } else {\n        console.log(\"all data loaded from db. files not needed\")\n    }\n    return scenTypeData\n}\n\nexport const getScenarioTypeObjectByID = async (db, scenarioTypeID) => {\n    const data = await getScenarioTypeByID(db, scenarioTypeID)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeObject = async (db, scenarioType, schemaVersion) => {\n    const data = await getScenarioType(db, scenarioType, schemaVersion)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeByID = (db, scenarioTypeID) => {\n    return db.collection(\"scenario-types\")\n        .doc(scenarioTypeID)\n        .get()\n        .then(doc => {\n        const data = doc.data()\n        data.id = doc.id\n        return addMissingScenarioTypeFields(data)\n        })\n        .catch(error => {\n            console.log(error)\n            return error\n        })\n}\n\nexport const getScenarioType = (db, scenarioType, schemaVersion) => {\n    return db.collection(\"scenario-types\")\n            .where(\"name\", \"==\", scenarioType)\n            .where(\"schemaVersion\", \"==\", schemaVersion)\n            .limit(1)\n            .get()\n            .then(snapShot => {\n                if (snapShot.size === 1) {\n                    return addMissingScenarioTypeFields(snapShot.docs[0].data())\n                } else {\n                    throw new Error(\"document not found\")\n                }\n            })\n}\n\n\n\n// FIXME: this needs to go away, although I need to figure out if it's in use anywhere first\nexport const getPromptAndOptions = (scenarioTypeOrPubScenario, promptID) => {\n    const scenType = scenarioTypeOrPubScenario\n    const prompt = scenType.interventionPrompts.find(e => e.id === promptID)\n    if (!!prompt) {\n        const options = prompt.answers.map(ansID => scenType.interventionPromptAnswers.find(a => a.id === ansID))\n        prompt.options = options.map(opt => {\n            return {...opt, prompt: prompt.label}\n        })\n    }\n    return prompt\n}\n\n// moved over from apps/data-entry/src/scripts/connect-firebase\n// added 'db' as first param so that these functions can be used either from web or server firebase APIs\n/**\n * Verify document doesn't already exist in database.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns True if document with given ID doesn't exist yet.\n */\nexport const verifyDocument = async (db, collectionId, documentId) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    return set.empty;\n};\n\n// returns true if combo of name and schemaVersion fields is unique\nexport const verifyDocNameUniqueness = async (db, collectionID, candidateName, dbNameField, schemaVersion) => {\n    const snapshot = await db.collection(collectionID)\n        .where(dbNameField, \"==\", candidateName)\n        .where(\"schemaVersion\", \"==\", schemaVersion)\n        .get()\n    return snapshot.empty\n}\n\n// Upload document object to database\nexport const publishDocument = async (db, collectionId, documentObject, documentId) => {\n    documentId\n        ?\n        await db.collection(collectionId).doc(documentId).set(documentObject) :\n        await db.collection(collectionId).doc().set(documentObject);\n};\n\n// Update document with given id\nexport const updateDocument = async (db, collectionId, documentId, documentObject) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    set.empty ?\n        publishDocument(collectionId, documentObject) :\n        await db.collection(collectionId).doc(set.docs[0].id).set(documentObject);\n};\n\n/**\n * Will save document, using auto-generated IDs if documentObject doesn't have\n * an 'id' attribute.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {object} documentObject\n */\nexport const saveDocument = async (db, collectionId, documentObject) => {\n    const doc = (!documentObject.id) ?\n        db.collection(collectionId).doc() :\n        db.collection(collectionId).doc(documentObject.id);\n    documentObject.id = doc.id;\n    await doc.set(documentObject);\n    return documentObject.id\n}\n\n/**\n * Query collection for document with id\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns {object} Object containing document data.\n */\nexport const getDocument = async (db, collectionId, documentId) => {\n    const doc = await db.collection(collectionId).doc(documentId).get();\n    return doc.data();\n};\n\n/**\n * Query collection for document with name\n * @param {string} collectionId\n * @param {string} documentName\n * @returns {object} Object containing document data.\n */\nexport const getDocumentWithName = async (db, collectionId, documentName) => {\n    const set = await db.collection(collectionId).where(\"name\", \"==\", `${documentName}`).get();\n    return set.docs[0]?.data();\n};\n\n/**\n * Delete document from collection\n * @param {string} collectionId\n * @param {string} documentId\n */\nexport const deleteDocument = async (db, collectionId, documentId) => {\n    await db.collection(collectionId).doc(documentId).delete();\n};\n\n/**\n * Pull collection from database as array of document objects\n * @param {string} collectionId\n * @returns {object[]} An array containing all of the document in the collection.\n */\nexport const getCollection = async (db, collectionId) => {\n    const collection = await db.collection(collectionId).get();\n    return collection.docs?.map(item => item.data());\n};\n\n// copied over from /apps/debriefer/src/scripts/connect-firebase and 'db' param added as first param\n\n// Get a list of document names and a copy of each document\nexport const listDocumentNames = async (db, collectionId) => {\n    let documentList = db.collectionGroup(collectionId);\n    let documentDictionary = {};\n    documentList.get().then((querySnapshot) => {\n        querySnapshot.forEach((doc) => {\n            documentDictionary[doc.id] = doc.data();\n        });\n    });\n    return documentDictionary;\n}\n\nexport const getLogs = (db) => {\n    return db.collection(\"logs\").get()\n        .then(querySnapshot => {\n            return querySnapshot.docs.map(doc => {\n                const data = doc.data()\n                return {\n                    id: doc.id,\n                    label: data.label,\n                    scenario: data.scenarioName,\n                    userName: data.userName,\n                    timestamp: data.timestamp\n                }\n            })\n        })\n}\n\n\nexport const getLog = (db, logID) => {\n    return db.collection(\"logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const getDebriefLog = (db, logID) => {\n    return db.collection(\"debriefing-feedback-logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const createInterventionVariant = (distPromptIds2OptIds) => {\n    // the list of opt IDs mapped to each distPromptID needs to be sorted in order\n    // to make them comparable\n    const retVal = {}\n    Object.entries(distPromptIds2OptIds).forEach(([distPromptID, optionsArray]) => {\n        retVal[distPromptID] = optionsArray.sort()\n    })\n    return retVal\n}\n\nexport const interventionVariantsAreEqual = (intvVariant1, intvVariant2) => {\n    return _.isEqual(intvVariant1, intvVariant2)\n}\n\n","import { MDB_TYPES, SELECTION_TYPES as ST } from \"@meddbriefer/scenario-data/constants.js\"\n\nconst INTV_PROMPTS = [\n    {\n        \"id\": \"prompt-wound-location\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.ONE,\n        label: \"Where is the wound located?\",\n        abbrLabel: \"Wound location?\",\n        answers: [\n            \"answer-wound-location-head\",\n            \"answer-wound-location-neck\",\n            \"answer-wound-location-chest\",\n            \"answer-wound-location-abdomen-pelvis\",\n            \"answer-wound-location-posterior\",\n            \"answer-wound-location-genitalia\",\n            \"answer-wound-location-left-lower-extremity\",\n            \"answer-wound-location-right-lower-extremity\",\n            \"answer-wound-location-left-upper-extremity\",\n            \"answer-wound-location-right-upper-extremity\",\n            \"answer-wound-location-other\"\n        ]\n    },\n    {\n        \"id\": \"prompt-wound-locations\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.OOM,\n        label: \"Where are the wound(s) located?\",\n        abbrLabel: \"Wound location(s)?\",\n        answers: [\n            \"answer-wound-locations-head\",\n            \"answer-wound-locations-neck\",\n            \"answer-wound-locations-chest\",\n            \"answer-wound-locations-abdomen-pelvis\",\n            \"answer-wound-locations-posterior\",\n            \"answer-wound-locations-genitalia\",\n            \"answer-wound-locations-left-lower-extremity\",\n            \"answer-wound-locations-right-lower-extremity\",\n            \"answer-wound-locations-left-upper-extremity\",\n            \"answer-wound-locations-right-upper-extremity\",\n            \"answer-wound-locations-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-airway-patency-suction-device\",\n        \"interventionID\": \"intv-airway-patency-technique-suction-airway\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What kind of suction catheter will you use?\",\n        \"abbrLabel\": \"Suction catheter type?\",\n        \"answers\": [\n            \"answer-airway-patency-suction-yankauer\",\n            \"answer-airway-patency-suction-long-multiuse\",\n            \"answer-airway-patency-suction-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-advanced-airway-adjunct-type\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of advanced airway adjunct would you use?\",\n        \"abbrLabel\": \"Which advanced airway?\",\n        \"answers\": [\n            \"answer-alternative-rescue-airway-type-ett\",\n            \"answer-alternative-rescue-airway-type-combitube\",\n            \"answer-alternative-rescue-airway-type-lta\",\n            \"answer-alternative-rescue-airway-type-lma\",\n            \"answer-alternative-rescue-airway-type-igel\",\n            \"answer-alternative-rescue-airway-type-other\"\n        ]\n    }, {\n        \"id\": \"prompt-advanced-airway-tube-size\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\":\"one\",\n        \"label\": \"What tube size for advanced airway?\",\n        \"abbrLabel\": \"What size?\",\n        \"answers\": [\n            \"answer-alternative-airway-tube-size-7\",\n            \"answer-alternative-airway-tube-size-8\",\n            \"answer-alternative-airway-tube-size-age-div-4-plus-4\",\n            \"answer-alternative-airway-tube-size--age-div-4-plus-4-minus-5\",\n            \"answer-alternative-airway-tube-size-37f\",\n            \"answer-alternative-airway-tube-size-41f\",\n            \"answer-alternative-airway-tube-size-0\",\n            \"answer-alternative-airway-tube-size-1\",\n            \"answer-alternative-airway-tube-size-1-5\",\n            \"answer-alternative-airway-tube-size-2\",\n            \"answer-alternative-airway-tube-size-2-5\",\n            \"answer-alternative-airway-tube-size-3\",\n            \"answer-alternative-airway-tube-size-4\",\n            \"answer-alternative-airway-tube-size-5\",\n            \"answer-alternative-airway-tube-size-6\",\n            \"answer-alternative-airway-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-orotracheal-intubation-tube-insertion-depth\",\n        \"interventionID\": \"intv-orotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what depth would you insert the tube?\",\n        \"abbrLabel\": \"Tube insertion depth?\",\n        \"answers\": [\n            \"answer-orotracheal-intubation-tube-insertion-depth-21cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-23cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-3-times-tube-size\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasotracheal-intubation-tube-size\",\n        \"interventionID\": \"intv-nasotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What tube size would you use?\",\n        \"abbrLabel\": \"Tube size?\",\n        \"answers\": [\n            \"answer-nasotracheal-intubation-tube-size-6-to-6-5\",\n            \"answer-nasotracheal-intubation-tube-size-7-to-7-5\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus1\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus0-5\",\n            \"answer-nasotracheal-intubation-tube-size-0-5-1cm-less-than-oro-size\",\n            \"answer-nasotracheal-intubation-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasal-cannula-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-nasal-cannula-flow-rate-1-6-lpm\",\n            \"answer-nasal-cannula-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-nasal-cannula-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-nasal-cannula-target-saturation-gt-90-pct\",\n            \"answer-nasal-cannula-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-non-rebreather-mask-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-flow-rate-10-15-liters-min\",\n            \"answer-non-rebreather-mask-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-non-rebreather-mask-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-target-saturation-gt-90-pct\",\n            \"answer-non-rebreather-mask-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-bvm-ventilation-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what rate will you ventilate the patient?\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n            \"answer-bvm-ventilation-rate-10-12-bpm\",\n            \"answer-bvm-ventilation-rate-other\",\n        ]\n    }, {\n        \"id\": \"prompt-bvm-flow-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What flow rate would you administer?\",\n        \"abbrLabel\": \"Flow rate?\",\n        \"answers\": [\n            \"answer-bvm-flow-rate-15-ltm-or-gt\",\n            \"answer-bvm-flow-rate-other\",\n        ]\n    },{\n        \"id\": \"prompt-bvm-target-saturation\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-bvm-target-saturation-rate-gt-90-pct\",\n            \"answer-bvm-target-saturation-rate-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-tourniquet-placement-close-to-core-far-from-wound\",\n            \"answer-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-2nd-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the second tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-2nd-tourniquet-placement-adjacent-to-initial-tourniquet\",\n            \"answer-2nd-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-occlusive-dressing-injury-type\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-occulsivive-dressing-injury-type-open-pneumothorax\",\n            \"answer-occulsivive-dressing-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-occlusive-dressing-method\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How would you create a release valve on an occlusive dressing?\",\n        \"abbrLabel\": \"How would you create a release valve?\",\n        \"answers\": [\n            \"answer-occulsive-dressing-method-leave-one-side-untaped\",\n            \"answer-occulsive-dressing-method-leave-dressing-with-one-way-valve\",\n            \"answer-occulsive-dressing-method-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-pleural-decompression-injury-type\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-pleural-decompression-injury-type-tension-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-open-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-side-of-the-body\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"On which side of the body would you place the needle?\",\n        \"abbrLabel\": \"Which side would you place the needle?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-right\",\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-left\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-anatomical-landmark\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what anatomical landmark?\",\n        \"abbrLabel\": \"At what anatomical landmark?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-2nd-or-3rd-intercostal-space-mid-clavicular\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-4th-or-5th-intercostal-space-mid-axillary\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-size\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What size needle do you want to use?\",\n        \"abbrLabel\": \"Needle size?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-size-large-bore\",\n            \"answer-pleural-decompression-needle-size-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-length\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How long a needle would you use?\",\n        \"abbrLabel\": \"Needle length?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-length-2-inches-or-longer\",\n            \"answer-pleural-decompression-needle-length-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-transport-facility-choice\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of care facility will you transport the patient to?\",\n        \"abbrLabel\": \"Type of receiving facility\",\n        \"answers\": [\n            \"answer-transport-facility-choice-level-1-or-2-trauma-center\",\n            \"answer-transport-facility-choice-level-3-or-4-trauma-center\",\n            \"answer-transport-facility-choice-closest\",\n            \"answer-transport-facility-choice-other\"\n        ]\n    },{\n        \"id\": \"prompt-transport-method\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you transport this patient by air or ground ambulance?\",\n        \"abbrLabel\": \"Air or ground ambulance?\",\n        \"answers\": [\n            \"answer-transport-method-ambulance\",\n            \"answer-transport-method-helicopter\"\n        ]\n    },{\n        \"id\": \"prompt-transport-lights-siren-decision\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you use lights and sirens with this patient?\",\n        \"abbrLabel\": \"Lights and sirens?\",\n        \"answers\": [\n            \"answer-transport-lights-sirens-yes\",\n            \"answer-transport-lights-sirens-no\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-splint-type\",\n        \"interventionID\": \"intv-splint-fractures\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of splint would you use?\",\n        \"abbrLabel\": \"Type of splint?\",\n        \"answers\": [\n            \"answer-splint-type-board\",\n            \"answer-splint-type-moldable\",\n            \"answer-splint-type-traction\",\n            \"answer-splint-type-pelvic-binder\",\n            \"answer-splint-type-other\"\n        ]\n    },\n\n]\n/*\n    {\n        \"id\": \"\",\n        \"interventionID\": \"\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n        ]\n    },\n*/\nexport default INTV_PROMPTS","const INTV_MENU_ITEMS = [\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-als\",\n        \"label\": \"ALS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-amputation\",\n        \"label\": \"Manage amputation\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-bls\",\n        \"label\": \"BLS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-crico\",\n        \"label\": \"Cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-establish-patency\",\n        \"label\": \"Establish patency\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-insert-adjunct\",\n        \"label\": \"Insert adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-intubation\",\n        \"label\": \"Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-internal-bleeding\",\n        \"label\": \"Manage suspected internal bleeding\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-shock\",\n        \"label\": \"Manage hemorrhagic shock\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-medication-facilitated-intubation\",\n        \"label\": \"Medication Facilitated Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-open-airway\",\n        \"label\": \"Open airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-remove-foreign-body-obstructions\",\n        \"label\": \"Remove foreign body obstructions\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n         \"depth\": 1,\n         \"type\": \"heading\",\n         \"id\": \"heading-severe-external-bleeding\",\n         \"label\": \"Manage severe external bleeding\",\n         intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transfer\",\n        \"label\": \"Transfer patient to EMS vehicle\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transport\",\n        \"label\": \"Transport to care facility\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-advanced-airway-adjunct\",\n        interventionID: \"intv-advanced-airway-adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-airway-patency-technique-suction-airway\",\n        interventionID: \"intv-airway-patency-technique-suction-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-apply-sterile-dressings\",\n        interventionID: \"intv-apply-sterile-dressings\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-back-blows-and-chest-thrusts\",\n        interventionID: \"intv-back-blows-and-chest-thrusts\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-direct-pressure\",\n        interventionID: \"intv-control-severe-bleeding-technique-direct-pressure\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-2nd-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        interventionID: \"intv-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pressure-bandage\",\n        interventionID: \"intv-control-severe-bleeding-technique-pressure-bandage\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-load-and-go\",\n        interventionID: \"intv-control-severe-bleeding-technique-load-and-go\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-keep-patient-warm\",\n        interventionID: \"intv-control-shock-technique-keep-patient-warm\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-high-concentration-o2\",\n        interventionID: \"intv-control-shock-technique-administer-high-concentration-o2\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-place-patient-supine-position\",\n        interventionID: \"intv-control-shock-technique-place-patient-supine-position\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-iv-boluses\",\n        interventionID: \"intv-control-shock-technique-administer-iv-boluses\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-heimlich-maneuver\",\n        interventionID: \"intv-heimlich-maneuver\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-keep-body-part-cool\",\n        interventionID: \"intv-keep-body-part-cool\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-magill-forceps-assisted\",\n        interventionID: \"intv-magill-forceps-assisted\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-manual-finger-sweep\",\n        interventionID: \"intv-manual-finger-sweep\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasopharyngeal-airway\",\n        interventionID: \"intv-nasopharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-needle-cricothyrotomy\",\n        interventionID: \"intv-needle-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-occlusive-dressing\",\n        interventionID: \"intv-occlusive-dressing\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-head-tilt\",\n        interventionID: \"intv-open-airway-method-head-tilt\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-modified-jaw-thrust\",\n        interventionID: \"intv-open-airway-method-modified-jaw-thrust\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-oropharyngeal-airway\",\n        interventionID: \"intv-oropharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-orotracheal-intubation\",\n        interventionID: \"intv-orotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-body-part-in-bag\",\n        interventionID: \"intv-place-body-part-in-bag\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-immobilized-patient-on-stretcher\",\n        interventionID: \"intv-place-immobilized-patient-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-pleural-decompression\",\n        interventionID: \"intv-pleural-decompression\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-pain-nausea-vomiting-medications\",\n        interventionID: \"intv-prepare-and-administer-pain-nausea-vomiting-medications\",\n        intvCategoryID: \"intv-cat-manage-pain-nausea-vomiting\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-sedative\",\n        interventionID: \"intv-prepare-and-administer-sedative\",\n        intvCategoryID: \"intv-cat-sedate-agitated-or-combatitive-patient\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-retrieve-amputated-body-part\",\n        interventionID: \"intv-retrieve-amputated-body-part\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sedation-assisted-intubation\",\n        interventionID: \"intv-sedation-assisted-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-slat\",\n        interventionID: \"intv-slat\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-attach-cid\",\n        interventionID: \"intv-spinal-immobilization-technique-attach-cid\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-cervical-collar\",\n        interventionID: \"intv-spinal-immobilization-technique-cervical-collar\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-manual-c-spine-stabilization\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine2\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-transfer-to-device\",\n        interventionID: \"intv-spinal-immobilization-technique-transfer-to-device\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures2\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sterile-dressing-soft-tissue\",\n        interventionID: \"intv-sterile-dressing-soft-tissue\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-nasal-cannula\",\n        interventionID: \"intv-supplemental-oxygen-device-nasal-cannula\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-non-rebreather-mask\",\n        interventionID: \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-surgical-cricothyrotomy\",\n        interventionID: \"intv-surgical-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-walk-patient\",\n        interventionID: \"intv-transfers-patient-method-walk-patient\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-place-directly-on-stretcher\",\n        interventionID: \"intv-transfers-patient-method-place-directly-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport\",\n        interventionID: \"intv-transport\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport-body-part-to-receiving-facility\",\n        interventionID: \"intv-transport-body-part-to-receiving-facility\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-ventilation-technique-bag-valve-mask\",\n        interventionID: \"intv-ventilation-technique-bag-valve-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-wrap-body-part-in-saline-soaked-gauze\",\n        interventionID: \"intv-wrap-body-part-in-saline-soaked-gauze\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    }\n]\n\nexport default INTV_MENU_ITEMS","import { useEffect, useState } from \"react\"\n\nimport { Link } from \"react-router-dom\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLogs } from \"@meddbriefer/scenario-data/index\"\n\nimport { Table } from \"reactstrap\"\nconst LogList = () => {\n    const [logs, setLogs] = useState([])\n    const [logsLoaded, setLogsLoaded] = useState(false)\n\n    useEffect(\n        () => {\n            getLogs(db)\n            .then(result => {\n                setLogs(result)\n                // console.log(result)\n                setLogsLoaded(true)\n            })\n            .catch(error => console.log('error fetching logs', error))\n        },\n        []\n    )\n\n    if (!logsLoaded) {\n        return (<h4>fetching log data</h4>)\n    }\n    return (\n        <Table striped={true} borderless size=\"sm\" hover>\n            <thead>\n                <tr>\n                    <th>Label</th>\n                    <th>Scenario</th>\n                    <th>Username</th>\n                    <th>Timestamp</th>\n                </tr>\n            </thead>\n            <tbody>\n                {logs.map(log => (\n                    <tr key={log.id}>\n                        <td>{log.label}</td>\n                        <td>{log.scenario}</td>\n                        <td>{log.userName}</td>\n                        <td>{log.timestamp}</td>\n                        <td>\n                            <Link to={`/logs/${log.id}`}>Analyze</Link>&nbsp;&nbsp;&nbsp;&nbsp;\n                            <Link to={`/debriefing-feedback-logs/${log.id}`}>Review</Link>\n                        </td>\n                    </tr>\n                ))}\n            </tbody>\n        </Table>\n    )\n\n}\n\nexport default LogList","\n\n  export const colorTypes = {\n    \"Good\": \"text-success\",\n    \"Caution\": \"text-warning\",\n    \"Problem\": \"text-danger\",\n    \"Not implemented\": \"text-muted\"\n}\n\nexport const iconTypes = {\n    \"Good\": \"sentiment_satisfied\",\n    \"Caution\": \"report_problem\",\n    \"Problem\": \"highlight_off\",\n    \"Not implemented\": \"sentiment_neutral\"\n}\n\n//Feedback substitute commands for feedback template\n//@ means substitute this entry field into the feedback template and if no value in field say this in feedback, \n//? means substitute this entry field into the feedback template if the value exists,\n//+bos adds period to end sentence, two spaces and capitalizes first letter of what follows\n//+eos adds a period with no preceding spaces\n\n//assessmentEntries states are used by analyzeEvents, condition1 and condition2, but the rest is used only by condition 1\nexport const assessmentEntries = {\n    // state: [categorization for feedback, feedback template for condition 1]\n    \"contraindicated\": [\"Problem\", \"You should not have done this action because it is contraindicated in this case +bos ?contraindicatedWhy +eos\"],\n    \"missingMinimal\": [\"Problem\", \"You did not do this action, which is recommended by protocol ?protocol +bos @why +eos\"],\n    \"missingOptional\": [\"Caution\", \"You did not do this action +bos but it was optional in this case according to protocol ?protocol @bos @why +eos\"],\n    \"missingRequired\": [\"Problem\", \"You did not do this action, which is recommended by protocol ?protocol +bos @why +eos\"],\n    \"missingRequiredAssessment\": [\"Problem\", \"You did not do this action. +bos ?assessmentFB +eos\"],\n    \"notNecessary\": [\"Caution\", \"You should not have done this action because it was unnecessary +bos @why +eos\"],\n\n    //note that missing/wrong items cannot be an argument in a misordering of events so there states will not get combined with misOrdered states\n\n    //not yet implemented\n   // \"missedProblem\": [\"Problem\", \"The following should alert you to @problem: +items @problemAssessments\"],  //need to add status and fields to analysis code still and +item formatting below\n \n    \"assessment\": [\"Good\", \"\"],\n    \"assessment-option\": [\"Good\", \"\"],\n    \"decision-option\": [\"Good\", \"\"],\n    \"required-action\": [\"Good\", \"\"],\n    \"standard\": [\"Good\", \"?intvStatusFB +eos \"],\n    \n\n    \"misOrdered-assessment\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-assessment-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-decision-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-required-action\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-standard\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n\n    \"misOrdered-phase-assessment\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-assessment-option\": [\"Good\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-decision-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-phase-required-action\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-phase-standard\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n\n    //doubt that status checks can be misordered\n    \"intvCheckWNoIntvFound\": [\"Caution\", \"You didn't do this intervention so it doesn't make sense to check the status of it at this point.\"],\n    \"unexpectedPatientIntvCheck\": [\"Caution\", \"This status check is not likely to reveal any useful information.\"],  //nothing indicates a need to check that this intv worked\n    \"patientIntvCheck\": [\"Good\", \"\"], //as long as the intervention was done it is fine to request it\n    \"patientVitalCheck\": [\"Good\", \"\"],  //currently any patient vital check that is done is fine\n\n\n    \"assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],  \n    \"incorrect-answers\": [\"Problem\", \"Doing this action is correct but there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal-incorrect-answers\": [\"Problem\", \"Doing this action was correct and would solve the problem but you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do this intervention +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal\": [\"Caution\", \"Doing this action is correct and solves the problem but you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos \"],\n\n   \n    \"misOrdered-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos\"],\n        \n    \n    \"misOrdered-phase-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos\"],\n    \n    \"green\": [\"Good\", \"\"],  //just for headers\n    \"red\": [\"Problem\", \"\"], //just for headers\n    \"yellow\": [\"Caution\", \"\"], //just for headers\n    //\"notFound\": [\"Not implemented\", \"Assessment knowledge is not yet specified\", []],\n    \"default\": [\"Not implemented\", \"This action was not expected.  There could be an issue with how this scenario is represented within the system.\"]\n}\n","export const phaseStatusList = {\n    absent: [\"missingMinimal\", \"missingOptional\", \"missingRequired\", \"missingRequiredAssessment\"],\n    errors: [\"misOrdered-assessment\", \"misOrdered-assessment-option\", \"misOrdered-decision-option\", \"misOrdered-required-action\", \"misOrdered-standard\",\n    \"contraindicated\", \"intvCheckWNoIntvFound\", \"unexpectedPatientIntvCheck\", \n    \"assessment-option-incorrect\", \"decision-option-incorrect\", \"incorrect-answers\", \"minimal-incorrect-answers\", //\"minimal\", \n    \"misOrdered-assessment-option-incorrect\", \"misOrdered-decision-option-incorrect\", \"misOrdered-incorrect-answers\", \"misOrdered-minimal-incorrect-answers\",\n    \"misOrdered-minimal\", \"notNecessary\",\n    \"default\",\n    \"misOrdered-phase-assessment-option-incorrect\", \"misOrdered-phase-decision-option-incorrect\", \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\", //\"misOrdered-phase-minimal\"\n        ],\n    good: [\"assessment\", \"assessment-option\", \"decision-option\", \"required-action\", \"standard\", \n        \"patientIntvCheck\", \"patientVitalCheck\",\n        //condition 2 does not need to address minimal as an error nor misordered-phase as that error appears as misordered at the phase or subphase level\n        //condition 1 uses misOrdered-Phase as that error feedback goes on the first line in the phase/subphase\n        //so without misOrdered-phase and/or minimal, these are good status values\n        \"minimal\", \"misOrdered-phase-minimal\",\n        \"misOrdered-phase-assessment\", \"misOrdered-phase-assessment-option\", \"misOrdered-phase-decision-option\", \"misOrdered-phase-required-action\", \"misOrdered-phase-standard\",\n        ]  \n}\n\n","// defines which assessment steps are not required per scenario.  Provides feedback on\n// why the step is not required.\nexport const exceptionDefs = \n[{scenarioName: \"M2CA\", exceptions: [\n    [\"required-action-obtain-OPQRST\", \"This cannot be assessed when GCS < 15\"],\n    [\"assess-opqrst-info\", \"This cannot be assessed when GCS < 15\"]\n    ]}\n  ]\n  \n/* This starts section on defining temporal constraints, conditional constraints and implications.*/\n\n/*temporal constraints are an\nindex of event labels with two lists as values.\nThe first value is a list of event labels that the indexed event\nshould precede (if any) and the second value is a list of event\nlabels that the indexed event should follow after (if any)\n*/\n\nexport const globalConstraints = {\n    // event < list of other events, > list of other events\n    // lookup by event id to see the list of event ids that it should go before\n    // and after, and the type of constraint. \n    // included constraints type with values of policy, commonSense and both.  These may be used in future to\n    // decide any lead in to feedback about a constraint violation\n    // type policy operators are usually \"ands\", type commonsense operators are ususally \"ors\" because\n    // the ordering is looser than with policy ordering.  An operator can be blank if only one item is listed for the\n    // before or for the after.  No software should be written to expect\n    // this tendency between type and operators to hold.\n\n    //Note that: \n    //- for now the software will use either the label or id to lookup constraints but id\n    // is preferred.\n    //- a key (first item on each line) is the first arg in the constraints and is\n    //  assumed to have just one constraint applicable to\n    //  it but may appear as the second arg in a constraint multiple times (2nd args are\n    //  lists under before or after fields)\n    //- when something is a phase or subphase with multiple actions then we look for the begining\n    //  and ending actions for constraint checking.  If overlap in phases is to be allowed the constraint should\n    //  be amongst lower level items and no higher level constraint should be included\n    //= there is no check to make sure the constraints expressed do not conflict.  For example,\n    //  saying a whole phase should be before another phase and that a particular item in the second\n    //  phase can go before some other item in the first phase are in conflict with one another\n    \n    // BSI and scene size up should be completed before primary survey is begun \n    \"scene-size-up\": {id: \"T1\", before: [\"primary-survey\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    //states that primary survey in its entirety should come before the secondary assessment.  Not yet correct wrt Sandy's statement for T2\n    \"primary-survey\": {id: \"T2\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    //no intervention or assessment \"Call for air ambulance\"\n    \"Call for air ambulance\": {id: \"T3\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"required-action-obtains-vitals\": {id: \"T4\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"secondary-assessment\": {id: \"T5-6\", before: [\"intv-transfer\", \"ongoing-mgmt-plan\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"transport-decision\": {id: \"T7\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\", \"breathing\", \"circulation\"], afterOp: \"\", type: \"policy\"},\n    \"trauma-expose\": {id: \"T8\", before: [\"chest\", \"secondary-assessment\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \"general-impression\": {id: \"T9\", before: [\"airway\", \"breathing\", \"circulation\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-spinal-immobilization-technique-manual-c-spine\": {id: \"T10\", before: [\"airway\", \"breathing\", \"circulation\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    \n    \"intv-airway-patency-technique-suction-airway\": {id: \"T14\", before: [\"intv-oropharyngeal-airway\", \"intv-nasopharyngeal-airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-oropharyngeal-airway\": {id: \"T15a\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-nasopharyngeal-airway\": {id: \"T15b\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \n    //used during testing\n    //state that ongoing management plan should go after the entirety of everything listed in after\n    //\"ongoing-mgmt-plan\": {id: \"c2\", before: [ ], beforeOp: \"\", after: [\"bsi\", \"scene-size-up\", \"primary-survey\", \"history-taking\",\"secondary-assessment\"], afterOp: \"and\", type: \"commonSense\"},\n    // have two second args in below because some of Observer logs have one of these ids and some have the other\n    //\"assess-injury-mechanism\": {id: \"c7\", before: [\"required-action-consider-stabilization-of-spine\", \"required-action-considers-stabilize-spine\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"commonSense\"},\n    //\"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"c8\", before: [\"intv-control-severe-bleeding-technique-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n    //\"intv-control-severe-bleeding-technique-tourniquet\": {id: \"c9\", before: [\"intv-control-severe-bleeding-technique-2nd-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n     \n}\n\n//constraints that depend on whether certain conditions hold within a scenario\n\nexport const conditionalConstraints = {\n    // assess major bleeding first before doing any of airway and breathing (note that there is no\n    // ordering specified between circulation and airway or breathing as that would be a conflict with this\n    // constraint)\n\n    // a hold over from testing\n    \"assess-major-bleeding\": {id: \"c1\", before: [\"airway\",\"breathing\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    \n}\n\n\n// used to simulate conditional constraints, i.e. we hardcode which condition constraints are relevant\n// to each scenario\nexport const scenarioConstraintIDs = {\n    \"M2CA\": [\"c1\"],\n    \"B4CA\": [],\n    \"B7CA\": [],\n    \"SC8CP\": [],\n    //\"\": [],\n    //\"\": []\n}\n\n\n//below are examples of interventions in which status should be checked.  The key intvStatusNeeded\n//is true or false.  If true it means should have requested status of this intervention.  If vitals key is\n//not empty then should have checked all of these vitals as well.  Will only check entries after an intervention\n//up until something other than an intervention check is done\n\n//updates wrt SC8CP-combined-goals-4-4\nexport const intvChecks = {\n    \"intv-nasopharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-oropharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-orotracheal-intubation\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-ventilation-technique-bag-valve-mask\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\" ]},\n    \"intv-sedation-assisted-intubation\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\"]},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},\n    //test cases for now.  First 3 are likely to become relevant for scenarios like M2CA\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []}, \n    //\"intv-control-shock-technique-administer-iv-boluses\": {intvStatusNeeded: false, vitalsNeeded: [\"BP\"]},\n        \n    }\n\n","import { formatAsMinSecs } from \"../utils\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport {colorTypes, iconTypes, assessmentEntries, phaseStatusList} from \"@meddbriefer/feedback-data\"\nimport { scenarioConstraintIDs, conditionalConstraints, globalConstraints } from \"@meddbriefer/feedback-data\"\n   \nexport const pushNew = (elt,array) => {\n    if (!array.includes(elt)) {\n        array.push(elt)\n    }\n}\n\nexport const getPhaseStatus = (statuses) => {\n    //for collecting first unique item statuses and then\n    //unique phase statuses\n    let itemStatuses = []\n    let phaseStatuses = []\n\n    //get a unique list of item status values\n    statuses.forEach(status => {\n        pushNew(status,itemStatuses)\n        /* if (!itemStatuses.includes(status)){\n            itemStatuses.push(status)\n        } */\n    })\n    \n    //turn the item status values into phase level status values\n    let res\n    for (const [key, val] of Object.entries(phaseStatusList)) {\n        res = val.filter(value => itemStatuses.includes(value))\n        //if there is an intersection, save the key (i.e. is unique)\n        if (res.length !== 0)\n            pushNew(key,phaseStatuses)\n            /* if (!phaseStatuses.includes(key)){\n                phaseStatuses.push(key)} */\n        }\n\n    if (phaseStatuses.length === 1){return phaseStatuses[0]}  // to be absent or good, all entries must be good or absent\n    else {return \"errors\"}  //otherwise they are not all good to that translates to errors\n       \n    }\n\n\n\n// functions that extract info from above or create the feedback from the above \n\n//returns a list of all the state values associated with the input status (e.g. status is one of \"Problem\", \"Good\", \"Caution\")\nexport const getStatesForStatus = (status) => {\n    let stateList = []\n    for (const [state, entry] of Object.entries(assessmentEntries)) {\n        let stateStatus = entry[0]\n        if (stateStatus === status){\n            stateList.push(state)}\n        }\n    //console.log(\"In getStatesForStatus\", stateList)\n    return (stateList)}\n        \n\n//returns the entry under that state\nconst getAssessmentEntry = (currentEntry,aIndex) => {\n    let assessmentEntry = \"\"\n    if (currentEntry.type === \"header\"){\n        assessmentEntry = assessmentEntries[currentEntry.displayColor] \n        if (!assessmentEntry) {assessmentEntry = assessmentEntries[currentEntry.status]}\n    }\n    else{\n        if (!assessmentEntries[currentEntry.status]){\n            assessmentEntry = assessmentEntries[\"default\"]}\n        else{assessmentEntry = assessmentEntries[currentEntry.status]}}\n    if (assessmentEntry){\n        return assessmentEntry[aIndex]}\n}\n\n//returns the html icon to use in condition 1 for the state\nexport const getAssessmentIcon = (currentEntry) => {  \n    let val = iconTypes[getAssessmentEntry(currentEntry,0)]\n    return val;\n}\n\n//returns the html color to use in condition 1 for the state\nexport const getColor = (currentEntry) => {\n    return colorTypes[getAssessmentEntry(currentEntry,0)];\n}\n\n//add protexted spaces after a . except for the very last .  \n//Otherwise html reduces continguous regular spaces to a single space.\n//Need this for text strings that will appear in one array entry because\n//of substitution\nconst fixStrSp = (textString) => {\n    if (!!textString){\n        let textArray = textString.split(\" \");\n        let lenTextArray = textArray.length;\n        textArray.forEach((item, i) => {\n            let newItem = item.trim()\n            if (newItem[item.length-1] === \".\" && i < lenTextArray-1){\n                //add protected space to the string\n                newItem = newItem + \"\\xa0\\xa0\"}\n            textArray[i] = newItem \n        })\n        let newString\n        for (let item of textArray){\n            if (!!newString){\n            newString = newString + \" \" + item;}\n            else{newString = item}\n\n     }\n        //console.log(newString, textArray)\n        return newString}\n    else {return \"\"}\n}\n\nconst generateIntvStatusFB = (currentEntry) => {\n    let checked = []\n    let notChecked = []\n    let fb\n    for (let entry of currentEntry.intvStatus){\n        if (entry.foundCk){\n            checked.push(entry.label)}\n        else {notChecked.push(entry.label)}\n    }\n    if (notChecked.length > 0){\n        fb = \"Remember to check the effect of this action by asking for: \" + notChecked + \".\"\n        if (checked.length > 0){\n            fb = fb + \" That is in addition to what you did ask for: \" + checked + \".\"\n        }\n    }\n    return fb\n}\n\n\n\n\nexport const getFeedback = (currentEntry) => {\n    if (!!currentEntry.intvStatus && currentEntry.intvStatus.length > 0){\n        //add our generated feedback string to the currentEntry\n        currentEntry.intvStatusFB = generateIntvStatusFB(currentEntry)\n    }\n    let feedbackTemplate = fixStrSp(getAssessmentEntry(currentEntry,1)).trim()\n    //Find any @ actions in the template and substitute with the indicated entry field\n    let feedbackArray = feedbackTemplate.split(\" \");\n    //Process all @ substitutions first since +eos does one forward action\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let newString = item.substring(1)\n        //trim off excess blanks before and after each word\n        feedbackArray[i] = feedbackArray[i].trim()\n        switch(firstChar){\n            case \"@\":\n                if (!!currentEntry[newString])\n                    //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"[value for \" + newString + \" is missing]\" }\n                break\n            case \"?\":\n                if (!!currentEntry[newString])\n                //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"\"  \n                    if (feedbackArray[i-1]  === \"+bos\"){feedbackArray[i-1] = \"\"}\n                    if (feedbackArray[i+1]  === \"+eos\"){feedbackArray[i+1] = \"\"}\n                }\n                break  \n            default:\n        }\n    })\n    //Now address the + actions in the template\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let previousString = \"\"\n        switch(firstChar){\n        case \"+\":\n            let afterPlusChar = item.substring(1)\n            switch(afterPlusChar){\n            case \"eos\":\n                //removes existing/redundant . if present so can be certain putting in single . \n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence and a protected space.  When stiched back into\n                //a single string a protected space will be added between each substring\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\"  //get rid of the command since was applied\n                break\n            case \"bos\":\n                //removes existing/redundant . if present so can put in single .\n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence .\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\" //get rid of the command since was applied\n                //Captitalize the beginning of the sentence\n                let nextString = feedbackArray[i+1].trim()\n                feedbackArray[i+1] = nextString.charAt(0).toUpperCase() + nextString.slice(1);\n                break\n            default:\n            }\n            break\n        default:\n    }}\n    )\n    //stitch back into a single string\n    let feedbackString\n    for (let item of feedbackArray){\n        if (!!feedbackString) {\n            if (item !== \"\"){\n                feedbackString = feedbackString + \"\\xa0\" + item;}} \n        else {if (item !== \"\"){feedbackString = item}}\n    }\n    //console.log(feedbackString)\n    return feedbackString\n}\n\n//built by the function initializeConstraints\nvar scenarioConstraints = {}\n\n// adds on scenario specific constraints where the constraint is only applicable if certain patient\n// conditions hold.  Since assessment callouts are text and have no associated representation, we\n// can yet implement true conditional constraints.\nexport const initializeConstraints = (scenarioName) => {\n    // look up applicable conditional constraints from const structure scenarioConstraintIDs \n    let constraintIDs = scenarioConstraintIDs[scenarioName] \n    scenarioConstraints = globalConstraints\n    for (const [key, val] of Object.entries(conditionalConstraints)) {\n            if (constraintIDs.includes(val.id)){\n                scenarioConstraints[key] = val\n            }\n        }\n}\n\n\n\n//gets one constraint since each id/label would be a key\n//in the constraints definitions\nexport const getConstraint = (item) => {\n    let id = item.id\n    let label = item.label\n    let constraints = scenarioConstraints[id] \n    if (!constraints){constraints = scenarioConstraints[label]}\n    return constraints \n}\n\n\n// This section is for looking up items in the analysis log\n\nexport const getEvents = (events,field,val) => {\n    return events.filter(entry => entry[field] === val)\n}\n\nexport const getEventsByIdTime = (events,id,timestamp) => {\n    return getEvents(getEvents(events,\"timestamp\",timestamp),\"id\",id)\n}\n\n// This ends the section for looking up items in the analysis log\n\n\n\n//This starts section for saving/loading the debriefing log\n    \nconst _ = require(\"lodash\"); \n\nexport const saveAnalysisLog = (log, actions, hierAssessResults, hierProblemResults, constraintsViolated) => {\n    console.log(\"In savingDebriefingLog\")\n    const docRef = db.collection(\"debriefing-feedback-logs\").doc(log.id)\n    let data = {\n        userName: log.userName,\n        ObserverFileCreater: log.userName,\n        label: log.label,\n        ObserverFileName: log.label,\n        commenter: \"\",\n        scenarioID: log.scenarioID,\n        scenarioName: log.scenarioName,\n        schemaVersion: log.schemaVersion,\n        timestamp: Date().toLocaleString(),\n        hierAssessResults: hierAssessResults,\n        hierProblemResults: hierProblemResults,\n        constraintsViolated: constraintsViolated\n    }\n\n    let newActionsList = [];\n    let newObj = {};\n    let filterUnknown = false;\n\n    //included for debugging puposes only\n    actions.forEach(function (logObj, index){\n        for (let [key, val] of Object.entries(logObj)) {\n            if (undefined === val) {\n                console.log(\"filtered out from events; index: \", index, \" key: \", key, \" value: \", val)\n                filterUnknown = true;}\n             }\n        }\n    )\n        \n    if (filterUnknown) {\n        actions.forEach(function (logObj, index) {\n            newObj = _.pickBy(logObj, function (value, key) {\n                return !(value === undefined);\n            });\n            newActionsList.push(newObj)\n        })\n        data[\"events\"] = newActionsList\n    }\n    else (data[\"events\"] = actions);\n\n\n    //data[\"events\"] = formattedActions;\n    //console.log(JSON.stringify(data, null, 4))\n    docRef.set(data) \n}\n\n//not in use\n\nexport const retrieveDebriefing = (log) => { \n    //console.log(log.events) \n    return (log.events)  \n}  \n\n//This ends section for saving/loading the debriefing log\n\n\n\nexport const getTimestamp = (currentEntry) => {\n    if (currentEntry.status === \"criticalActionHeader\") {\n        return \"\";\n    }\n    if (currentEntry.timestamp === -1) {\n        return \"\\xa0\\xa0\";  // formatAsMinSecs would convert this to 59:59\n    }\n    return formatAsMinSecs(currentEntry.timestamp);\n}\n\n\n","import { MDB_TYPES, ANALYSIS_TYPES } from '@meddbriefer/scenario-data/constants.js';\nimport { getPhaseStatus, initializeConstraints, getConstraint, getStatesForStatus, saveAnalysisLog, getEventsByIdTime} from \"./debriefingUtils\"\nimport { intvChecks, exceptionDefs } from \"@meddbriefer/feedback-data/analysisData\"\nimport { getChecklistItemsByType, getChecklistHierarchy, groupByKey } from './scenarioDataAccesors';\nimport { summarizeAnalysis } from './summarizeAnalysis';\n//import { foo } from \"@meddbriefer/feedback-data\"\n\n//console.log(foo())\n\nconst problemStates = getStatesForStatus(\"Problem\")\nconst cautionStates = getStatesForStatus(\"Caution\")\nlet hierAssessResults = {}\nlet hierProblemResults = {}\nlet constraintsViolated = []\nlet insertInterventionHeader = false  //setting to true helps during debugging analysis, shows headers for problems\n//index of subphase names and value is phase id to which belongs\nlet subPhases = {}\n// list of all subphase IDs\nlet requiredSubphases\nlet requiredPhaseNames\nlet requiredPhaseAndSubPhases\nlet scenario\nexport var itemByID\nexport var itemByLabel\n// sts 1/23/22 - added as global\nlet checklistHierarchy\n\nfunction initGlobals(scen) {\n    scenario = scen\n    initializeConstraints(scen.name)\n    itemByID = initializeItemLookupByID(scen)\n    itemByLabel = initializeItemLookupByLabel(scen)\n    requiredPhaseNames = getChecklistItemsByType(scen, MDB_TYPES.PHASE).map(e => e.id).concat([\"Unknown\"])\n    requiredSubphases = getChecklistItemsByType(scen, MDB_TYPES.SUB_PHASE).map(e => e.id)\n    checklistHierarchy = getChecklistHierarchy(scen)\n    requiredPhaseAndSubPhases = findPhaseSubphasesOrdered(checklistHierarchy)\n    checklistHierarchy.forEach(ph => {\n        if (undefined === ph.subPhases) {\n            subPhases[ph.id] = ph.label} \n        else {\n            ph.subPhases.forEach(sp => {\n                subPhases[sp.id] = ph.label})}})\n    subPhases[\"Unknown\"] = \"Unknown\"\n}\n\n//This starts section for accessing checklist and intervention components by id or label\nconst initializeItemLookupByID = (scenario) => {\n    let checklistLookupByID = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let intvLookupByID = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let result = Object.assign(checklistLookupByID, intvLookupByID)\n    return result}\n\nconst initializeItemLookupByLabel = (scenario) => {\n        let checklistLookupByLabel = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let intvLookupByLabel = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let result = Object.assign(checklistLookupByLabel, intvLookupByLabel)\n        return result}\n\n\nconst findPhaseSubphasesOrdered = (phases) => {\n    let result = []\n    phases.forEach(ph => {\n        if (!!ph.subPhases){\n            let subPhIds = ph.subPhases.map(e => e.id)\n            //not currently useful to collect parent phases unless there were no subphases\n            //if parent phase included subphases and steps then it should be in this result\n            //result = result.concat(ph.id)\n            result = result.concat(subPhIds)\n        }\n        else {result = result.concat(ph.id)}})\n    return result\n}\n\nconst collectScenAssessments = (problems) => {\n    let assessments = []\n    problems.forEach(prob => {\n        if (prob.assessments !== \"\"){\n            assessments = assessments.concat(prob.assessments)}})\n    return assessments\n}\n\n//will need to update to comply with any relevant constraints on phases and subphases\n//currently looks for missing phases/subphases and inserts them into the analysis list\n//based on where last preceding phase appeared\nconst insertMissingSubphases = (phases,phaseNames) => {\n    let priorPh\n    requiredPhaseAndSubPhases.forEach((phase, i) => {\n        if (!phaseNames.includes(phase)) {\n            //find last index for phase before and splice after that    \n            if (i === 0){\n                priorPh = requiredPhaseAndSubPhases[0]\n            }\n            else {priorPh = requiredPhaseAndSubPhases[i-1]}\n\n            let insertionIndex = 0\n            if (priorPh !== phase){\n                insertionIndex = phaseNames.lastIndexOf(priorPh)  //if prior phase was missing it will have been inserted earlier\n                insertionIndex = insertionIndex + 1}\n            \n            phaseNames.splice(insertionIndex, 0, phase); //insert it where it should have appeared\n            phases.splice(insertionIndex, 0, []); //add the empty array for phase objects\n        }});\n    return[phases,phaseNames]\n}\n\n\n//as vital requests and intervention requests are made, update that it was requested\n//if it is one that we are tracking for post intervention success.  \nconst updateVital = (vitalEntries, timestamp) => {\n    let updatedEntries = []\n    vitalEntries.forEach(vitalEntry => {\n        if (vitalEntry.timestamp < timestamp){\n            vitalEntry[\"foundCk\"] = true}\n        updatedEntries.push(vitalEntry)\n    })\nreturn updatedEntries\n}\n\n//initial review of observer log to add annotations to what was found in the observer log.  Filters out things not useful to\n//analysis or is not yet being analyzed in the codep.  It also\n// pulls together interventions and prompt answers into one event and adds fields to each event that will fill in in later analysis,\n// fills in problem information for interventions found in observer log and\n// sets up the phases and phaseNames structures for events in the observation log and initiates\n// record of what have encountered so far in the observations in order to recognize what is missing in later stages of analysis\nconst annotateInputEvents = (events,problems) => {\n    let confirmedEvents = [];\n    let interventionsConfirmed = [];  //needed for vital checking\n    //instead of a multi-dimensional array, am using an array of phase and subphase names e.g. \"BSI\", \"prinary\" ...\n    let phaseNames = [];\n    let phases = []; //and another array with the actual content for each phase.  I can search phaseNames for the index into phases\n    let phaseObjects = [];\n    let trackForStatus = {};  //save correct interventions that were done that require status checks later\n    \n\n    // phases entry of that name and then use that index to retrieve the appropriate phase entried to\n    //add on the missing items (assessment or intervention) for that phase\n    let priorPhase = \"\";\n    let parentPhase = \"\"\n    let parentIndex = 0\n    let phaseIndex = 0;\n    let newPhaseStart = true\n    let assessmentTypes = [\"assessment\", \"required-action\", \"decision-option\", \"assessment-option\"]\n\n    // created annotated object for each event\n    events.forEach((event, i) => {\n        // Each eventObj is one of the lines in the displayed base log\n        // Set up fields for extra annotations for this event after analyzing each event\n        let eventObj = {\n            \"comment\": \"\",\n            \"numericalID\": i,\n            \"status\": \"\",\n            \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n            \"contraindicatedWhy\": \"\",\n            \"minimalWhy\": \"\",\n            \"why\": \"\",\n            \"answerCorrect\": true,\n            \"answerDetails\": {},\n            \"expertPhase\": \"\",  //filled in only for interventions\n            \"workingPhase\": \"\",  //is subphase of phase if there is no subphase\n            \"suggestedPhase\": \"\", //mostly for interventions so don't override info on when was originally done\n            \"protocol\": \"\",\n            \"probLabel\": \"\",\n            \"assessments\": \"\",\n            \"required\": false,\n            \"actionDescription\": \"\",\n            \"assessmentFB\": \"\",\n            \"incorrectAnswersFB\": \"\",\n            \"orderingFB\": \"\",\n            \"processingState\": \"good\" // values of good/bad used to filter out events not needed for analysis or displaying\n        };\n\n        // copy over the event fields that exist in the input log from observer UI (which is type dependent)\n        const EVENT_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"vitalType\", \"vital\", \"value\", \"type\", \"prompt\", \"promptID\", \"intervention\", \"timestamp\"];\n        EVENT_FIELDS.forEach(fldName => {\n            if (!!event[fldName]) {\n                eventObj[fldName] = event[fldName];\n            }\n        });\n\n        //copy event fields if defined to initialize some of the above annotation fields\n        if (!!event.label) { eventObj.actionDescription = event.label; }\n        if (!!event.type) { eventObj.status = event.type; }\n        // prefer subPhase if available\n        if (!!event.subPhase) { eventObj.workingPhase = event.subPhase; }\n        else {\n            if (!!event.phase) { eventObj.workingPhase = event.phase; }}\n        eventObj.expertPhase = eventObj.workingPhase;\n\n        //if current phase same as prior then keep on with the current phase\n        // otherwise initialize for a new phase but don' let an intervention\n        // or intervention answer set a new phase since this info in event is\n        // not reliable  \n            \n        if (priorPhase !== eventObj.workingPhase || parentPhase !== eventObj.phase){ \n            if (priorPhase !== \"\" && assessmentTypes.includes(eventObj.type)) {  \n                //have a non initial phase change and we have an assessment type (i.e. we can't base phase changes on interventions)\n                newPhaseStart = true\n                phases[phaseIndex] = phaseObjects;\n                if (phaseIndex !== parentIndex){\n                    phases[parentIndex] = phases[parentIndex].concat(phaseObjects);  \n                }\n                phaseIndex++\n                \n                //if upcoming parent phase is different than current parent phase then set up\n                //for a new parent phase\n                if (eventObj.phase !== parentPhase){ \n                    parentPhase = eventObj.phase\n                    parentIndex = phaseIndex\n                    // if the upcoming is truly a parent with subphases \n                    // then add an extra entry for the new parent phase \n                    if (eventObj.phase !== eventObj.workingPhase) {\n                        //create the new parent phase\n                        phases[parentIndex] = []\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++\n                    }}}\n            else {\n                if (priorPhase === \"\" && assessmentTypes.includes(eventObj.type)){\n                // first item in events so initialize\n                    parentPhase = eventObj.phase\n                    // if the event parent phase is not the same as the subPhase\n                    // then we need to save that parent phase in phases and phaseNames\n                    if (parentPhase !== eventObj.workingPhase) {\n                        parentPhase = eventObj.phase\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++;}}\n                \n                else{ \n                    if (priorPhase === \"\"){\n                        //did an intervention before doing any assessments\n                        //so make up an initial phase of unknown\n                        parentPhase = \"Unknown\"\n                        eventObj.workingPhase = parentPhase\n                        eventObj.phase = parentPhase\n                        eventObj.subPhase = \"\" }\n                    else {newPhaseStart = false}}}\n\n                \n            \n            //now setup for collecting for the current phase if not skipping new phase start\n            if(newPhaseStart){\n                priorPhase = eventObj.workingPhase;\n                phaseObjects = [];\n                phaseNames[phaseIndex] = priorPhase;\n                phases[phaseIndex] = []}\n            else {newPhaseStart = true}\n            }\n        \n\n        let eventType = eventObj.type;\n        // List of types in log that are currently processed.  Rest are filtered out.\n        let processedTypes = [\"assessment\", \"required-action\", \"intervention\", \"answer\", \"obtain-vital-sign\", \"decision-option\", \"assessment-option\"];\n\n        //skip over adding anything not of these types to the debriefing display for now\n        if (!processedTypes.includes(eventType)) {\n            eventObj.processingState = \"bad\";\n        }\n\n        // when get an answer for an intervention prompt, grade the response.  The intervention itself is later in the event log, so\n        // accumulate the answers and grading and then when an intervention is later found we can use the intervention\n        // event itself and move all the answer results into it\n        let prioreventObj = [];\n        if (eventType === \"answer\") {\n            //make sure we have answer info for this promptID\n            let correctAnswerLabel = getCorrectAnswerLabel(event.promptID, true);\n            let givenAnswerLabel = getAnswerLabel(event.id, true);\n            //if we don't have answer info for this prompt ID then just ignore this entry\n            if (!correctAnswerLabel) {\n                eventObj.processingState = \"bad\"}\n            else {\n                //currently returns correct answer-id if has answered incorrectly or false if answered correctly\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, true);\n                //store details of this answer and its grading\n                let answerDetails = {\"correctAnswer\": correctAnswerLabel, \"givenAnswer\": givenAnswerLabel, \"correct\": !wrongAnswer}\n                \n                //have answer to prior question for this intervention \n                //(i.e. there is more than one question associated with this intervention)\n                if (confirmedEvents.includes(eventObj.intervention)) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    //add the answer student gave to the action description\n                    eventObj.actionDescription = prioreventObj.actionDescription + \", \" + givenAnswerLabel;\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        if (prioreventObj.incorrectAnswersFB === \"\") {\n                            eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                            }\n                        else {eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB + \", and \" + correctAnswerLabel;\n                            }}\n                    else {\n                        eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                        eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    }}\n                //first answer for this intervention\n                else { \n                    //put the answer student gave in the action description\n                    //responding to first question for the intervention\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                    }\n                    else { eventObj.incorrectAnswersFB = \"\"; }\n                    //pushNew(eventObj.intervention,confirmedEvents)\n                    confirmedEvents.push(eventObj.intervention)\n                }\n                //storing the prompt/answer details \n                eventObj.answerDetails[event.promptID] = answerDetails}}\n\n        if (eventType === \"intervention\") {\n            prioreventObj = phaseObjects.slice(-1)[0]; //slice returns an array rather than the last object in array\n            //check to find if prior phaseObjects contains an answer and if it does then consolidate that answer\n            //event into the associated intervention\n            if (prioreventObj && prioreventObj.type === \"answer\"){\n                if (prioreventObj.intervention === eventObj.id) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                    eventObj.actionDescription = eventObj.actionDescription + \".\\xa0\\xa0\" + prioreventObj.actionDescription}\n                else {\n                    prioreventObj = phaseObjects.pop();  //discard this answer, it is for an intervention that was not done\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                 }}\n        }\n\n        if (eventObj.processingState === \"good\") {\n\n            if (eventObj.type === \"obtain-vital-sign\"){\n                //if it is an intervention status check then the vital field contains\n                //the intervention id and otherwise the vital label\n                let vital = eventObj.vital \n                let type = \"\"\n                if (eventObj.vitalType === \"intervention-status\"){\n                    if (interventionsConfirmed.includes(vital)){\n                        type = \"intv\"}\n                    else {type = \"noIntv\"}\n                    }\n                else {type = \"vital\"}\n                \n                //update trackForStatus relative to this \"vital\"\n                let vitalEntry = trackForStatus[vital]  \n                //set the status for this particular vital (i.e. makes sense to ask for it or not)\n                switch (type){\n                    case \"intv\": \n                        eventObj.status = \"patientIntvCheck\"\n                        if (vitalEntry && (vitalEntry.timestamp < eventObj.timestamp)){\n                            vitalEntry[\"foundCk\"] = true\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    case \"noIntv\":\n                        eventObj.status = \"intvCheckWNoIntvFound\"\n                        break\n                    case \"vital\":\n                        eventObj.status = \"patientVitalCheck\" \n                        if (vitalEntry){\n                            vitalEntry = updateVital(vitalEntry,eventObj.timestamp)\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    default: eventObj.status = \"unexpectedPatientIntvCheck\"}\n\n\n                    \n            }\n            // add additional annotations per type\n            if (eventObj.type === \"intervention\") {\n                // iterate through all problem actions looking how to format the\n                // data structue for the current \"event\"\n                problems.forEach((prob, j) => {\n                    // We're going through things in the order standard, contraindicated since\n                    // it is possible but unlikely to have multiple matches and we want the last one to win.\n                    // Also, we are assuming minimal is always a subset of standard\n                    const PROBLEM_ACTION_FIELDS = [\"why\", \"probLabel\"];\n                    \n\n                    // check for this action to be an intervention for a problem\n                    prob.actions?.forEach((action, k) => {\n                        if (action.id === eventObj.id) {\n                            //see if this is an event whose status should be checked by the student\n                            //and initialize its tracking.  Not yet limiting to event id when\n                            //defining what needs to be tracked in the structure intvChecks\n                            //so also checking event label\n                            let statusChecking  //the entry retrieve from intvChecks\n                            let intv = eventObj.id\n                            statusChecking = intvChecks[eventObj.label]\n                            if (!statusChecking){\n                                statusChecking = intvChecks[eventObj.id]}\n\n                            if (!!statusChecking){\n                                let initialEntry = {\"intervention\": intv, \"timestamp\": eventObj.timestamp, \"foundCk\": false}\n                                //put the intervention on the list if there is a direct status check possible for it\n                                if (statusChecking.intvStatusNeeded){\n                                    trackForStatus[intv] = Object.assign({}, initialEntry)}\n                                //if any vitals are listed for this intervention as a way of checking its status then\n                                //put those on the statusChecking list.  Anytime a vital is checked after the timestamp\n                                //it will count towards checking the status of the intervention\n                                statusChecking.vitalsNeeded.forEach(vital => {\n                                    if (!trackForStatus[vital]){trackForStatus[vital] = [Object.assign({}, initialEntry)]}\n                                    else {trackForStatus[vital].push(Object.assign({}, initialEntry))}})}\n                                \n                            // fill out problem related fields in the action event\n                            if (!!action.assessments) {eventObj.assessmentsNeeded = action.assessments}\n                            if (!!action.phase) {eventObj.when = action.phase};\n                            if (!action.optional) { eventObj.required = true};\n                            if (!!prob.protocols) {eventObj.protocol = prob.protocols}\n                            if (eventObj.answerCorrect) {\n                                eventObj.status = \"standard\";}\n                            else { eventObj.status = \"incorrect-answers\"; }\n                            if (!!action.phase) {eventObj.suggestedPhase = action.phase};\n                            eventObj.probLabel = prob.probLabel;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!action[fldName]) {\n                                    eventObj[fldName] = action[fldName];\n                                }});\n                            if (!!action[\"id-label\"]) { eventObj[\"label\"] = action[\"id-label\"]; }  //dealing with residual name changes\n                        }});\n\n                    // check for this action to be a contraindication for a problem solution\n                    prob.contraindications?.forEach((contra, j) => {\n                        if (contra.id === eventObj.id) {\n                            eventObj.status = \"contraindicated\";\n                            if (!!contra.why) { eventObj.contraindicatedWhy = contra.why; }\n                            if (!!contra[\"id-label\"]) { eventObj.label = contra[\"id-label\"]; }\n                            if (!!contra.protocol) { eventObj.protocol = contra.protocol; }\n                            if (!!prob.probLabel) { eventObj.probLabel = prob.probLabel; }\n                        }}) \n                    })}\n\n            if (eventObj.type === \"decision-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"decision-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n\n            if (eventObj.type === \"assessment-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"assessment-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n            // add the formatted object to our list of formatted objects for the current phase and the id to our set of confirmed ids\n            if (eventObj.type === \"intervention\"){\n                confirmedEvents.push(eventObj.id + \"+\" + eventObj.probLabel)\n                interventionsConfirmed.push(eventObj.id)\n            }\n            else {confirmedEvents.push(eventObj.id)}\n            phaseObjects.push(eventObj)}});\n\n    // store the last phase processed\n    phases[phaseIndex] = phaseObjects;\n    if (phaseIndex !== parentIndex){\n        phases[parentIndex] = (phases[parentIndex]).concat(phaseObjects)};\n    return [phases,phaseNames,confirmedEvents,trackForStatus]\n}\n\n//start support functions for constraint checking\n\nconst findNameNumID = (names, entries, item, occurrence) => {\n    let result = undefined\n    let index = undefined\n    for (let i = 0; i < names.length; i++) {\n        if (item.id === names[i]) {\n            result = entries[i]\n            if (occurrence === \"start\") {\n                break}}}\n    if (!!result) {\n        if (result.numericalID === -1) {\n            if (occurrence === \"start\") {\n                index = result.numericalIDStart}\n            else { index = result.numericalIDEnd }}\n        else { index = result.numericalID }}\n\n    return index\n}\n\nlet unknownItem = {id: \"Unknown\", label: \"Unknown\"}\n\nconst getItem = (val) => {\n    if (val === \"Unknown\"){return unknownItem}\n    let item = itemByID[val]\n    if (!item){\n        item = itemByLabel[val]}\n    if (item){return item[0]}\n}\n\nconst findObjByNumerialID = (numericalID,phases,phaseNames) => {\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            for (let entry of phaseObjects){\n                if (entry.numericalID === numericalID){\n                    return entry}\n            }}}}\n\n\nconst storeMisOrderedFB = (numericalID, arg2, FB, constraintType, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (!objToModify.arg2){\n            objToModify.arg2 = [arg2.id]}\n        else {objToModify.arg2 = objToModify.arg2.concat([arg2.id])}\n        if (objToModify.orderingFB !== \"\") {\n            objToModify.orderingFB = objToModify.orderingFB + \".\\xa0\\xa0\" + FB}\n        else { objToModify.orderingFB = FB }\n        let status\n        if (!(objToModify.status.includes(\"misOrdered\"))){\n            let appendString = \"misOrdered-phase-\"\n            if (constraintType === \"item\"){\n                appendString = \"misOrdered-\"}\n            status = appendString + objToModify.status \n            objToModify.status = status}}\n}\n\n\n//flattens out the phases and phaseNames data structures so that all phase and subphase\n//names have their own entry and each item under a phase or subphase has its own entry.\n//Collect and return unique names because phase and subphase names can appear multiple times in the \n//phases and phaseNames ds.  Having a unique list of names means that a constraint will only be checked once.\n\n\nconst collectEntriesToCheckConstraints = (phases, phaseNames) => {\n    let listOfNames = []\n    let listOfEntries = []\n    let uniqueListOfNames = []\n    let counter = -1\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let startIndex = phaseObjects[0].numericalID\n        let endIndex = phaseObjects[phaseObjects.length-1].numericalID\n\n        //handle phases and subphases first\n    \n        if (requiredPhaseNames.includes(phaseName) || requiredSubphases.includes(phaseName)) {\n            listOfEntries.push({ id: phaseName, numericalID: counter, numericalIDStart: startIndex, numericalIDEnd: endIndex })\n            listOfNames.push(phaseName)\n            if (!uniqueListOfNames.includes(phaseName)){uniqueListOfNames.push(phaseName)}}\n\n        //can't be an else to above because a phase can have entries but a subphase cannot\n        \n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            let phaseObjectNames = phaseObjects.map(obj => obj.id)\n            listOfEntries = listOfEntries.concat(phaseObjects)\n            uniqueListOfNames = uniqueListOfNames.concat(phaseObjectNames)\n            listOfNames = listOfNames.concat(phaseObjectNames)\n        }\n    }\nreturn [listOfNames, uniqueListOfNames, listOfEntries]\n\n}\n\nconst saveFailedConstraint = (lateArg, otherArg, constraintType, constraintID) => {\n    if (constraintType === \"phase\"){\n        constraintsViolated.push({constraintID: constraintID, arg1: lateArg, op: \"before\", arg2: otherArg}) }\n}\n\nconst checkAgainst2ndArgs = (arg1st,args2nd,op,direction,constraintID,entryNames,entries,phases,phaseNames) => {\n    let endNum1st = findNameNumID(entryNames, entries, arg1st, \"end\")\n    let startNum1st = findNameNumID(entryNames, entries, arg1st, \"start\")\n    let label1st = arg1st.label\n    let parPhFB = \"\"\n    if (args2nd.length > 0) {\n        for (let arg of args2nd) {\n            let arg2nd = getItem(arg)\n            if (!!arg2nd) {\n                let label2nd = arg2nd[\"label\"]\n                let startNum2nd = findNameNumID(entryNames, entries, arg2nd, \"start\")\n                let endNum2nd = findNameNumID(entryNames, entries, arg2nd, \"end\")\n                let constraintType = \"item\"\n                switch (direction){\n                case \"before\":\n                    if (!!endNum1st && !!startNum2nd) {\n                        if (!(endNum1st < startNum2nd)) {  //if failed constraint i.e. arg1 is late\n                            if (startNum1st === endNum1st) {\n                                //feedback for nonphase\n                                parPhFB = \"You should have done \" + label1st} \n                            //feedback for phase\n                            else { parPhFB = \"You should have completed \" + label1st \n                                   constraintType = \"phase\"}  \n                            if (startNum2nd === endNum2nd) {\n                                    parPhFB = parPhFB + \" before you did \" + label2nd} //feedback for nonphase\n                            else { parPhFB = parPhFB + \" before starting \" + label2nd } //feedback for phase\n                            storeMisOrderedFB(startNum1st, arg2nd, parPhFB, constraintType, phases, phaseNames)\n                            saveFailedConstraint(arg1st, arg2nd, constraintType, constraintID)\n                        }\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                case \"after\":\n                    if (!!startNum1st && !!endNum2nd) {\n                        if (!(startNum1st > endNum2nd)) { //if failed constraint  i.e. arg2 is late\n                            if (startNum1st === endNum1st){\n                                //feedback for nonphase\n                                parPhFB = \"You should have done \" + label2nd} \n                            //feedback for phase \n                            else{parPhFB = \"You should have completed \" + label2nd\n                                constraintType = \"phase\"}  \n                            if (startNum2nd === endNum2nd){\n                                parPhFB = parPhFB + \" before you did \" + label1st}\n                            else {parPhFB = parPhFB + \" before starting \" + label1st} //feedback for nonphase\n                            storeMisOrderedFB(startNum2nd, arg1st, parPhFB, constraintType, phases, phaseNames)   //feedback for phase\n                            saveFailedConstraint(arg2nd, arg1st, constraintType, constraintID)}\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                default: break}}}}\n\n\n}\n\n\n\nconst checkConstraintsForArg = (arg1st, constraint, phases, phaseNames, entryNames, entries) => {\n    \n    let args2nd = constraint.before\n    let op = constraint.beforeOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"before\",constraint.id,entryNames,entries,phases,phaseNames)\n\n    args2nd = constraint.after\n    op = constraint.afterOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"after\",constraint.id,entryNames,entries,phases,phaseNames)}\n    \n    \n  //end support functions for constraint checking              \n                        \n\n\n//To DO: filter constraints in/out based on findings available for this scenario\n\n//main function for constraint checking \nconst checkAgainstKB = (phases, phaseNames) => {\n\n    let result = collectEntriesToCheckConstraints(phases, phaseNames)\n    let entryNames = result[0]\n    let uniqueEntryNames = result[1]\n    let entries = result[2]\n    uniqueEntryNames.forEach(firstArg => {\n        let firstArgItem = getItem(firstArg)\n        if (!!firstArgItem) {        \n            let constraint = getConstraint(firstArgItem)  //will find only one constraint per 1st arg\n            if (!!constraint) {\n                checkConstraintsForArg(firstArgItem, constraint, phases, phaseNames, entryNames, entries)}}})            \n    //only expect to change objects in phases\n    return [phases, phaseNames]\n}\n\n\n//main function for dealing with missing assessment steps\n\nconst checkForMissingAssessments = (problems,events,confirmedEvents,phaseNames,phases) => {\n    let neededScenAssessments = collectScenAssessments(problems)\n    let indexCounter = events.length;\n    var checklistSteps = scenario.checkListMetaData.filter(md => [MDB_TYPES.ASSESS, MDB_TYPES.REQUIRED].includes(md.type));\n\n    // before evaluating assessment steps, deal with exceptional cases where one or more steps is not\n    // necessary for a given scenario.  Because GCS value is a string and not a formatted object\n    // we can't reliably parse out values and units to do more general checks so can only set what\n    // steps should not be assessed for a particular scenario.  Requires info on feedback to give as\n    // well.\n    // Get any exceptional steps associated with the current scenario\n    var exceptions = [];\n    for (let exceptionDef of exceptionDefs) {\n        if (exceptionDef.scenarioName === scenario.name) {\n            exceptions = exceptionDef.exceptions;\n            break;\n        }\n    }\n\n    exceptions.forEach((exception, j) => {\n        // remove the step from the checklist as it is not required\n        checklistSteps = checklistSteps.filter(entry => entry.id !== exception[0]);\n\n        // if the step was done during the observation then mark it as an issue\n        if (confirmedEvents.includes(exception[0])) {\n            // it could appear in any phase so check all phases and mark\n            // each instancs as unnecessary\n            phases.forEach((phaseObjects, j) => {\n                phaseObjects.forEach((action, i) => {\n                    if (action.id === exception[0]) {\n                        action.why = exception[1];\n                        action.status = \"notNecessary\";\n                    }\n                });\n            });\n        }\n\n    });\n\n    // iterate through all checklist steps for ones for which we don't have formated objects\n    checklistSteps.forEach((cls, i) => {\n        if (!confirmedEvents.includes(cls.id)) {\n            // add so we don't check for the missing checklist item again\n            confirmedEvents.push(cls.id);\n            let phaseObject = {\n                \"comment\": \"\",\n                \"numericalID\": indexCounter,\n                \"status\": \"missingRequiredAssessment\",\n                \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                \"expertPhase\": \"\",\n                \"workingPhase\": \"\",\n                \"contraindicatedWhy\": \"\",\n                \"minimalWhy\": \"\",\n                \"why\": \"\",\n                \"probLabel\": \"\",\n                \"protocol\": \"\",\n                \"actionDescription\": \"\",\n                \"assessmentFB\": \"\",\n                \"timestamp\": -1\n            };\n\n            //copy over the step fields that exist (type dependent)\n            const STEP_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"type\", \"prompt\"];\n            STEP_FIELDS.forEach(fldName => {\n                if (!!cls[fldName]) {\n                    phaseObject[fldName] = cls[fldName];\n                }\n            });\n            if (!!cls.subPhase) { phaseObject.workingPhase = cls.subPhase; }\n            else { if (!!cls.phase) { phaseObject.workingPhase = cls.phase; } }\n            phaseObject.when = phaseObject.workingPhase;\n            phaseObject.expertPhase = phaseObject.workingPhase;\n\n            if (!!phaseObject.label) { phaseObject.actionDescription = phaseObject.label; }\n            \n            //let findings = scenario.assessmentFindings[cls['id']]\n            //if (!!findings & findings !== \"Unremarkable\" & findings !== \"Stable\"){\n\n            if (neededScenAssessments.includes(cls['id'])){\n                phaseObject.assessmentFB = \"Thus you missed finding: \" + scenario.assessmentFindings[cls['id']]}\n            if (phaseObject.type === \"required-action\"){\n                phaseObject.status = \"missingRequiredAssessment\"\n            }\n            insertInPhaseInOrder(phaseNames, phases, phaseObject, i);\n            indexCounter++;\n        }\n    });\n    return[confirmedEvents, phaseNames, phases, indexCounter]\n}\n\n//support functions for updating and searching the phaseNames and phases data structures\nconst insertInPhaseInOrder = (phaseNames, phases, object, objIndex) => {\n    let phase\n    phase = object.when;  //what phase should it be added to\n    let phaseIndex = phaseNames.lastIndexOf(phase); //get the index for the last instance of the phase\n    let phaseObjects = phases[phaseIndex];  //get the objects associated with that phase\n    if (!phaseObjects) { phaseObjects = []; }\n    phaseObjects.splice(objIndex - 1, 0, object);  //insert it at the place indicated by input objIndex\n    phases[phaseIndex] = phaseObjects;\n};\n\nconst getEndSubPhase = (inPhaseId, phaseNames) => {\n    let subPhases = getSubPhases(inPhaseId);\n    let subPhaseName;\n    let reversedSubPhases = [...subPhases].reverse();\n    for (let subPhase of reversedSubPhases) {\n        subPhaseName = phaseNames.find(id => id === subPhase.id);\n        if (!!subPhaseName) { break; }\n    }\n    return subPhaseName;\n};\n\nconst getEndSubPhaseIndex = (inPhaseId, phaseNames) => {\n    let subPhaseName = getEndSubPhase(inPhaseId, phaseNames);\n    let index = phaseNames.lastIndexOf(subPhaseName);\n    //console.log(subPhaseName,index)\n    return index;\n};\n\n// sts 01/23/22\nconst getSubPhases = (phaseId) => {\n    return checklistHierarchy.find(phase => phase.id === phaseId).subPhases\n    // let mainPhases = findPhases();\n    // let phaseEntry = mainPhases.find(phase => phase.id === phaseId);\n    // return (phaseEntry.subPhases);\n};\n\nconst hasSubPhases = (phaseId) => {\n    let phase = checklistHierarchy.find(phase => phase.id === phaseId)\n    if (!!phase && !!phase.subPhases){\n        return true}\n    else {return false}\n}\n\n  \n//given a numerical id, what is its parent phase or subphase\n//find the header under which the input numericalID appears\nconst findHeaderFor = (numericalID, log) => {\n    let candidateHeader = {};\n    let foundHeader = {};\n    for (let entry of log) {\n        if (entry.id === \"problemHeader\") {\n            candidateHeader = entry;\n        }\n        else {\n            if (entry.numericalID === numericalID) {\n                foundHeader = candidateHeader;\n                break;\n            }\n        }\n    }\n    return (foundHeader);\n};\n\n//rearrange the problem data structure for use during analysis\n\nconst setupProblems = (problemDefs) => {\n    let problems = [];\n    for (let problemDef of problemDefs) {\n        let problem = {};\n        problem.assessments = problemDef.assessments;\n        problem.allProblemProtocols = problemDef.protocol;\n        problem.probLabel = problemDef.problem;\n        problem.lifeThreat = problemDef.lifeThreat\n       /*  problem.critical = false;\n        if (problemDef.type === \"critical\") { problem.critical = true; }; */\n        let solution = problemDef.solutions[0];\n        problem.actions = solution.actions;\n        problem.contraindications = solution.contraindications;\n        problem.minimalWhy = solution.minimalWhy;\n        problem.protocols = solution.protocols;\n        problems.push(problem);\n    }\n    return (problems);\n\n    //console.log(problems)\n};\n\n// this approximates the placement for a missing intervention based on ordering of interventions\n// in the problems definitions, what appears in the log that is just before and just after\n// the item to be inserted, and what is marked as required that is in the log just before and after.  An approach that\n// utilizes partial ordering constraints would be better.  Also it is not clear what to do for really badly ordered\n// actions on the part of the student.  Note that it only looks for two anchor points before and two anchor points after\n// rather than all potential anchor points.  Also it does not deal with a phase that is split into multiple time periods\n// within a log. It looks for the best placement in the last phase found.\n\n//input orderedArrayObjects is the interventions for a problem as ordered in the problem def\n// objIndex is the index in orderedArrayObjects for the intervention object that needs to be inserted in phases\nconst insertInPhaseRelativeToSuggestedOrder = (phaseNames, phases, object, orderedArrayObjects, objIndex) => {\n    // if expertPhase in object is a phase then find the last subphase and insert there instead of at the beginning\n    let phaseIndex = -1;\n    //console.log(object);\n    // if it is a subphase or a phase with no subphases then get the last entry for a proposed initial insertion point\n    // object.expertPhase is the phase recommended for this action to appear\n    if (object.expertPhase === \"\"){\n        /* let errorMsg = 'No phase specified in the problem defs for object: ' + object.actionDescription;\n        throw new Error(errorMsg) */\n        //just use the next to last phase if none is specified\n        object.expertPhase = requiredPhaseNames[requiredPhaseNames.length - 2]}\n        \n\n    if (requiredSubphases.includes(object.expertPhase) || !getSubPhases(object.expertPhase)) {\n        phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    }\n    // if it is a phase then get the last entry of the last suphase within it for a proposed intial insertion point\n    else {\n        phaseIndex = getEndSubPhaseIndex(object.expertPhase, phaseNames);}\n        \n    //update object when field which is mostly to see what gets computed for the insertion point\n    object.when = phaseNames[phaseIndex];\n        \n    \n\n    let objectsBefore = orderedArrayObjects.slice(0, objIndex - 1);\n    let objectBefore = orderedArrayObjects[objIndex - 1];\n    // console.log(\"Objects before in def\", {...objectsBefore})\n    let requiredObjectBefore = [...objectsBefore].reverse().find(entry => entry.required);\n    let objectAfter = orderedArrayObjects[objIndex + 1];\n    let objectsAfter = orderedArrayObjects.slice(objIndex + 1);\n    let requiredObjectAfter = objectsAfter.find(entry => entry.required);\n    //let phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    let phaseObjects = [...phases[phaseIndex]]; //trying for a deep copy of the array mainly for debug via console.log\n\n    //console.log(phaseObjects)\n    let indexBefore = -1;\n    let indexAfter = -1;\n    let indexRequiredBefore = -1;\n    let indexRequiredAfter = -1;\n    let insertionIndex = false;\n    if (objectBefore) { indexBefore = phaseObjects.findIndex(entry => entry.id === objectBefore.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    if (requiredObjectBefore) { indexRequiredBefore = phaseObjects.findIndex(entry => entry.id === requiredObjectBefore.id); }\n    if (requiredObjectAfter) { indexRequiredAfter = phaseObjects.findIndex(entry => entry.id === requiredObjectAfter.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    // There is a more compact way to do the below but this made\n    // it easier for me to get the logic right\n    // insert according to required before first as we want to follow something that was required\n    if (indexRequiredBefore !== -1) {\n        insertionIndex = indexRequiredBefore + 2;\n        // but if the just before object is greater then insert relative to it\n        if (indexBefore > indexRequiredBefore) { insertionIndex = indexBefore + 2; }\n    }\n    //if no required before and not required after then insert relative to\n    //required item after in actions definition\n    if (!insertionIndex && indexRequiredAfter !== -1) {\n        insertionIndex = indexRequiredAfter + 1;\n        // unless the just after is smaller then override and insert relative to it\n        if (indexAfter < indexRequiredAfter) { insertionIndex = indexAfter + 1; }\n    }\n    //otherwide if have a just before insert relative to it\n    if (!insertionIndex && indexBefore !== -1) {\n        insertionIndex = indexBefore + 2;\n    }\n    //otherwise if have a just after insert relative to it\n    if (!insertionIndex && indexAfter !== -1) {\n        insertionIndex = indexAfter + 1;\n    }\n    //otherwise put at end of phase\n    if (!insertionIndex) {\n        insertionIndex = phaseObjects.length + 2;\n    }\n    insertInPhaseInOrder(phaseNames, phases, object, insertionIndex);\n\n};\n\nconst determineHLcolor = (lowerColor, higherColor) => {\n    let newColor = higherColor\n    if (lowerColor === \"red\") {\n        newColor = \"red\"\n    }\n    if (lowerColor === \"yellow\" && newColor !== \"red\") {\n        newColor = \"yellow\"\n    }\n    return newColor\n}\n\n//to display the log using the phase structures accumulated\n// i.e. puts the phases data together in the order in which\n// should be displayed in debriefing log\nconst organizeLogDisplay = (phaseNames, phases) => {\n    let displayObjects = [];\n    let entryIndex = 1;\n    let headerIndex = 1;\n    let problemHeaderColor = \"green\"\n    let subPhaseColor = \"green\"\n    let subPhaseStatuses = []\n    let phaseStatuses = []\n    let newPhaseObjects = []\n    let headerObj = {\n        \"id\": \"assessmentHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"protocol\": \"\"\n    };\n    let subHeaderObj = {\n        \"id\": \"assessmentSubHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"phaseID\": \"\",\n        \"protocol\": \"\"\n    };\n    \n    let priorHLPhaseItem = \"\"\n    let endEntry = false\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let iPhaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let process = true\n        \n        if (requiredPhaseNames.includes(phaseName) && hasSubPhases(phaseName)) {\n            process = false}\n\n        if (iPhaseObjects.length > 0 && process) {\n                //for this set of objects, find the worst scoring item\n            let phaseObjects = phases[phaseIndex];\n            subPhaseColor = \"green\"\n            for (let phaseObject of phaseObjects) {\n                if (phaseObject.type !== \"intervention\"){\n                    subPhaseStatuses.push(phaseObject.status)}\n                //else {hierProblemResults.push(phaseObject)} \n                if (problemStates.includes(phaseObject.status)) {\n                    subPhaseColor = \"red\";     \n                }\n                // Red has a higher priority than yellow so will allow to override it\n                if (cautionStates.includes(phaseObject.status) && subPhaseColor !== \"red\") {\n                    subPhaseColor = \"yellow\";    \n                }               \n                phaseObject.numericalID = entryIndex++;\n                //entryIndex++;\n            };\n\n            let subheader = Object.assign({}, subHeaderObj)\n            let localPhaseName = phaseNames[phaseIndex]\n            let localPhaseItem = getItem(localPhaseName)\n            subheader.label = localPhaseItem.label\n            subheader.labelID = localPhaseItem.id\n            subheader.status = getPhaseStatus(subPhaseStatuses)\n            subheader.displayColor = subPhaseColor\n            let highLevelPhase = subPhases[localPhaseName]\n            let highLevelPhaseItem = getItem(highLevelPhase)\n            subheader.phaseID = highLevelPhaseItem.id\n\n            //Note that the inserted headers will have their own numerical id and\n            //am dividing by 1000 for headers so their numerical id will be unique\n            //to headers.  Am assuming we would never have more than 1000 events\n            //observed.  Will use the numerical ids for testing before and after\n            //constraints.       \n            \n            if (priorHLPhaseItem === \"\") {\n                priorHLPhaseItem = highLevelPhaseItem\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n            }\n            \n            if (phaseIndex === phaseNames.length - 1) {\n                //this closes out the prior phase and the new subphase \n                let header = Object.assign({}, headerObj)\n                if (highLevelPhase !== priorHLPhaseItem.label){    //ending with start of a new phase\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    newPhaseObjects = []}\n\n                header = Object.assign({}, subheader)\n                header.label = highLevelPhaseItem.label\n                header.labelID = highLevelPhaseItem.id\n                header.id = \"assessmentHeader\"\n                header.numericalID = headerIndex++ / 1000 \n                displayObjects.push(header)\n                      \n                if (highLevelPhase === subheader.label) { \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(...phaseObjects)}\n                else {\n                    subheader.numericalID = headerIndex++ / 1000 \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(subheader)\n                    displayObjects.push(...phaseObjects)}          \n                endEntry = true;\n            }\n\n            //save the accumulated high-level phase if the phase changes \n            if (!endEntry) {\n                if (highLevelPhase !== priorHLPhaseItem.label) {\n                    let header = Object.assign({}, headerObj)\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    phaseStatuses = []\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    //reinitialize for the new phase   \n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects = [...phaseObjects]\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects = [subheader]\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    priorHLPhaseItem = highLevelPhaseItem\n                    problemHeaderColor = determineHLcolor(subPhaseColor, \"green\")\n                }\n                else {\n                    problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects.push(subheader)\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                }\n            }\n        \n        }\n    }\n    return displayObjects;\n}\n\n\n\n\nconst evalForIncorrectAnswer = (promptID, answerID, isIntervention) => {\n        //check each prompt and if is the appropriate one then\n        let answers = undefined\n        if (isIntervention) {\n            answers = scenario.associations[promptID];\n        }\n        else { answers = scenario.checkListCorrectness[promptID]; }\n\n        if (answers === undefined) { console.log(\"didn't find answers for \", promptID); return (false) }  //can't grade if answers not found in spec\n\n        if (Array.isArray(answers)) {\n            //returns bool regarding whether answerID NOT in answers\n            return !(answers.find(ansId => ansId === answerID));\n\n        }\n        else {\n            return !(answers === answerID);\n        }\n};\n\n\nconst getCorrectAnswerLabel = (promptID, isIntervention) => {\n    let answers\n    let metaData\n    if (isIntervention){\n        answers = scenario.associations[promptID];\n        metaData = scenario.intvMetaData}\n    else {answers = scenario.checkListCorrectness[promptID];\n        metaData = scenario.checkListMetaData}\n    let answerLabels = false;\n    if (Array.isArray(answers)) {\n        answers.forEach((answer, j) => {\n            metaData.forEach((entry, i) => {\n                if (entry.id === answer) {\n                    if (answerLabels === false) {\n                        answerLabels = entry.label;\n                    }\n                    else { answerLabels = answerLabels + \", \"; }\n                    return;\n                }\n            });\n        });\n    }\n\n    else {\n\n        metaData.forEach((entry, i) => {\n            /* //needed to find out what the types are for debugging\n            let answertypes = []\n            if (!answertypes.find(type => type === entry.type)){\n                answertypes.push(entry.type)} */\n\n            if (entry.id === answers) {\n                answerLabels = entry.label;\n            }\n        });\n    }\n    //answerLabels = answerLabels.charAt(0).toLowerCase() + answerLabels.slice(1);\n    /* if (answerLabels){\n        answerLabels = \"'\" + answerLabels + \"'\";} */\n    return answerLabels\n};\n\nconst getAnswerLabel = (answerID, isIntervention) => {\n    let metaData\n    if (isIntervention){\n        metaData = scenario.intvMetaData}\n    else {metaData = scenario.checkListMetaData}\n    let answerLabel = \"\";\n    metaData.forEach((entry, i) => {\n            if (entry.id === answerID) {\n                answerLabel = entry.label;\n            }\n        });\n    return (answerLabel || false) ;\n}\n\n// create structure for tracking whether interventions are checked\nconst insertMissingIntvChecks = (events, statusTracking) => {\n    let toUpdate\n    for (const [key, entry] of Object.entries(statusTracking)) {\n        if (Array.isArray(entry)){\n            for (let obj of entry) {\n                let newObj = {\"label\": key, \"foundCk\": obj[\"foundCk\"]}\n                toUpdate = getEventsByIdTime(events,obj[\"intervention\"],obj[\"timestamp\"])\n                for (let intv of toUpdate) {\n                    if (!intv[\"intvStatus\"].includes(newObj)){\n                       intv[\"intvStatus\"].push(newObj)}\n                }}}\n        else {\n            let newObj = {\"label\": \"intervention status\", \"foundCk\": entry[\"foundCk\"]}\n            toUpdate = getEventsByIdTime(events,key,entry[\"timestamp\"])\n            toUpdate.forEach(intv => {\n                if (!intv[\"intvStatus\"].includes(newObj)){\n                    intv[\"intvStatus\"].push(newObj)}})}\n    }\n    return events\n}\n\nconst insertMissingInterventions = (problems,confirmedEvents,indexCounter,phaseNames,phases) => {\n    problems.forEach(prob => {\n        const actions = prob.actions\n        // now we just have to examine action ids to see what is missing\n        actions.forEach((action, k) => {\n            if (!confirmedEvents.includes(action.id + \"+\" + prob.probLabel)) {\n                confirmedEvents.push(action.id + \"+\" + prob.probLabel);\n                let phaseObject = {\n                    \"comment\": \"\",\n                    \"numericalID\": indexCounter,\n                    \"status\": \"\",\n                    \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                    \"required\": true,\n                    \"when\": \"\",\n                    \"suggestedPhase\": \"\",\n                    \"expertPhase\": \"\",\n                    \"probLabel\": \"\",\n                    \"minimalWhy\": \"\",\n                    \"assessmentsNeeded\": \"\",\n                    \"protocol\": \"\",\n                    \"actionDescription\": \"\",\n                    \"type\": \"intervention\",\n                    \"timestamp\": -1\n                };\n\n                //copy over the step fields that exist (type dependent)\n                const ACTION_FIELDS = [\"id\", \"phase\", \"why\", \"optional\", \"minimal\"];\n                ACTION_FIELDS.forEach(fldName => {\n                    if (!!action[fldName]) {\n                        phaseObject[fldName] = action[fldName];\n                    }\n                });\n\n                //copy over the step fields that exist (type dependent)\n                const PROBLEM_FIELDS = [\"probLabel\", \"minimalWhy\"];\n                PROBLEM_FIELDS.forEach(fldName => {\n                    if (!!prob[fldName]) {\n                        phaseObject[fldName] = prob[fldName];\n                    }\n                });\n\n                //initialize some fields above that come from problem and action if they are defined\n                if (!!prob.assessments) {phaseObject.assessmentsNeeded = prob.assessments}\n                if (!!prob.protocols) {phaseObject.protocol = prob.protocols}\n                if (!!action.optional) { phaseObject.required = !action.optional; }\n                if (!!action[\"id-label\"]) { phaseObject.label = action[\"id-label\"]; }\n                if (!!action[\"id-label\"]) { phaseObject.actionDescription = action[\"id-label\"]; }\n                if (!!action.phase) {\n                    phaseObject.when = action.phase;\n                    phaseObject.expertPhase = action.phase;\n                    phaseObject.suggestedPhase = action.phase;\n                }\n\n\n                if (phaseObject.required) {\n                    phaseObject.status = \"missingRequired\";\n                }\n                else {\n                    if (!phaseObject.optional) { phaseObject.status = \"missingRequired\"; }\n                    else { phaseObject.status = \"missingOptional\"; }\n                }\n                //assume actions are in the suggested order to solve a problem\n                if (phaseObject.status !== \"missingOptional\") {\n                    insertInPhaseRelativeToSuggestedOrder(phaseNames, phases, phaseObject, actions, k);\n                    indexCounter++;\n                }\n            }\n\n        });\n    });\nreturn [indexCounter,phaseNames,phases]}\n\n//the main function for analyzing the observation log\nfunction analyzeEvents(scen, log) {\n    let events = log.events;\n    console.log(\"in analyzeEvents\")\n    // sts 1/23/22 moved the setting of the following into initGlobals()\n    // setScenario(scenario)\n    // setupSubphasePhaseLookup()\n    // findSubphases();\n    initGlobals(scen)\n\n    //preprocess some of data from problems/solutions\n    //and for now just flatten it some to set it up to\n    //look more like the original problem actions in scenario\n    // assumes there is just one solution per problem for now.\n    let problemDefs = scenario.problems;\n    let problems = setupProblems(problemDefs);\n    \n    //In the remainder, just dealing with the first solution for each problem\n    //so if we ever have more than one solution for a problem this code needs to\n    //be updated.  Would need to consider the additional solutions to decide which\n    //solution is the best fit for the observer student\n\n\n    let formattedActions = [];\n    let annotatedResults = annotateInputEvents(events,problems)\n    //phaseNames and phases are two arrays synchronized be array indices\n    //phases contains just the steps under the phase (thus could be a phase or subphase in observer interface)\n    //phaseNames contains the label for each phase in phases.  Makes it a bit easier to search phaseNames to get the\n    //indice for last instance of a phase label and access its objects\n    let phases = annotatedResults[0];  \n    let phaseNames = annotatedResults[1]; \n    let confirmedEvents = annotatedResults[2]\n    let intvsTracking = annotatedResults[3]\n    \n\n    /* //now create some similar structures for the parents of the above phases\n    //so have all the associated event objects in parents and parentNames\n    //for easy lookup\n    let parentResults = collectParentPh(phaseNames)\n    let parents = parentResults[0]  //events under this parent\n    let parentNames = parentResults[1] */\n\n    //update relative to constraints and comprises definitions\n    //for now it just compares two constraint args of the same type\n    //for what currently exists\n    let kbUpdates = checkAgainstKB(phases,phaseNames)\n    phases = kbUpdates[0]\n    phaseNames = kbUpdates[1]\n    \n    //add missing phase names to phaseNames\n    //as do insertions should consider the temporal ordering constraints\n    \n    let updatedPhases = insertMissingSubphases(phases, phaseNames)\n    phases = updatedPhases[0]\n    phaseNames = updatedPhases[1]\n\n\n    // check for missing checklist steps\n    //as do insertions should consider the temporal ordering constraints\n    let postAssessmentReview = checkForMissingAssessments(problems,events,confirmedEvents,phaseNames,phases)\n    confirmedEvents = postAssessmentReview[0]\n    phaseNames = postAssessmentReview[1]\n    phases = postAssessmentReview[2]\n    let indexCounter = postAssessmentReview[3]\n\n\n\n    // this section could be moved into a separate function so that\n    // the parts of the main analysis are clearer\n\n    // start insert missing interventions\n\n    let postInterventionReview = insertMissingInterventions(problems,confirmedEvents,indexCounter,phaseNames,phases)\n    indexCounter = postInterventionReview[0]\n    phaseNames = postInterventionReview[1]\n    phases = postInterventionReview[2]\n    // search for missing interventions for each action\n    // Doing this separately from the earlier actions loop because\n    // we wanted to add in missing assessment steps first\n    // since interventions depend on appropriate assessments having \n    // been done\n\n\n\n   // end insert missing interventions\n    \n    \n    // put together the phases into a single array ordered as directed by phases\n    \n    formattedActions = organizeLogDisplay(phaseNames, phases);\n    //console.log(\"formattedActions after organizeLogDisplay = \", formattedActions)\n\n    // Now that it is all rejoined into a single list, do some updating with additional\n    // analysis results\n\n    formattedActions = insertMissingIntvChecks(formattedActions, intvsTracking)\n    \n    \n    let priorProb = \"N/A\";\n\n    let finalActions = [];\n    //console.log(\"formattedActions = \", formattedActions)\n\n    formattedActions.forEach((eventObj, j) => {\n        let intvHeaderIndex = 1\n\n        if (insertInterventionHeader && eventObj.type === \"intervention\" && eventObj.probLabel && !(priorProb === eventObj.probLabel)) {\n            priorProb = eventObj.probLabel;\n            let headerObject = {\n                \"id\": \"interventionHeader\",\n                \"status\": \"good\",\n                \"phaseOrderStatus\": \"good\",\n                \"labelID\": eventObj.probLabel,\n                \"type\": \"header\",\n                \"numericalID\": intvHeaderIndex++/3000,\n                \"displayColor\": \"green\",\n            //    \"why\": \"\",\n                \"probLabel\": eventObj.probLabel,\n                \"protocol\": \"\"\n            };\n            finalActions.push(headerObject);\n        }\n        finalActions.push(eventObj);\n    });\n\n    // start overall analysis to determine if all actions to solve a problem are present\n\n    // now we analyze all that we've found in the log to see whether\n    // all the actions were done for each problem and reset\n    // the status if not all are there but should be counted\n    // as minimal for the feedback.\n    let pActions = []; //here we will store the actual problem actions that student did\n    let pNames = []; //here we will store the problem names for the above with same order\n    let pIndex = 0;\n    let pActIndex = -1;\n\n    //console.log(\"finalActions before minimal check = \", finalActions)\n\n    finalActions.forEach((action, j) => {\n        if (action.type === \"intervention\") {\n            //good interventions can have these status values\n            if (!!action.status && action.status.includes(\"standard\", \"incorrect-answers\", \"minimal\", \"misOrdered-standard\", \n            \"misOrdered-incorrect-answers\", \"misOrdered-incorrect-answers\", \"minimal\", \"misOrdered-minimal\", \n            \"misOrdered-minimal-incorrect-answers\",\n            \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\", \"misOrdered-phase-minimal\")) {\n                if (!pNames.includes(action.probLabel)) {\n                    pActIndex = pIndex;\n                    pNames[pActIndex] = action.probLabel;\n                    pIndex++;}\n                else { pActIndex = pNames.indexOf(action.probLabel); }\n                let actions = pActions[pActIndex];\n                if (!actions) { actions = []; }\n                actions.push(action);\n                pActions[pActIndex] = actions;\n            }\n        }\n    });\n\n    // If all the minimal were found but not all the action were, then we\n    // need to re-mark the action objects created for the minimal events\n    // to be minimal instead of standard.  It isn't\n    // appropriate to give this feedback if all actions are present.\n    // Waited until now so that all the events are in one list instead of\n    // a list per phase,\n    let processedIds = formattedActions.map(event => event.id);\n    let pIds = problems.map(a => a.probLabel);\n    pNames.forEach((pEntry, j) => {\n        //get the action definition for this problem\n        let pIndex = pIds.indexOf(pEntry);\n        let prob = problems[pIndex];\n        let actionNeeded = prob.actions.filter(obj => !obj.optional).map(obj => obj.id);\n        //collect statuses for these actions\n\n        let minimalNeeded = prob.actions.filter(obj => obj.minimal).map(obj => obj.id);\n        if (minimalNeeded) { //no point in doing anything else if no minimals were defined\n            let foundActions = pActions[j];\n            let found = foundActions.map(a => a.id);\n            let allActionFound = true;\n            let allMinimalFound = true;\n            for (let item of actionNeeded) {\n                if (!found.includes(item)) {\n                    allActionFound = false;\n                    break;\n                }\n            }\n            for (let item of minimalNeeded) {\n                if (!found.includes(item)) {\n                    allMinimalFound = false;\n                    break;\n                }\n            }\n            let numericalIDsChanged = [];\n            if (!allActionFound && allMinimalFound) {\n                minimalNeeded.forEach((foundId, j) => {\n                    let pIndex = processedIds.indexOf(foundId);\n                    let object = formattedActions[pIndex];\n\n                    //find object to modify\n                    object.minimalWhy = prob.minimalWhy;\n                    switch (object.status){\n                        case \"incorrect-answers\":\n                            object.status = \"minimal-incorrect-answers\"\n                            break\n                        case \"standard\":\n                            object.status = \"minimal\"\n                            break\n                        case \"misOrdered-standard\":\n                            object.status = \"misOrdered-minimal\"\n                            break\n                        case \"misOrdered-incorrect-answers\":\n                            object.status = \"misOrdered-minimal-incorrect-answers\"\n                            break\n                        case \"misOrdered-phase-standard\":\n                            object.status = \"misOrdered-phase-minimal\"\n                            break\n                        case \"misOrdered-phase-incorrect-answers\":\n                            object.status = \"misOrdered-phase-minimal-incorrect-answers\"\n                            break\n                        default: \n                            break}\n\n                    numericalIDsChanged.push(object.numericalID);\n                    formattedActions[pIndex] = object;\n                });\n                //redo color for header if needed\n                let header = {};\n                numericalIDsChanged.forEach((numericalID, z) => {\n                    header = findHeaderFor(numericalID, formattedActions);\n                    if (header && header.displayColor === \"green\") { header.displayColor = \"yellow\"; }\n                });\n\n            }\n        }\n\n    });\n\n    // end of overall analysis\n\n    //create summaries for condition 2\n    let summaryResults = summarizeAnalysis(finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated)\n    hierAssessResults = summaryResults[0]\n    hierProblemResults = summaryResults[1]\n\n    \n    //save analysis and summaries for condition 2 to db\n\n    console.log(\"Phase Assessment Status Results\", hierAssessResults)\n    console.log(\"Intervention Status Results\", hierProblemResults)\n    console.log(\"Constraint Violation Results\", constraintsViolated)\n    //console.log(\"Final Analysis:\", finalActions);\n\n\n    // save final analysis in a file\n    saveAnalysisLog(log, finalActions, hierAssessResults, hierProblemResults, constraintsViolated);\n\n    //else {checkOnOverwriting(log, finalActions)}\n\n\n    return (finalActions);\n\n}\n\n\nexport {analyzeEvents}","export const formatAsMinSecs = (seconds) => {\n    return new Date(seconds * 1000).toISOString().substr(14, 5)\n}","import { MDB_TYPES, CHECKLIST_STEP_TYPES, OPTION_TYPES } from \"@meddbriefer/scenario-data/constants\";\n\n// input: list of objects and a fieldName\n// returns: an object who's attributes are the distinct values for that fieldName mapped to the subset\n// of list items which share that field value\nexport const groupByKey = (listOfObjs, fldName) => listOfObjs.reduce(\n    (hash, obj) => ({ ...hash, [obj[fldName]]: (hash[obj[fldName]] || []).concat(obj) }),\n    {}\n)\n\nexport const getChecklistItemsByType = (scenario, itemType) => {\n    return scenario.checkListMetaData.filter(e => e.type === itemType)\n}\n\nexport const getChecklistItems = (scenario) => {\n  return scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(MDB_TYPES.PHASE, MDB_TYPES.SUB_PHASE))  \n}\n\nexport const getChecklistHierarchy = (scenario) => {\n    const phases = getChecklistItemsByType(scenario, MDB_TYPES.PHASE)\n    const subPhases = getChecklistItemsByType(scenario, MDB_TYPES.SUB_PHASE)\n    // filters out items which are display only\n    const clSteps = scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(e.type))\n    // get the options which are associated with some certain types of steps (decisions, assess w/options)\n    const options = scenario.checkListMetaData.filter(e => OPTION_TYPES.includes(e.type))\n    // map the options to their stepId\n    const stepOptions = groupByKey(options, \"parentID\")\n    // if a step has options, add them to that step\n    clSteps.forEach(step => {\n        if (step.id in stepOptions) {\n            step.options = stepOptions[step.id]\n        }\n    })\n    // figure out which checklist items belong to phases or subphases and group them by\n    // the their corresponding phase/subphase ids\n    const phChecklistSteps = groupByKey(clSteps.filter(e => undefined === e.subPhase), \"phase\")\n    const spChecklistSteps = groupByKey(clSteps.filter(e => !!e.subPhase), \"subPhase\")\n    // assign subphase steps to the appropriate subphase\n    subPhases.forEach(sp => {\n        sp.items = spChecklistSteps[sp.id]\n    })\n    // map subphases to their phase\n    const phSubphases = groupByKey(subPhases, \"phase\")\n    // phases have either items or subphases -not both. assign the appropriate stuff\n    // to each phase\n    phases.forEach(ph => {\n        if (ph.id in phChecklistSteps) {\n            ph.items = phChecklistSteps[ph.id]\n        } else {\n            ph.subPhases = phSubphases[ph.id]\n        }\n    })\n    return phases\n}","import { getPhaseStatus, pushNew} from \"./debriefingUtils\"\n\nlet allAssessResults = []\nlet allProblemResults = []\n\nconst getEntriesUnderHeader = (headerID,events,level,populate) => {\n    let header = mergeHeaderStatuses(headerID,events)\n    if (!!header) { \n        let results = [header]\n        if (populate){\n            let eventItems\n            if (level === 2){\n                eventItems = events.filter(e => (e.expertPhase === headerID && e.type !== \"header\"))}\n            if (level === 1){\n                eventItems = events.filter (e => (e.phaseID === header.labelID && e.type === \"header\" && e.id === \"assessmentSubHeader\"))}\n            results = results.concat(eventItems)}\n       return results}\n    else {return false}\n }\n\n//merges a phase or subphase that is temporarly split\nconst mergeHeaderStatuses = (headerID, events) => {\n    let overallStatus = \"unk\"\n    let headerStatuses = []\n    let headerItems = events.filter(e => e.type === \"header\" && e.labelID === headerID)\n    let header = headerItems[0]    \n    for (const item of headerItems){\n        if (!headerStatuses.includes(item.status)){headerStatuses.push(item.status)}\n    }\n    if (headerStatuses.length > 0) {\n        if (headerStatuses.length === 1){overallStatus = headerStatuses[0]}\n        else {overallStatus = \"errors\"}  //must be all good or all absent for either of those to hold\n    }\n    if (!!header) {header.status = overallStatus}\n    return header \n}\n\n// use if there is a possibility that the children headers could have changed because of their merging\n    // across time\n    const updateHeader = (headerID, events) => {\n        if (headerID !== \"Unknown\") {\n            let newStatus\n            let statuses = []\n            let headerItems = events.filter(e => e.type === \"header\" && e.labelID === headerID)\n            let header = headerItems[0]\n            let subitems = events.filter(e => (e.phaseID === header.labelID && e.type === \"header\" && e.id === \"assessmentSubHeader\"))\n            for (let item of subitems) {\n                pushNew(item.status, statuses)\n            }\n            if (statuses.length === 1) { newStatus = statuses[0] }\n            else { newStatus = \"errors\" }\n            header.status = newStatus\n        }\n    }\n\n\n\n    \nexport const summarizeAnalysis = (finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated) => {\n    let hierAssessResults = {}\n    let hierProblemResults = {}\n    finalActions.forEach(event => {\n        if (event.type !== \"intervention\" && event.type !== \"answer\"){\n            allAssessResults.push(event)}\n        else {allProblemResults.push(event)}\n\n    }) \n    problems.forEach(prob => {\n        let intvHeaderIndex = 1\n        let entries = allProblemResults.filter(e => (e.probLabel === prob.probLabel && e.type !== \"header\"))\n        let statuses = entries.map(e => e.status)\n        let status = getPhaseStatus(statuses)\n        let headerObject = {\n            \"id\": \"interventionHeader\",\n            \"status\": status,\n            \"phaseOrderStatus\": \"good\",\n            \"labelID\": prob.probLabel,\n            \"type\": \"header\",\n            \"numericalID\": intvHeaderIndex++/2000,\n            \"displayColor\": \"green\",\n        //    \"why\": \"\",\n        //    \"protocol\": \"\"\n        };\n        if (entries){\n            hierProblemResults[prob.probLabel] = [headerObject].concat(entries)}\n\n    })\n\n    let subLevel = requiredPhaseAndSubPhases\n    let topLevel = requiredPhaseNames.filter(e => !subLevel.includes(e))\n    \n    //need to update status in headers for lower level first since those\n    //values will percolate upwards\n\n    subLevel.forEach(headerID  => {\n        let entries = getEntriesUnderHeader(headerID,allAssessResults,2,true)\n        //console.log(\"header = \", header, \"entries = \", entries)\n        if (entries){\n            hierAssessResults[headerID] = entries}})\n\n            topLevel.forEach(headerID => {\n                updateHeader(headerID,allAssessResults)  // in case the merging of split subphases above changes a status\n                let entries = getEntriesUnderHeader(headerID,allAssessResults,1,true)\n                //console.log(\"header = \", header, \"entries = \", entries)\n                if (entries){\n                    hierAssessResults[headerID] = entries}})\n        \n            \n            // store phase level contraint feedback at the header level for condition 2 \n            // (Note that for condition 1 it was stored during the analysis at the first\n            // event entry for a phase and is prefaced by misOrderedPhase in status so that\n            // it alone won't count as an error later for condition 2)\n            let entryToModify\n            constraintsViolated.forEach(constraint => {\n                entryToModify = finalActions.filter(e => e.labelID === constraint.arg1.id)[0]\n                entryToModify.phaseOrderStatus = \"misOrdered\"\n                if (!entryToModify.arg2){\n                    entryToModify.arg2 = [constraint.arg2.id]}\n                else {entryToModify.arg2 = entryToModify.arg2.concat([constraint.arg2.id])}\n            })\n\n    return [hierAssessResults, hierProblemResults]\n\n}","import React, { useContext } from 'react';\n\nimport {\n    Button,\n    Nav,\n    Navbar,\n    NavbarBrand,\n    NavbarText,\n} from \"reactstrap\";\n\nimport { AuthContext } from \"@meddbriefer/mdb-auth\"\n\n// {/* <Button color=\"primary\" onClick={prefsToggler}>\n//     Preferences\n// </Button> */}\n\n\nconst MDBNavBar = ({title, leftNav = null, rightNav = null }) => {\n\n    const { isAuthenticated, userName, signOutUser } = useContext(AuthContext)\n\n    return (\n        <Navbar color=\"dark\" dark>\n\n            <NavbarBrand href=\"#\">\n                MedDBriefer\n            </NavbarBrand>\n\n            {!!leftNav &&\n                <Nav>\n                {leftNav}\n                </Nav>\n            }\n\n            {!!title &&\n                <NavbarText tag=\"h3\">{title}</NavbarText>\n            }\n\n            <Nav>\n                {isAuthenticated &&\n                <>\n                    <NavbarText>\n                        Welcome, {userName} &nbsp;\n                    </NavbarText>\n                    <Button\n                        color=\"danger\"\n                        onClick={signOutUser}\n                    >\n                        Sign Out\n                    </Button>\n                </>\n                }\n                {!!rightNav &&\n                    rightNav\n                }\n            </Nav>\n\n        </Navbar>\n    )\n}\n\nexport default MDBNavBar;\n","import React, { useState, useEffect } from 'react';\nimport { Button, Table } from 'reactstrap';\nimport MDBNavBar from \"./MDBNavBar\"\nimport { getAssessmentIcon, getColor, getFeedback, getTimestamp, saveAnalysisLog} from \"./debriefingUtils\"\n\n\n\nconst DisplayBaseDebriefing = ({log, actions, scenario, context}) => {\n    const [showCommentColumn, setShowCommentColumn] = useState(false);\n    // eslint-disable-next-line\n    //const [events, setEvents] = useState(log.events);\n    const [formattedActions, setFormattedActions] = useState(undefined);\n\n// const Debriefing = ({ log, metaData, criticalActions, associations }) => {\n    /* const toggleCommentColumn = () => {\n        setShowCommentColumn(!showCommentColumn);\n    } */\n    \n\n    const saveAnalysisLogLocally = () => {\n        saveAnalysisLog(log,formattedActions)\n    }\n\n    const toggleComments = () => {\n        setShowCommentColumn(!showCommentColumn)\n    }\n\n    const dispHeaderRow = (entry) => {\n        return (\n            <>\n                {entry.id ===  \"assessmentHeader\"  || entry.id === \"assessmentSubHeader\"\n                    ? <td colSpan=\"4\" className={getColor(entry)}>\n                        <b>{entry.label}</b>\n                    </td>\n                    : <td colSpan=\"10\" className={\"black\"} >\n                        <div><em>\n                        &nbsp;&nbsp;&nbsp;Intervention Group: {entry.probLabel}</em></div>\n                    </td>}\n            </>\n        )\n    }\n    \n    function getLabel(entry) {\n        return(\n            <>\n            {entry.type === \"obtain-vital-sign\"\n                ? vitalLabel(entry)\n                : regularLabel(entry)\n            }\n            </>\n    \n        )\n    }\n    \n    function getStatusLabel(entry){\n        let metaData = scenario.intvMetaData\n        let metaEntry = metaData.find(me => (entry.vital === me.id))\n        return(<>{metaEntry.label}</>)\n    }\n    \n    function vitalLabel(entry){\n        return(\n            <>\n            {entry.vitalType === \"intervention-status\"\n                ? <>Requested intervention status for: {getStatusLabel(entry)}, <p>Found: <i>{entry.value}</i></p></>\n                : <>Requested vital: {entry.vital}, <p>Found: <i>{entry.value}</i></p></>\n            }\n            </>\n        )\n    }\n    \n    function regularLabel(entry) {\n        return(\n            <>\n            {entry.subPhase && entry.type !== \"intervention\"\n                ? <><b>{entry.subPhase}:</b> {entry.actionDescription}.  {findingsData(entry)}</>\n                : <>{phaseLabel(entry)}</>\n        }\n            </>\n        )\n    }\n    \n    function phaseLabel(entry){\n        return(\n            <>\n            {entry.type === \"intervention\"\n                ? <><b>Intervention:</b> {entry.actionDescription}. {findingsData(entry)} </>\n                : <>{entry.actionDescription}.  {findingsData(entry)}</>\n                }\n            </>\n        )\n    }\n        \n    function findingsData(entry){\n        return(\n            <>\n            {entry.finding\n            ?<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Findings: <i>{entry.finding}</i></p>\n            :<></>\n        }\n            </>\n        )\n    \n    }\n    \n    \n     function saveComment(val) {\n        let orig = val.target.defaultValue;\n        let comment = val.target.value;\n        let entryID = val.target.id;\n        if (orig !== comment){\n            let entry = formattedActions.find(entry => (entry.id === entryID))\n            // if (entry) { entry.comment = comment }}\n            const newEntry = Object.assign({}, entry, {comment: comment})\n            updateFormattedAction(newEntry)\n        }\n    }\n    \n    const dispDataRow = (entry) => {\n        return (\n            <>\n                <td>{entry.numericalID}</td>\n                <td>{getTimestamp(entry)}</td>\n                <td className={getColor(entry)}>\n                    <span className=\"material-icons-outlined\">{getAssessmentIcon(entry)}</span>\n                    {getLabel(entry)}\n                </td>\n                <td>{getFeedback(entry)}</td>\n\n                {showCommentColumn && <td><textarea rows=\"2\" cols=\"50\" defaultValue={entry.comment} onBlur={saveComment} id={`${entry.id}`}/></td>}\n            </>\n        )\n    }\n\n    \n    const updateFormattedAction = (record) => {\n        const index = formattedActions.findIndex(rec => rec.id === record.id)\n        setFormattedActions([\n            ...formattedActions.slice(0, index),\n            record,\n            ...formattedActions.slice(index+1)\n        ])\n    }    \n\n\n    async function displayIt () {\n        \n        \n        if (context === \"review\"){\n            //console.log(\"displaying for review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(true)        \n        }\n        else {\n            //console.log(\"displaying for non-review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(false)\n              }\n\n        setFormattedActions(actions)\n    \n        \n    }\n\n    \n   \n\n\n// eslint-disable-next-line\nuseEffect(\n    () => {\n        displayIt()\n        // eslint-disable-next-line\n    }, [] // empty list means this code will only be run on initial render\n)\n\n\n\nif (undefined === formattedActions) {\n    return (<h3>processing</h3>)\n}\n\nreturn (\n        <>\n            {context === \"review\"\n                ? <><MDBNavBar\n                    title={`Review of: ${log.label}`}\n                    leftNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={saveAnalysisLogLocally}>Save Debriefing Log\n                        </Button>}\n                    rightNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={toggleComments}>Toggle Comments\n                        </Button>}\n                     /></>\n                : <><MDBNavBar\n                    title={`Analysis for: ${log.label}`}\n                    /></>\n            }\n            <form>\n            <div style={{ overflowY: \"auto\", maxHeight: \"700px\" }}>\n                <Table borderless size=\"sm\">\n                    <thead>\n                        <tr>\n                            <th className=\"table-header\"> ID </th>\n                            <th className=\"table-header\"> Timestamp </th>\n                            <th className=\"table-header\"> Action Description </th>\n                            <th className=\"table-header\"> Feedback </th>\n                            {showCommentColumn && <th className=\"table-header\"> Comments </th>}\n                        </tr>\n                    </thead>\n                    <tbody className=\"scrolling\">\n                        {formattedActions.map((currentEntry, index) => (\n                            <tr key={index}>\n                                {currentEntry.type === \"header\"\n                                    ? dispHeaderRow(currentEntry)\n                                    : dispDataRow(currentEntry)\n                                }\n                            </tr>\n                        ))}\n                    </tbody>\n                </Table>\n            </div>\n        </form>\n        </>\n\n    )\n}\n\nexport {saveAnalysisLog}  \nexport default DisplayBaseDebriefing\n","import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID } from '@meddbriefer/scenario-data/index'\nimport {analyzeEvents} from './analyzeEvents'\nimport DisplayBaseDebriefing from './DisplayBaseDebriefing';\n\n\n\nfunction AnalyzeDebriefing ()  {\n    const { logID } = useParams()\n    const [observerLog, setObserverLog] = useState (undefined)\n    const [log, setLog] = useState(undefined)\n    const [scenario, setScenario] = useState(undefined)\n    const [analyzed, setAnalyzed] = useState(false)\n    const [loaded, setLoaded] = useState(false)\n\n    // eslint-disable-next-line\n    \n    // Set to true once all performed actions have been displayed in the log\n    // const [finishedPerformedActions, setFinishedPerformedActions] = useState(false);\n\n    //console.log (\"logID:\", logID)\n\n    function checkOnOverwriting() {\n        if (window.confirm (\"Are you sure you want to overwrite the existing analysis?  Any prior comments previously added will be lost.\")){\n            analyzeEventsHook(scenario, observerLog) \n            \n        }\n\n    }\n\n    async function analyzeEventsHook(scenario, log) {\n      analyzeEvents(scenario, log)}\n\n    \n    async function processEvents ()  {\n        //console.log(\"in processEvents to process a new observer file\")\n        if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n            {analyzeEventsHook(scenario, observerLog)\n            setAnalyzed(true)} \n        else {checkOnOverwriting()} \n        setAnalyzed(true)\n        return (true)    \n    }\n\n    useEffect(\n        () => {\n          getLog(db,logID)\n            .then(observerLogData => {  \n              //console.log(\"retrieve observerLogData\", observerLogData) \n              setObserverLog(observerLogData)    \n            })\n            .catch(error => alert('error fetching observer log', error))   \n        // eslint-disable-next-line\n    }, []\n      )\n    \n      useEffect(\n        () => {\n          !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n            .then(scenData => {\n              console.log(\"retrieve scenario:\", scenData)\n              setScenario(scenData)\n            })\n    \n        }, [observerLog]\n      )\n    \n      useEffect(\n        () => {\n          !!scenario && processEvents()\n          //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n    \n      useEffect(\n        () => {\n          !!analyzed && getDebriefLog(db, logID)\n            .then(logData => {\n              //console.log(\"retrieve Debriefing result:\", logData)\n              setLog(logData)  \n            })\n            .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n    \n      useEffect(\n        () => {\n          !!log && setLoaded(true) \n        }, [log]\n      )\n    \n      if (!loaded) {\n        return (<h3>Loading</h3>)\n      }\n    \n\n\n    return (\n        <DisplayBaseDebriefing\n        log={log}\n        actions={log.events}\n        scenario={scenario}\n        context={\"initial-analysis\"}\n        />\n    )\n}\n\nexport default AnalyzeDebriefing","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLog , getPublishedScenarioByID } from \"@meddbriefer/scenario-data/index\"\nimport AnalyzeDebriefing from '../components/AnalyzeDebriefing'\n\nconst Log = () => {\n\n  const { logID } = useParams()\n  const [ log, setLog ] = useState(null)\n  const [ scenario, setScenario] = useState(null)\n  const [loaded, setLoaded] = useState(false)\n\n  useEffect(\n    () => {\n      getLog(db,logID)\n        .then(logData => {\n          setLog(logData)\n        })\n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      //!!log && getScenarioByName(db, log.scenarioName, \"V2\")\n      !!log && getPublishedScenarioByID(db, log.scenarioID)\n        .then(scenData => {\n          setScenario(scenData)\n          console.log(\"scenario\", scenData)\n        })\n\n    }, [log]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && setLoaded(true)\n    }, [scenario]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n  return ( \n      <AnalyzeDebriefing \n        log={logID} \n      /> \n    )\n\n\n}\n\nexport default Log;\n","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { analyzeEvents } from '../components/analyzeEvents'\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID} from \"@meddbriefer/scenario-data/index\"\nimport DisplayBaseDebriefing from '../components/DisplayBaseDebriefing'\n\n\n\nfunction DisplayDebriefing () {\n\n  const { logID } = useParams()\n  const [observerLog, setObserverLog] = useState(undefined)\n  const [log, setLog] = useState(undefined)\n  const [scenario, setScenario] = useState(undefined)\n  const [analyzed, setAnalyzed] = useState(false)\n  const [loaded, setLoaded] = useState(false)\n\n  \n  \n  async function processLog () {\n    //console.log(\"in processLog to display existing analysis\")\n    if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n          {analyzeEvents(scenario, observerLog) \n          }\n    setAnalyzed(true)\n    return (true)\n  }\n  \n\n  //get observer log first\n\n  useEffect(\n    () => {\n      getLog(db, logID)\n        .then(observerLogData => {  \n          //console.log(\"retrieve observerLogData\", observerLogData) \n          setObserverLog(observerLogData)    \n        })\n        .catch(error => alert('error fetching observer log', error))   \n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n        .then(scenData => {\n          console.log(\"scenario:\", scenData)\n          setScenario(scenData)\n        })\n\n    }, [observerLog]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && processLog()\n      //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n      \n  useEffect(\n      () => {\n        !!analyzed && getDebriefLog(db,logID)\n          .then(logData => {\n            //console.log(\"retrieve Debriefing result:\", logData)\n            setLog(logData)  \n          })\n          .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n\n  useEffect(\n    () => {\n      !!log && setLoaded(true) \n    }, [log]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n\n\n  return (\n    <DisplayBaseDebriefing\n      log={log}\n      actions={log.events}\n      scenario={scenario}\n      context={\"review\"} />\n  )\n\n\n}\n\nexport default DisplayDebriefing;\n","import React from \"react\"\n\nimport MDBNavBar from \"./MDBNavBar\"\n\nconst UnauthedLayout = (props) => {\n\n    return (\n        <>\n            <MDBNavBar\n                title=\"MedDBriefer Authentication\"\n            />\n            { props.children }\n        </>\n    )\n}\n\nexport default UnauthedLayout","import React from \"react\"\n\nimport {\n    HashRouter as Router,\n    Switch,\n} from \"react-router-dom\"\n\nimport { AuthProvider, PrivateRoute } from \"@meddbriefer/mdb-auth\"\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport \"./styles.css\";\n\nimport LogList from \"./routes/LogList\"\nimport Log from \"./routes/Log\"\nimport DisplayDebriefing from \"./routes/DisplayDebriefing\"\n\n\nimport UnauthedLayout from \"./components/UnauthedLayout\"\n\nconst App = (props) => {\n\n    return (\n        <AuthProvider>\n            <Router>\n\n                <Switch>\n                    <PrivateRoute\n                        exact path=\"/logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={Log}\n                    />\n                    <PrivateRoute\n                        exact path=\"/debriefing-feedback-logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={DisplayDebriefing}\n                    />\n                    {/*default (catchall) route*/}\n                    <PrivateRoute\n                        exact match=\"/\"\n                        authFlowLayout={UnauthedLayout}\n                        component={LogList}\n                    />\n                </Switch>\n            </Router>\n        </AuthProvider>\n    )\n}\n\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
{"version":3,"sources":["../../../libs/mdb-firebase/index.js","../../../libs/scenario-data/constants.js","../../../libs/scenario-data/index.js","../../../libs/scenario-data/intvPrompts.js","../../../libs/scenario-data/intvMenuItems.js","routes/LogList.js","../../../libs/feedback-data/c1Data.js","../../../libs/feedback-data/c2Data.js","../../../libs/feedback-data/analysisData.js","components/debriefingUtils.js","components/analyzeEvents.js","utils.js","components/scenarioDataAccesors.js","components/summarizeAnalysis.js","components/MDBNavBar.js","components/DisplayBaseDebriefing.js","components/AnalyzeDebriefing.js","routes/Log.js","routes/DisplayDebriefing.js","components/UnauthedLayout.js","App.js","reportWebVitals.js","index.js"],"names":["userApp","getOrInitializeApp","appCfg","name","app","appID","matches","firebase","apps","filter","options","appId","length","getApp","initializeApp","process","REACT_APP_APP_ENV","console","log","apiKey","authDomain","projectId","storageBucket","messagingSenderId","measurementId","prodApp","db","auth","firestore","ASSESS","ASSESS_OPTION","AWO","DECISION","DECISION_OPTION","INTERV","PHASE","REQUIRED","SUB_PHASE","MDB_TYPES","Object","freeze","ASSESSO","CL_HEADING","CL_PROMPT","DIST_PROMPT","NESTED_CHECKLIST","REQURED","PROMPT_SET","PROMPT","ANSWER","SELECTION_TYPES","ONE","OOM","NONE","CHECKLIST_STEP_TYPES","AW","BR","BL","SH","OPTION_TYPES","ANALYSIS_TYPES","MIN","OPT","CONTRA","getPublishedScenarioByID","ST","interventionID","scenarioID","collection","doc","get","then","data","verifyDocument","collectionId","documentId","a","where","set","empty","getLog","logID","id","getDebriefLog","LogList","useState","logs","setLogs","logsLoaded","setLogsLoaded","useEffect","querySnapshot","docs","map","label","scenario","scenarioName","userName","timestamp","result","catch","error","Table","striped","borderless","size","hover","to","colorTypes","iconTypes","assessmentEntries","phaseStatusList","absent","errors","good","exceptionDefs","exceptions","globalConstraints","before","beforeOp","after","afterOp","type","conditionalConstraints","scenarioConstraintIDs","intvChecks","intvStatusNeeded","vitalsNeeded","hierAssessResults","hierProblemResults","constraintsViolated","requiredSubphases","requiredPhaseNames","requiredPhaseAndSubPhases","itemByID","itemByLabel","checklistHierarchy","pushNew","elt","array","includes","push","getPhaseStatus","statuses","itemStatuses","phaseStatuses","forEach","status","entries","key","value","getStatesForStatus","stateList","state","getAssessmentEntry","currentEntry","aIndex","assessmentEntry","displayColor","getColor","fixStrSp","textString","newString","textArray","split","lenTextArray","item","i","newItem","trim","getFeedback","intvStatus","intvStatusFB","fb","checked","notChecked","entry","foundCk","generateIntvStatusFB","feedbackString","feedbackArray","firstChar","charAt","substring","previousString","slice","nextString","toUpperCase","scenarioConstraints","getEvents","events","field","val","getEventsByIdTime","_","require","saveAnalysisLog","actions","docRef","ObserverFileCreater","ObserverFileName","commenter","schemaVersion","Date","toLocaleString","newActionsList","newObj","filterUnknown","logObj","index","undefined","pickBy","getTimestamp","seconds","toISOString","substr","groupByKey","listOfObjs","fldName","reduce","hash","obj","concat","getChecklistItemsByType","itemType","checkListMetaData","e","allAssessResults","allProblemResults","getEntriesUnderHeader","headerID","level","populate","header","mergeHeaderStatuses","eventItems","results","expertPhase","phaseID","labelID","overallStatus","headerStatuses","headerItems","summarizeAnalysis","finalActions","problems","event","prob","intvHeaderIndex","probLabel","headerObject","entryToModify","subLevel","topLevel","newStatus","subitems","updateHeader","constraint","arg1","phaseOrderStatus","arg2","problemStates","cautionStates","subPhases","initGlobals","scen","constraintIDs","initializeConstraints","initializeItemLookupByID","initializeItemLookupByLabel","phases","clSteps","stepOptions","step","phChecklistSteps","subPhase","spChecklistSteps","sp","items","phSubphases","ph","getChecklistHierarchy","findPhaseSubphasesOrdered","checklistLookupByID","intvLookupByID","intvMetaData","assign","checklistLookupByLabel","intvLookupByLabel","subPhIds","findNameNumID","names","occurrence","numericalID","numericalIDStart","numericalIDEnd","unknownItem","getItem","findObjByNumerialID","phaseNames","phaseIndex","phaseObjects","phaseName","hasSubPhases","storeMisOrderedArgs","objToModify","saveFailedConstraint","lateArg","otherArg","constraintID","op","addToListOfFeedback","parPhFB","last","repeating","toLowerCase","checkAgainst2ndArgs","arg1st","args2nd","direction","entryNames","constraintType","endNum1st","startNum1st","label1st","phFB","par1PhFB","par2PhFB","counter","violations","arg","arg2nd","label2nd","startNum2nd","endNum2nd","FB","orderingFB","appendString","storeMisOrderedFB","checkAgainstKB","listOfNames","listOfEntries","uniqueListOfNames","startIndex","endIndex","phaseObjectNames","collectEntriesToCheckConstraints","uniqueEntryNames","firstArg","firstArgItem","constraints","getConstraint","checkConstraintsForArg","insertInPhaseInOrder","object","objIndex","phase","when","lastIndexOf","splice","getEndSubPhaseIndex","inPhaseId","subPhaseName","getSubPhases","reversedSubPhases","reverse","find","getEndSubPhase","phaseId","determineHLcolor","lowerColor","higherColor","newColor","evalForIncorrectAnswer","promptID","answerID","isIntervention","answers","associations","checkListCorrectness","Array","isArray","ansId","getCorrectAnswerLabel","metaData","answerLabels","answer","j","getAnswerLabel","answerLabel","insertMissingInterventions","confirmedEvents","indexCounter","action","k","phaseObject","assessments","assessmentsNeeded","protocols","protocol","optional","required","actionDescription","suggestedPhase","orderedArrayObjects","objectsBefore","objectBefore","requiredObjectBefore","objectAfter","requiredObjectAfter","indexBefore","indexAfter","indexRequiredBefore","indexRequiredAfter","insertionIndex","findIndex","insertInPhaseRelativeToSuggestedOrder","analyzeEvents","problemDefs","problemActions","defs","sols","problemDef","problem","solutionID","solutions","actEntries","sol","problemID","lifeThreat","vitals","actIDs","act","protocolRelationship","contraindications","minimal","minimalWhy","allProblemProtocols","setupProblems","formattedActions","annotatedResults","interventionsConfirmed","trackForStatus","priorPhase","parentPhase","parentIndex","newPhaseStart","assessmentTypes","eventObj","workingPhase","eventType","processingState","prioreventObj","correctAnswerLabel","givenAnswerLabel","wrongAnswer","answerDetails","intervention","pop","answerCorrect","incorrectAnswersFB","vital","vitalType","vitalEntry","vitalEntries","updatedEntries","updateVital","PROBLEM_ACTION_FIELDS","statusChecking","intv","initialEntry","contra","why","contraindicatedWhy","incorrectAnswerFB","annotateInputEvents","intvsTracking","kbUpdates","updatedPhases","priorPh","insertMissingSubphases","postAssessmentReview","neededScenAssessments","collectScenAssessments","checklistSteps","md","exceptionDef","exception","cls","assessmentFB","assessmentFindings","checkForMissingAssessments","postInterventionReview","statusTracking","toUpdate","insertMissingIntvChecks","displayObjects","entryIndex","headerIndex","problemHeaderColor","subPhaseColor","subPhaseStatuses","newPhaseObjects","headerObj","subHeaderObj","priorHLPhaseItem","endEntry","iPhaseObjects","subheader","localPhaseName","localPhaseItem","highLevelPhase","highLevelPhaseItem","organizeLogDisplay","pActions","pNames","pIndex","pActIndex","indexOf","processedIds","pIds","pEntry","actionNeeded","minimalNeeded","found","allActionFound","allMinimalFound","numericalIDsChanged","foundId","z","candidateHeader","foundHeader","findHeaderFor","summaryResults","MDBNavBar","title","leftNav","rightNav","useContext","AuthContext","isAuthenticated","signOutUser","Navbar","color","dark","NavbarBrand","href","Nav","NavbarText","tag","Button","onClick","DisplayBaseDebriefing","context","showCommentColumn","setShowCommentColumn","setFormattedActions","getLabel","vitalLabel","regularLabel","getStatusLabel","metaEntry","me","findingsData","phaseLabel","finding","saveComment","orig","target","defaultValue","comment","entryID","newEntry","updateFormattedAction","dispDataRow","className","rows","cols","onBlur","record","rec","displayIt","style","overflowY","maxHeight","colSpan","AnalyzeDebriefing","useParams","observerLog","setObserverLog","setLog","setScenario","analyzed","setAnalyzed","loaded","setLoaded","checkOnOverwriting","window","confirm","analyzeEventsHook","observerLogData","alert","scenData","processEvents","logData","Log","DisplayDebriefing","processLog","UnauthedLayout","props","children","App","exact","path","authFlowLayout","component","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e4010a67.chunk.js","sourcesContent":["import firebase from 'firebase/app'\nimport \"firebase/auth\";\nimport \"firebase/firestore\"\n\nconst prodFirebaseCfg = {\n    apiKey: \"AIzaSyBOgWAbXUGckpad2sk0IUo00hZsV4WxG0E\",\n    authDomain: \"meddbriefer-68cd4.firebaseapp.com\",\n    projectId: \"meddbriefer-68cd4\",\n    storageBucket: \"meddbriefer-68cd4.appspot.com\",\n    messagingSenderId: \"1087114796018\",\n    appId: \"1:1087114796018:web:679fbab38dbf78af0ce96b\",\n    measurementId: \"G-Q7QZKC9KHW\"\n}\n\nconst devFirebaseCfg = {\n    apiKey: \"AIzaSyBqnEMwEstp4D7Mvtbw9OTAiNJ7qza0Ses\",\n    authDomain: \"meddbriefer-dev.firebaseapp.com\",\n    projectId: \"meddbriefer-dev\",\n    storageBucket: \"meddbriefer-dev.appspot.com\",\n    messagingSenderId: \"144940722070\",\n    appId: \"1:144940722070:web:4de179ebb58d84a7679fb7\"\n};\n\n\nconst pamFirebaseCfg = {\n    apiKey: \"AIzaSyB9eVT-fu4TOjxHoPAXqsnz9tCcbTJkTOw\",\n    authDomain: \"pamdev-ea800.firebaseapp.com\",\n    projectId: \"pamdev-ea800\",\n    storageBucket: \"pamdev-ea800.appspot.com\",\n    messagingSenderId: \"366450927885\",\n    appId: \"1:366450927885:web:caa5f022ef1de182a0e844\",\n    measurementId: \"G-JC5XZEPYT1\"\n  };\n\n  const scottFirebaseConfig = {\n  apiKey: \"AIzaSyBEhbIdVW2F2vvvfvpNb2SsCDP9Yoc__z8\",\n  authDomain: \"scottdev-f6528.firebaseapp.com\",\n  projectId: \"scottdev-f6528\",\n  storageBucket: \"scottdev-f6528.appspot.com\",\n  messagingSenderId: \"447730403122\",\n  appId: \"1:447730403122:web:1727020dbac4ad4cf6f92b\"\n\n};\n\n// console.log(`NODE_ENV: ${process.env.NODE_ENV}`)\n\nlet userApp\n\nconst getApp = (appID) => {\n    const matches = firebase.apps.filter(app => app.options.appId === appID)\n    // console.log(\"matches\", matches)\n    return (matches.length === 1) ? matches[0] : null\n}\n\nconst getOrInitializeApp = (appCfg, name) => {\n    const app = getApp(appCfg.appId)\n    // console.log(`${appCfg.appId} already exists: ${!!app}`)\n    return (!!app) ? app : firebase.initializeApp(appCfg, name)\n}\n\n// don't reinitialize app if it already exists\n// const prodApp = !firebase.apps.length ? firebase.initializeApp(prodFirebaseCfg) : firebase.app()\n//const prodApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\nif (\"pam\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using pjordan config\")\n    userApp = getOrInitializeApp(pamFirebaseCfg, \"pam\")\n} else if (\"scott\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using scott config\")\n    userApp = getOrInitializeApp(scottFirebaseConfig)\n}\nelse {\n    console.log(\"using production config\")\n    userApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\n}\n\nconst prodApp = userApp;\n// const devApp = function() {\n//     if (process.env.NODE_ENV !== \"production\") {\n//         return getOrInitializeApp(devFirebaseCfg, \"development\")\n//      }\n//      return null\n// }()\n\n// console.log(firebase.apps)\n\n\n\n\nexport const auth = prodApp.auth()\nexport const db = prodApp.firestore()\n\n// export const db = function() {\n//     return process.env.NODE_ENV !== \"production\" ? devApp.firestore() : prodApp.firestore()\n// }()\n","// the following constants are deprecated (need to figure out how to handle this)\n// use MDB_TYPES, SELECTION_TYPES, PREFIXES, and SYSTEMS instead\nexport const ANSWER = \"answer\"\nexport const ASSESS = \"assessment\"\nexport const ASSESSO = \"assessment-option\"\nexport const ASSESS_OPTION = \"assessment-option\"\nexport const AWO = \"assessment-with-options\"\nexport const CB = \"checkbox\"\nexport const CL_HEADING = \"checklist-heading\"\nexport const CL_PROMPT = \"checklist-prompt\"\nexport const CRIT_FAIL = \"critical-criteria\"\nexport const DECISION = \"decision\"\nexport const DECISION_OPTION = \"decision-option\"\nexport const DIST_PROMPT = \"distinguishing-prompt\"\nexport const HEADING = \"heading\" //not a leaf node, simply a step which has child steps\nexport const INTERV = \"intervention\" // an action performed on the patient\nexport const INTV_FORM = \"intervention-form\"\nexport const NESTED_CHECKLIST = \"nested-checklist\"\nexport const NONE = \"none\"\nexport const ONE = \"one\"\nexport const OOM = \"one-or-more\"\nexport const OPTION = \"option\"\nexport const PHASE = \"phase\"\nexport const PROMPT = \"prompt\"\nexport const PROMPT_SET = \"prompt-set\"\nexport const REQUIRED = \"required-action\"   // an action the EMT performs, but not on the patient\n// keeping as I had a typo. need to deprecate somehow\nexport const REQURED = REQUIRED\nexport const SUB_PHASE = \"sub-phase\"\n\nexport const MDB_TYPES = Object.freeze({\n    PHASE: PHASE,\n    SUB_PHASE: SUB_PHASE,\n    ASSESS: ASSESS,\n    AWO: AWO,\n    ASSESS_OPTION: ASSESS_OPTION,\n    ASSESSO: ASSESS_OPTION,\n    CL_HEADING: CL_HEADING,\n    CL_PROMPT: CL_PROMPT,\n    DECISION: DECISION,\n    DECISION_OPTION: DECISION_OPTION,\n    DIST_PROMPT: DIST_PROMPT,\n    NESTED_CHECKLIST: NESTED_CHECKLIST,\n    REQUIRED: REQUIRED,\n    REQURED: REQUIRED,\n    INTERV: INTERV,\n    PROMPT_SET: PROMPT_SET,\n    PROMPT: PROMPT,\n    ANSWER: ANSWER,\n})\nexport const SELECTION_TYPES = Object.freeze({\n    ONE: ONE,\n    OOM: OOM,\n    NONE: NONE\n})\nexport const SELECTION_TYPE_LABELS = Object.freeze({\n    ONE: \"One\",\n    OOM: \"One or more\",\n    NONE: \"None\"\n})\nexport const PREFIXES = Object.freeze({\n    PHASE: \"\",\n    SUB_PHASE: \"\",\n    ANSWER: \"answer-\",\n    ASSESS: \"assess-\",\n    AWO: \"assessment-with-options-\",\n    ASSESS_OPTION: \"assess-option-\",\n    CL_PROMPT: \"cl-prompt-\",\n    DECISION: \"decision-\",\n    DECISION_OPTION: \"decision-option-\",\n    INTERV: \"intv-\",\n    PROMPT_SET: \"prompt-set-\",\n    PROMPT: \"prompt-\",\n    REQUIRED: \"required-action-\",\n})\n\nexport const SYSTEMS = Object.freeze({\n    AW: \"airway\",\n    BR: \"breathing\",\n    BL: \"bleeding\",\n    SH: \"shock\",\n})\nexport const SYSTEM_LABELS = Object.freeze({\n    AW: \"Airway\",\n    BR: \"Breathing\",\n    BL: \"Bleeding\",\n    SH: \"Shock\"\n})\n\nexport const CHECKLIST_STEP_TYPES = [ASSESS, AWO, DECISION, REQUIRED]\nexport const OPTION_TYPES = [ASSESS_OPTION, DECISION_OPTION]\nexport const ANALYSIS_TYPES = [ASSESS, AWO, DECISION, REQUIRED, INTERV, PHASE, SUB_PHASE]\n\nexport const PROTOCOL_RELATIONSHIPS = Object.freeze({\n    NONE: \"\",\n    MIN: \"mimimal\",\n    OPT: \"optional\",\n    CONTRA: \"contraindicated\"\n})","\nimport _ from \"lodash\"\n\nimport { MDB_TYPES } from \"./constants.js\"\nimport { ScenarioType, PublishedScenario } from \"./types.js\"\n\n// the rest of these imports can go away soon. simply allows me to delete objects form the db\n// and reload with files. not used if records exist in db\nimport INTVS from \"./intvs.js\"\nimport INTV_PROMPTS from \"./intvPrompts.js\"\nimport INTV_PROMPT_ANSWERS from \"./intvPromptAnswers.js\"\nimport INTV_MENU_CATS from \"./intvMenusCats.js\"\nimport INTV_MENU_ITEMS from \"./intvMenuItems.js\"\n\nexport const loadIntvs = () => {\n    const tmp = INTVS.map(e => {\n        const rec = {...e}\n        if (!e.abbrLabel) {\n            rec.abbrLabel = e.label\n        }\n        if (!e.distPrompts) {\n            rec.distPrompts = []\n        }\n        if (!e.prompts) {\n            rec.prompts = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPrompts = () => {\n    const tmp = INTV_PROMPTS.map(e => {\n        const rec = {...e}\n        if (!!e.interventionID) {\n            const found = INTVS.find(i => i.id === e.interventionID)\n            if (!found) {\n                console.log(`loadIntvPrompts(${e.id}) ${e.interventionID} not found`)\n            }\n        }\n        if (!e.abbrLabel) {\n            rec.abbrLabel = \"\"\n        }\n        if (!e.feedback) {\n            rec.feedback = rec.label\n        }\n        if (!e.answers) {\n            rec.answers = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPromptAnswers = () => {\n    const tmp = INTV_PROMPT_ANSWERS.map(e => {\n        if (!e.abbrLabel) {\n            e.abbrLabel = \"\"\n        }\n        const found = INTV_PROMPTS.find(p => p.id === e.promptID)\n        if (!found) {\n            console.log(`loadIntvPromptAnswers(${e.id}) ${e.promptID} not found`)\n        }\n        return e\n    })\n    return tmp\n}\n\nexport const getScenarios = (db, scenarioType, schemaVersion) => {\n    const query = db.collection(\"scenarios\")\n             .where(\"scenarioType\", \"==\", scenarioType)\n             .where(\"schemaVersion\", \"==\", schemaVersion)\n    return query.get()\n        .then(snapShot => {\n            const scenarios = []\n            if (snapShot.size > 0) {\n                snapShot.docs.forEach(doc => {\n                    const data = doc.data()\n                    scenarios.push({\n                        id: data.id,\n                        name: data.name,\n                        scenarioType: data.scenarioType,\n                        schemaVersion: data.schemaVersion\n                    })\n                })\n            }\n            return scenarios\n        })\n}\n\nexport const getPublishedScenarioObjectByID = async (db, scenarioID) => {\n    const data = await getPublishedScenarioByID(db, scenarioID)\n    return new  PublishedScenario(data)\n}\n\nexport const getPublishedScenarioByID = (db, scenarioID) => {\n    return db.collection(\"published-scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByID = (db, scenarioID) => {\n    return db.collection(\"scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByName = (db, scenarioName, schemaVersion) => {\n    return db.collection(\"scenarios\")\n    .where(\"name\", \"==\", scenarioName)\n    .where(\"schemaVersion\", \"==\", schemaVersion)\n    .limit(1)\n    .get()\n    .then(snapShot => {\n        if (snapShot.size === 1) {\n            return snapShot.docs[0].data()\n        } else {\n            throw new Error(\"document not found\")\n        }\n    })\n}\n\nconst addMissingScenarioTypeFields = (scenTypeData) => {\n    const msgs = []\n    if (!scenTypeData.interventions) {\n        msgs.push(\"loading intvs from file\")\n        scenTypeData.interventions = loadIntvs()\n    }\n    if (!scenTypeData.interventionPrompts) {\n        const errs = []\n        const tmpPrompts = loadIntvPrompts()\n        tmpPrompts.forEach(e => {\n            if (e.type === MDB_TYPES.PROMPT) {\n                // ignore this check if distinguishing prompt (not associated with a single intv)\n                if (undefined === scenTypeData.interventions.find(rec => rec.id === e.interventionID)) {\n                    errs.push(`bad interventionID ${e.interventionID}`)\n                }\n            }\n        })\n        let msg = \"loading intv prompts from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPrompts = tmpPrompts\n    }\n    if (!scenTypeData.interventionPromptAnswers) {\n        const errs = []\n        const tmpPromptAnswers = loadIntvPromptAnswers()\n        tmpPromptAnswers.forEach(e => {\n            if (undefined === scenTypeData.interventionPrompts.find(rec => rec.id === e.promptID)) {\n                errs.push(`bad promptID ${e.promptID}`)\n            }\n        })\n        let msg = \"loading intv prompt answers from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPromptAnswers = tmpPromptAnswers\n    }\n    if (!scenTypeData.interventionMenuCategories) {\n        msgs.push(\"loading intv menu categories from file\")\n        scenTypeData.interventionMenuCategories = INTV_MENU_CATS\n    }\n    if (!scenTypeData.interventionMenuItems) {\n        const errs = []\n        const tmpIntvMenuItems = INTV_MENU_ITEMS.map(e => {\n            const found = scenTypeData.interventionMenuCategories.find(cat => cat.id === e.intvCategoryID)\n            if (!found) {\n                errs.push(`bad intvCategoryID ${e.intvCategoryID}`)\n            } else {\n                if (e.type === MDB_TYPES.INTERV) {\n                    const intv = scenTypeData.interventions.find(i => i.id === e.interventionID)\n                    if (!intv) {\n                        errs.push(`bad interventionID ${e.interventionID}`)\n                    } else {\n                        e.label = intv.label\n                    }\n                }\n                return e\n            }\n        })\n        let msg = \"loading intv menu items from file...\"\n\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionMenuItems = tmpIntvMenuItems\n    }\n    if (msgs.length > 0) {\n        msgs.forEach(m => console.log(m))\n    } else {\n        console.log(\"all data loaded from db. files not needed\")\n    }\n    return scenTypeData\n}\n\nexport const getScenarioTypeObjectByID = async (db, scenarioTypeID) => {\n    const data = await getScenarioTypeByID(db, scenarioTypeID)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeObject = async (db, scenarioType, schemaVersion) => {\n    const data = await getScenarioType(db, scenarioType, schemaVersion)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeByID = (db, scenarioTypeID) => {\n    return db.collection(\"scenario-types\")\n        .doc(scenarioTypeID)\n        .get()\n        .then(doc => {\n        const data = doc.data()\n        data.id = doc.id\n        return addMissingScenarioTypeFields(data)\n        })\n        .catch(error => {\n            console.log(error)\n            return error\n        })\n}\n\nexport const getScenarioType = (db, scenarioType, schemaVersion) => {\n    return db.collection(\"scenario-types\")\n            .where(\"name\", \"==\", scenarioType)\n            .where(\"schemaVersion\", \"==\", schemaVersion)\n            .limit(1)\n            .get()\n            .then(snapShot => {\n                if (snapShot.size === 1) {\n                    return addMissingScenarioTypeFields(snapShot.docs[0].data())\n                } else {\n                    throw new Error(\"document not found\")\n                }\n            })\n}\n\n\n\n// FIXME: this needs to go away, although I need to figure out if it's in use anywhere first\nexport const getPromptAndOptions = (scenarioTypeOrPubScenario, promptID) => {\n    const scenType = scenarioTypeOrPubScenario\n    const prompt = scenType.interventionPrompts.find(e => e.id === promptID)\n    if (!!prompt) {\n        const options = prompt.answers.map(ansID => scenType.interventionPromptAnswers.find(a => a.id === ansID))\n        prompt.options = options.map(opt => {\n            return {...opt, prompt: prompt.label}\n        })\n    }\n    return prompt\n}\n\n// moved over from apps/data-entry/src/scripts/connect-firebase\n// added 'db' as first param so that these functions can be used either from web or server firebase APIs\n/**\n * Verify document doesn't already exist in database.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns True if document with given ID doesn't exist yet.\n */\nexport const verifyDocument = async (db, collectionId, documentId) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    return set.empty;\n};\n\n// returns true if combo of name and schemaVersion fields is unique\nexport const verifyDocNameUniqueness = async (db, collectionID, candidateName, dbNameField, schemaVersion) => {\n    const snapshot = await db.collection(collectionID)\n        .where(dbNameField, \"==\", candidateName)\n        .where(\"schemaVersion\", \"==\", schemaVersion)\n        .get()\n    return snapshot.empty\n}\n\n// Upload document object to database\nexport const publishDocument = async (db, collectionId, documentObject, documentId) => {\n    documentId\n        ?\n        await db.collection(collectionId).doc(documentId).set(documentObject) :\n        await db.collection(collectionId).doc().set(documentObject);\n};\n\n// Update document with given id\nexport const updateDocument = async (db, collectionId, documentId, documentObject) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    set.empty ?\n        publishDocument(collectionId, documentObject) :\n        await db.collection(collectionId).doc(set.docs[0].id).set(documentObject);\n};\n\n/**\n * Will save document, using auto-generated IDs if documentObject doesn't have\n * an 'id' attribute.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {object} documentObject\n */\nexport const saveDocument = async (db, collectionId, documentObject) => {\n    const doc = (!documentObject.id) ?\n        db.collection(collectionId).doc() :\n        db.collection(collectionId).doc(documentObject.id);\n    documentObject.id = doc.id;\n    await doc.set(documentObject);\n    return documentObject.id\n}\n\n/**\n * Query collection for document with id\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns {object} Object containing document data.\n */\nexport const getDocument = async (db, collectionId, documentId) => {\n    const doc = await db.collection(collectionId).doc(documentId).get();\n    return doc.data();\n};\n\n/**\n * Query collection for document with name\n * @param {string} collectionId\n * @param {string} documentName\n * @returns {object} Object containing document data.\n */\nexport const getDocumentWithName = async (db, collectionId, documentName) => {\n    const set = await db.collection(collectionId).where(\"name\", \"==\", `${documentName}`).get();\n    return set.docs[0]?.data();\n};\n\n/**\n * Delete document from collection\n * @param {string} collectionId\n * @param {string} documentId\n */\nexport const deleteDocument = async (db, collectionId, documentId) => {\n    await db.collection(collectionId).doc(documentId).delete();\n};\n\n/**\n * Pull collection from database as array of document objects\n * @param {string} collectionId\n * @returns {object[]} An array containing all of the document in the collection.\n */\nexport const getCollection = async (db, collectionId) => {\n    const collection = await db.collection(collectionId).get();\n    return collection.docs?.map(item => item.data());\n};\n\n// copied over from /apps/debriefer/src/scripts/connect-firebase and 'db' param added as first param\n\n// Get a list of document names and a copy of each document\nexport const listDocumentNames = async (db, collectionId) => {\n    let documentList = db.collectionGroup(collectionId);\n    let documentDictionary = {};\n    documentList.get().then((querySnapshot) => {\n        querySnapshot.forEach((doc) => {\n            documentDictionary[doc.id] = doc.data();\n        });\n    });\n    return documentDictionary;\n}\n\nexport const getLogs = (db) => {\n    return db.collection(\"logs\").get()\n        .then(querySnapshot => {\n            return querySnapshot.docs.map(doc => {\n                const data = doc.data()\n                return {\n                    id: doc.id,\n                    label: data.label,\n                    scenario: data.scenarioName,\n                    userName: data.userName,\n                    timestamp: data.timestamp\n                }\n            })\n        })\n}\n\n\nexport const getLog = (db, logID) => {\n    return db.collection(\"logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const getDebriefLog = (db, logID) => {\n    return db.collection(\"debriefing-feedback-logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const createInterventionVariant = (distPromptIds2OptIds) => {\n    // the list of opt IDs mapped to each distPromptID needs to be sorted in order\n    // to make them comparable\n    const retVal = {}\n    Object.entries(distPromptIds2OptIds).forEach(([distPromptID, optionsArray]) => {\n        retVal[distPromptID] = optionsArray.sort()\n    })\n    return retVal\n}\n\nexport const interventionVariantsAreEqual = (intvVariant1, intvVariant2) => {\n    return _.isEqual(intvVariant1, intvVariant2)\n}\n\n","import { MDB_TYPES, SELECTION_TYPES as ST } from \"@meddbriefer/scenario-data/constants.js\"\n\nconst INTV_PROMPTS = [\n    {\n        \"id\": \"prompt-wound-location\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.ONE,\n        label: \"Where is the wound located?\",\n        abbrLabel: \"Wound location?\",\n        answers: [\n            \"answer-wound-location-head\",\n            \"answer-wound-location-neck\",\n            \"answer-wound-location-chest\",\n            \"answer-wound-location-abdomen-pelvis\",\n            \"answer-wound-location-posterior\",\n            \"answer-wound-location-genitalia\",\n            \"answer-wound-location-left-lower-extremity\",\n            \"answer-wound-location-right-lower-extremity\",\n            \"answer-wound-location-left-upper-extremity\",\n            \"answer-wound-location-right-upper-extremity\",\n            \"answer-wound-location-other\"\n        ]\n    },\n    {\n        \"id\": \"prompt-wound-locations\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.OOM,\n        label: \"Where are the wound(s) located?\",\n        abbrLabel: \"Wound location(s)?\",\n        answers: [\n            \"answer-wound-locations-head\",\n            \"answer-wound-locations-neck\",\n            \"answer-wound-locations-chest\",\n            \"answer-wound-locations-abdomen-pelvis\",\n            \"answer-wound-locations-posterior\",\n            \"answer-wound-locations-genitalia\",\n            \"answer-wound-locations-left-lower-extremity\",\n            \"answer-wound-locations-right-lower-extremity\",\n            \"answer-wound-locations-left-upper-extremity\",\n            \"answer-wound-locations-right-upper-extremity\",\n            \"answer-wound-locations-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-airway-patency-suction-device\",\n        \"interventionID\": \"intv-airway-patency-technique-suction-airway\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What kind of suction catheter will you use?\",\n        \"abbrLabel\": \"Suction catheter type?\",\n        \"answers\": [\n            \"answer-airway-patency-suction-yankauer\",\n            \"answer-airway-patency-suction-long-multiuse\",\n            \"answer-airway-patency-suction-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-advanced-airway-adjunct-type\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of advanced airway adjunct would you use?\",\n        \"abbrLabel\": \"Which advanced airway?\",\n        \"answers\": [\n            \"answer-alternative-rescue-airway-type-ett\",\n            \"answer-alternative-rescue-airway-type-combitube\",\n            \"answer-alternative-rescue-airway-type-lta\",\n            \"answer-alternative-rescue-airway-type-lma\",\n            \"answer-alternative-rescue-airway-type-igel\",\n            \"answer-alternative-rescue-airway-type-other\"\n        ]\n    }, {\n        \"id\": \"prompt-advanced-airway-tube-size\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\":\"one\",\n        \"label\": \"What tube size for advanced airway?\",\n        \"abbrLabel\": \"What size?\",\n        \"answers\": [\n            \"answer-alternative-airway-tube-size-7\",\n            \"answer-alternative-airway-tube-size-8\",\n            \"answer-alternative-airway-tube-size-age-div-4-plus-4\",\n            \"answer-alternative-airway-tube-size--age-div-4-plus-4-minus-5\",\n            \"answer-alternative-airway-tube-size-37f\",\n            \"answer-alternative-airway-tube-size-41f\",\n            \"answer-alternative-airway-tube-size-0\",\n            \"answer-alternative-airway-tube-size-1\",\n            \"answer-alternative-airway-tube-size-1-5\",\n            \"answer-alternative-airway-tube-size-2\",\n            \"answer-alternative-airway-tube-size-2-5\",\n            \"answer-alternative-airway-tube-size-3\",\n            \"answer-alternative-airway-tube-size-4\",\n            \"answer-alternative-airway-tube-size-5\",\n            \"answer-alternative-airway-tube-size-6\",\n            \"answer-alternative-airway-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-orotracheal-intubation-tube-insertion-depth\",\n        \"interventionID\": \"intv-orotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what depth would you insert the tube?\",\n        \"abbrLabel\": \"Tube insertion depth?\",\n        \"answers\": [\n            \"answer-orotracheal-intubation-tube-insertion-depth-21cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-23cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-3-times-tube-size\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasotracheal-intubation-tube-size\",\n        \"interventionID\": \"intv-nasotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What tube size would you use?\",\n        \"abbrLabel\": \"Tube size?\",\n        \"answers\": [\n            \"answer-nasotracheal-intubation-tube-size-6-to-6-5\",\n            \"answer-nasotracheal-intubation-tube-size-7-to-7-5\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus1\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus0-5\",\n            \"answer-nasotracheal-intubation-tube-size-0-5-1cm-less-than-oro-size\",\n            \"answer-nasotracheal-intubation-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasal-cannula-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-nasal-cannula-flow-rate-1-6-lpm\",\n            \"answer-nasal-cannula-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-nasal-cannula-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-nasal-cannula-target-saturation-gt-90-pct\",\n            \"answer-nasal-cannula-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-non-rebreather-mask-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-flow-rate-10-15-liters-min\",\n            \"answer-non-rebreather-mask-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-non-rebreather-mask-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-target-saturation-gt-90-pct\",\n            \"answer-non-rebreather-mask-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-bvm-ventilation-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what rate will you ventilate the patient?\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n            \"answer-bvm-ventilation-rate-10-12-bpm\",\n            \"answer-bvm-ventilation-rate-other\",\n        ]\n    }, {\n        \"id\": \"prompt-bvm-flow-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What flow rate would you administer?\",\n        \"abbrLabel\": \"Flow rate?\",\n        \"answers\": [\n            \"answer-bvm-flow-rate-15-ltm-or-gt\",\n            \"answer-bvm-flow-rate-other\",\n        ]\n    },{\n        \"id\": \"prompt-bvm-target-saturation\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-bvm-target-saturation-rate-gt-90-pct\",\n            \"answer-bvm-target-saturation-rate-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-tourniquet-placement-close-to-core-far-from-wound\",\n            \"answer-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-2nd-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the second tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-2nd-tourniquet-placement-adjacent-to-initial-tourniquet\",\n            \"answer-2nd-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-occlusive-dressing-injury-type\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-occulsivive-dressing-injury-type-open-pneumothorax\",\n            \"answer-occulsivive-dressing-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-occlusive-dressing-method\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How would you create a release valve on an occlusive dressing?\",\n        \"abbrLabel\": \"How would you create a release valve?\",\n        \"answers\": [\n            \"answer-occulsive-dressing-method-leave-one-side-untaped\",\n            \"answer-occulsive-dressing-method-leave-dressing-with-one-way-valve\",\n            \"answer-occulsive-dressing-method-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-pleural-decompression-injury-type\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-pleural-decompression-injury-type-tension-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-open-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-side-of-the-body\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"On which side of the body would you place the needle?\",\n        \"abbrLabel\": \"Which side would you place the needle?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-right\",\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-left\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-anatomical-landmark\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what anatomical landmark?\",\n        \"abbrLabel\": \"At what anatomical landmark?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-2nd-or-3rd-intercostal-space-mid-clavicular\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-4th-or-5th-intercostal-space-mid-axillary\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-size\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What size needle do you want to use?\",\n        \"abbrLabel\": \"Needle size?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-size-large-bore\",\n            \"answer-pleural-decompression-needle-size-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-length\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How long a needle would you use?\",\n        \"abbrLabel\": \"Needle length?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-length-2-inches-or-longer\",\n            \"answer-pleural-decompression-needle-length-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-transport-facility-choice\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of care facility will you transport the patient to?\",\n        \"abbrLabel\": \"Type of receiving facility\",\n        \"answers\": [\n            \"answer-transport-facility-choice-level-1-or-2-trauma-center\",\n            \"answer-transport-facility-choice-level-3-or-4-trauma-center\",\n            \"answer-transport-facility-choice-closest\",\n            \"answer-transport-facility-choice-other\"\n        ]\n    },{\n        \"id\": \"prompt-transport-method\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you transport this patient by air or ground ambulance?\",\n        \"abbrLabel\": \"Air or ground ambulance?\",\n        \"answers\": [\n            \"answer-transport-method-ambulance\",\n            \"answer-transport-method-helicopter\"\n        ]\n    },{\n        \"id\": \"prompt-transport-lights-siren-decision\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you use lights and sirens with this patient?\",\n        \"abbrLabel\": \"Lights and sirens?\",\n        \"answers\": [\n            \"answer-transport-lights-sirens-yes\",\n            \"answer-transport-lights-sirens-no\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-splint-type\",\n        \"interventionID\": \"intv-splint-fractures\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of splint would you use?\",\n        \"abbrLabel\": \"Type of splint?\",\n        \"answers\": [\n            \"answer-splint-type-board\",\n            \"answer-splint-type-moldable\",\n            \"answer-splint-type-traction\",\n            \"answer-splint-type-pelvic-binder\",\n            \"answer-splint-type-other\"\n        ]\n    },\n\n]\n/*\n    {\n        \"id\": \"\",\n        \"interventionID\": \"\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n        ]\n    },\n*/\nexport default INTV_PROMPTS","const INTV_MENU_ITEMS = [\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-als\",\n        \"label\": \"ALS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-amputation\",\n        \"label\": \"Manage amputation\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-bls\",\n        \"label\": \"BLS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-crico\",\n        \"label\": \"Cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-establish-patency\",\n        \"label\": \"Establish patency\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-insert-adjunct\",\n        \"label\": \"Insert adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-intubation\",\n        \"label\": \"Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-internal-bleeding\",\n        \"label\": \"Manage suspected internal bleeding\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-shock\",\n        \"label\": \"Manage hemorrhagic shock\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-medication-facilitated-intubation\",\n        \"label\": \"Medication Facilitated Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-open-airway\",\n        \"label\": \"Open airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-remove-foreign-body-obstructions\",\n        \"label\": \"Remove foreign body obstructions\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n         \"depth\": 1,\n         \"type\": \"heading\",\n         \"id\": \"heading-severe-external-bleeding\",\n         \"label\": \"Manage severe external bleeding\",\n         intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transfer\",\n        \"label\": \"Transfer patient to EMS vehicle\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transport\",\n        \"label\": \"Transport to care facility\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-advanced-airway-adjunct\",\n        interventionID: \"intv-advanced-airway-adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-airway-patency-technique-suction-airway\",\n        interventionID: \"intv-airway-patency-technique-suction-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-apply-sterile-dressings\",\n        interventionID: \"intv-apply-sterile-dressings\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-back-blows-and-chest-thrusts\",\n        interventionID: \"intv-back-blows-and-chest-thrusts\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-direct-pressure\",\n        interventionID: \"intv-control-severe-bleeding-technique-direct-pressure\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-2nd-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        interventionID: \"intv-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pressure-bandage\",\n        interventionID: \"intv-control-severe-bleeding-technique-pressure-bandage\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-load-and-go\",\n        interventionID: \"intv-control-severe-bleeding-technique-load-and-go\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-keep-patient-warm\",\n        interventionID: \"intv-control-shock-technique-keep-patient-warm\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-high-concentration-o2\",\n        interventionID: \"intv-control-shock-technique-administer-high-concentration-o2\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-place-patient-supine-position\",\n        interventionID: \"intv-control-shock-technique-place-patient-supine-position\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-iv-boluses\",\n        interventionID: \"intv-control-shock-technique-administer-iv-boluses\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-heimlich-maneuver\",\n        interventionID: \"intv-heimlich-maneuver\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-keep-body-part-cool\",\n        interventionID: \"intv-keep-body-part-cool\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-magill-forceps-assisted\",\n        interventionID: \"intv-magill-forceps-assisted\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-manual-finger-sweep\",\n        interventionID: \"intv-manual-finger-sweep\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasopharyngeal-airway\",\n        interventionID: \"intv-nasopharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-needle-cricothyrotomy\",\n        interventionID: \"intv-needle-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-occlusive-dressing\",\n        interventionID: \"intv-occlusive-dressing\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-head-tilt\",\n        interventionID: \"intv-open-airway-method-head-tilt\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-modified-jaw-thrust\",\n        interventionID: \"intv-open-airway-method-modified-jaw-thrust\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-oropharyngeal-airway\",\n        interventionID: \"intv-oropharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-orotracheal-intubation\",\n        interventionID: \"intv-orotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-body-part-in-bag\",\n        interventionID: \"intv-place-body-part-in-bag\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-immobilized-patient-on-stretcher\",\n        interventionID: \"intv-place-immobilized-patient-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-pleural-decompression\",\n        interventionID: \"intv-pleural-decompression\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-pain-nausea-vomiting-medications\",\n        interventionID: \"intv-prepare-and-administer-pain-nausea-vomiting-medications\",\n        intvCategoryID: \"intv-cat-manage-pain-nausea-vomiting\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-sedative\",\n        interventionID: \"intv-prepare-and-administer-sedative\",\n        intvCategoryID: \"intv-cat-sedate-agitated-or-combatitive-patient\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-retrieve-amputated-body-part\",\n        interventionID: \"intv-retrieve-amputated-body-part\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sedation-assisted-intubation\",\n        interventionID: \"intv-sedation-assisted-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-slat\",\n        interventionID: \"intv-slat\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-attach-cid\",\n        interventionID: \"intv-spinal-immobilization-technique-attach-cid\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-cervical-collar\",\n        interventionID: \"intv-spinal-immobilization-technique-cervical-collar\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-manual-c-spine-stabilization\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine2\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-transfer-to-device\",\n        interventionID: \"intv-spinal-immobilization-technique-transfer-to-device\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures2\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sterile-dressing-soft-tissue\",\n        interventionID: \"intv-sterile-dressing-soft-tissue\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-nasal-cannula\",\n        interventionID: \"intv-supplemental-oxygen-device-nasal-cannula\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-non-rebreather-mask\",\n        interventionID: \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-surgical-cricothyrotomy\",\n        interventionID: \"intv-surgical-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-walk-patient\",\n        interventionID: \"intv-transfers-patient-method-walk-patient\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-place-directly-on-stretcher\",\n        interventionID: \"intv-transfers-patient-method-place-directly-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport\",\n        interventionID: \"intv-transport\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport-body-part-to-receiving-facility\",\n        interventionID: \"intv-transport-body-part-to-receiving-facility\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-ventilation-technique-bag-valve-mask\",\n        interventionID: \"intv-ventilation-technique-bag-valve-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-wrap-body-part-in-saline-soaked-gauze\",\n        interventionID: \"intv-wrap-body-part-in-saline-soaked-gauze\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    }\n]\n\nexport default INTV_MENU_ITEMS","import { useEffect, useState } from \"react\"\n\nimport { Link } from \"react-router-dom\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLogs } from \"@meddbriefer/scenario-data/index\"\n\nimport { Table } from \"reactstrap\"\nconst LogList = () => {\n    const [logs, setLogs] = useState([])\n    const [logsLoaded, setLogsLoaded] = useState(false)\n\n    useEffect(\n        () => {\n            getLogs(db)\n            .then(result => {\n                setLogs(result)\n                // console.log(result)\n                setLogsLoaded(true)\n            })\n            .catch(error => console.log('error fetching logs', error))\n        },\n        []\n    )\n\n    if (!logsLoaded) {\n        return (<h4>fetching log data</h4>)\n    }\n    return (\n        <Table striped={true} borderless size=\"sm\" hover>\n            <thead>\n                <tr>\n                    <th>Label</th>\n                    <th>Scenario</th>\n                    <th>Username</th>\n                    <th>Timestamp</th>\n                </tr>\n            </thead>\n            <tbody>\n                {logs.map(log => (\n                    <tr key={log.id}>\n                        <td>{log.label}</td>\n                        <td>{log.scenario}</td>\n                        <td>{log.userName}</td>\n                        <td>{log.timestamp}</td>\n                        <td>\n                            <Link to={`/logs/${log.id}`}>Analyze</Link>&nbsp;&nbsp;&nbsp;&nbsp;\n                            <Link to={`/debriefing-feedback-logs/${log.id}`}>Review</Link>\n                        </td>\n                    </tr>\n                ))}\n            </tbody>\n        </Table>\n    )\n\n}\n\nexport default LogList","\n\n  export const colorTypes = {\n    \"Good\": \"text-success\",\n    \"Caution\": \"text-warning\",\n    \"Problem\": \"text-danger\",\n    \"Not implemented\": \"text-muted\"\n}\n\nexport const iconTypes = {\n    \"Good\": \"sentiment_satisfied\",\n    \"Caution\": \"report_problem\",\n    \"Problem\": \"highlight_off\",\n    \"Not implemented\": \"sentiment_neutral\"\n}\n\n//Feedback substitute commands for feedback template\n//@ means substitute this entry field into the feedback template and if no value in field say this in feedback, \n//? means substitute this entry field into the feedback template if the value exists,\n//+bos adds period to end sentence, two spaces and capitalizes first letter of what follows\n//+eos adds a period with no preceding spaces\n\n//assessmentEntries states are used by analyzeEvents, condition1 and condition2, but the rest is used only by condition 1\nexport const assessmentEntries = {\n    // state: [categorization for feedback, feedback template for condition 1]\n    \"contraindicated\": [\"Problem\", \"You should not have done this action because it is contraindicated in this case +bos ?contraindicatedWhy +eos\"],\n    \"missingMinimal\": [\"Problem\", \"You did not do this action, which is recommended by protocol ?protocol +bos @why +eos\"],\n    \"missingOptional\": [\"Caution\", \"You did not do this action +bos but it was optional in this case according to protocol ?protocol @bos @why +eos\"],\n    \"missingRequired\": [\"Problem\", \"You did not do this action, which is recommended by protocol ?protocol +bos @why +eos\"],\n    \"missingRequiredAssessment\": [\"Problem\", \"You did not do this action. +bos ?assessmentFB +eos\"],\n    \"notNecessary\": [\"Caution\", \"You should not have done this action because it was unnecessary +bos @why +eos\"],\n\n    //note that missing/wrong items cannot be an argument in a misordering of events so there states will not get combined with misOrdered states\n\n    //not yet implemented\n   // \"missedProblem\": [\"Problem\", \"The following should alert you to @problem: +items @problemAssessments\"],  //need to add status and fields to analysis code still and +item formatting below\n \n    \"assessment\": [\"Good\", \"\"],\n    \"assessment-option\": [\"Good\", \"\"],\n    \"decision-option\": [\"Good\", \"\"],\n    \"required-action\": [\"Good\", \"\"],\n    \"standard\": [\"Good\", \"?intvStatusFB +eos \"],\n    \n\n    \"misOrdered-assessment\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-assessment-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-decision-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-required-action\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-standard\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n\n    \"misOrdered-phase-assessment\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-assessment-option\": [\"Good\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-decision-option\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n    \"misOrdered-phase-required-action\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n    \"misOrdered-phase-standard\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n\n    //doubt that status checks can be misordered\n    \"intvCheckWNoIntvFound\": [\"Caution\", \"You didn't do this intervention so it doesn't make sense to check the status of it at this point.\"],\n    \"unexpectedPatientIntvCheck\": [\"Caution\", \"This status check is not likely to reveal any useful information.\"],  //nothing indicates a need to check that this intv worked\n    \"patientIntvCheck\": [\"Good\", \"\"], //as long as the intervention was done it is fine to request it\n    \"patientVitalCheck\": [\"Good\", \"\"],  //currently any patient vital check that is done is fine\n\n\n    \"assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],  \n    \"incorrect-answers\": [\"Problem\", \"Doing this action is correct but there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal-incorrect-answers\": [\"Problem\", \"Doing this action was correct and would solve the problem but you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do this intervention +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal\": [\"Caution\", \"Doing this action is correct and solves the problem but you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos \"],\n\n   \n    \"misOrdered-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos\"],\n        \n    \n    \"misOrdered-phase-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-incorrect-answers\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos\"],\n    \n    \"green\": [\"Good\", \"\"],  //just for headers\n    \"red\": [\"Problem\", \"\"], //just for headers\n    \"yellow\": [\"Caution\", \"\"], //just for headers\n    //\"notFound\": [\"Not implemented\", \"Assessment knowledge is not yet specified\", []],\n    \"default\": [\"Not implemented\", \"This action was not expected.  There could be an issue with how this scenario is represented within the system.\"]\n}\n","export const phaseStatusList = {\n    absent: [\"missingMinimal\", \"missingOptional\", \"missingRequired\", \"missingRequiredAssessment\"],\n    errors: [\"misOrdered-assessment\", \"misOrdered-assessment-option\", \"misOrdered-decision-option\", \"misOrdered-required-action\", \"misOrdered-standard\",\n    \"contraindicated\", \"intvCheckWNoIntvFound\", \"unexpectedPatientIntvCheck\", \n    \"assessment-option-incorrect\", \"decision-option-incorrect\", \"incorrect-answers\", \"minimal-incorrect-answers\", //\"minimal\", \n    \"misOrdered-assessment-option-incorrect\", \"misOrdered-decision-option-incorrect\", \"misOrdered-incorrect-answers\", \"misOrdered-minimal-incorrect-answers\",\n    \"misOrdered-minimal\", \"notNecessary\",\n    \"default\",\n    \"misOrdered-phase-assessment-option-incorrect\", \"misOrdered-phase-decision-option-incorrect\", \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\", //\"misOrdered-phase-minimal\"\n        ],\n    good: [\"assessment\", \"assessment-option\", \"decision-option\", \"required-action\", \"standard\", \n        \"patientIntvCheck\", \"patientVitalCheck\",\n        //condition 2 does not need to address minimal as an error nor misordered-phase as that error appears as misordered at the phase or subphase level\n        //condition 1 uses misOrdered-Phase as that error feedback goes on the first line in the phase/subphase\n        //so without misOrdered-phase and/or minimal, these are good status values\n        \"minimal\", \"misOrdered-phase-minimal\",\n        \"misOrdered-phase-assessment\", \"misOrdered-phase-assessment-option\", \"misOrdered-phase-decision-option\", \"misOrdered-phase-required-action\", \"misOrdered-phase-standard\",\n        ]  \n}\n\n","// defines which assessment steps are not required per scenario.  Provides feedback on\n// why the step is not required.\nexport const exceptionDefs = \n[{scenarioName: \"M2CA\", exceptions: [\n    [\"required-action-obtain-OPQRST\", \"This cannot be assessed when GCS < 15\"],\n    [\"assess-opqrst-info\", \"This cannot be assessed when GCS < 15\"]\n    ]}\n  ]\n  \n/* This starts section on defining temporal constraints, conditional constraints and implications.*/\n\n/*temporal constraints are an\nindex of event labels with two lists as values.\nThe first value is a list of event labels that the indexed event\nshould precede (if any) and the second value is a list of event\nlabels that the indexed event should follow after (if any)\n*/\n\nexport const globalConstraints = {\n    // event < list of other events, > list of other events\n    // lookup by event id to see the list of event ids that it should go before\n    // and after, and the type of constraint. \n    // included constraints type with values of policy, commonSense and both.  These may be used in future to\n    // decide any lead in to feedback about a constraint violation\n    // type policy operators are usually \"ands\", type commonsense operators are ususally \"ors\" because\n    // the ordering is looser than with policy ordering.  An operator can be blank if only one item is listed for the\n    // before or for the after.  No software should be written to expect\n    // this tendency between type and operators to hold.\n\n    //Note that: \n    //- for now the software will use either the label or id to lookup constraints but id\n    // is preferred.\n    //- a key (first item on each line) is the first arg in the constraints and is\n    //  assumed to have just one constraint applicable to\n    //  it but may appear as the second arg in a constraint multiple times (2nd args are\n    //  lists under before or after fields)\n    //- when something is a phase or subphase with multiple actions then we look for the begining\n    //  and ending actions for constraint checking.  If overlap in phases is to be allowed the constraint should\n    //  be amongst lower level items and no higher level constraint should be included\n    //= there is no check to make sure the constraints expressed do not conflict.  For example,\n    //  saying a whole phase should be before another phase and that a particular item in the second\n    //  phase can go before some other item in the first phase are in conflict with one another\n\n\n    // Note: looks like I may need to allow multiple constraints to be listed under an arg1 key.  Shouldn't be\n    // difficult to do but waiting to see if it is truly necessary first.  While most constraints for arg1 could\n    // be combined in the list below, there is an issue with adding in scenario specific conditional constraints\n    // that are expressed in a different structure.\n\n    //\"\": {id: \"T\", before: [\"\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \n    // T1\n    \"scene-size-up\": {id: \"T1\", before: [\"primary-survey\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T2\n    \"primary-survey\": {id: \"T2a\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    //listing the below any intervention that I think are always going to address a life threat\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"T2b\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {id: \"T2c\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {id: \"T2d\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T3\n    \"ints-call-for-helicopter\": {id: \"T3\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T4\n    \"required-action-obtains-vitals\": {id: \"T4\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T5\n    \"required-action-attempt-obtain-sample\": {id: \"T5a\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"required-action-obtain-OPQRST\": {id: \"T5b\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T6 is in scenario specific constraints\n    // T7\n    \"intv-transfer\": {id: \"T7\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\", \"breathing\", \"circulation\"], afterOp: \"\", type: \"policy\"},\n    // T8\n    \"trauma-expose\": {id: \"T8\", before: [\"chest\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T9\n    \"general-impression\": {id: \"T9\", before: [\"airway\", \"breathing\", \"circulation\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    // T10\n    \"intv-spinal-immobilization-technique-manual-c-spine\": {id: \"T10a\", before: [\"airway\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-spinal-immobilization-technique-cervical-collar\": {id: \"T10b\", before: [\"airway\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T11 was deleted per discussion with Sandy\n    // T12 is in scenario specific constraints\n    // T13\n    \"intv-airway-patency-technique-suction-airway\": {id: \"T13\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\"], afterOp: \"\", type: \"policy\"},\n    // T14\n    \"intv-airway-patency-technique-suction-airway\": {id: \"T14\", before: [\"intv-oropharyngeal-airway\", \"intv-nasopharyngeal-airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T15\n    \"intv-oropharyngeal-airway\": {id: \"T15a\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \n                                  \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-nasopharyngeal-airway\": {id: \"T15b\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \n                                  \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T16 awaiting observer interface implementation decisions on how contacting medical command will be recorded\n    // T17\n    \"intv-ventilation-technique-bag-valve-mask\": {id: \"T17\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T18 and T19 are constraints involving intervention checks and need to be discussed in a group meeting\n    \n    //used during testing\n    //state that ongoing management plan should go after the entirety of everything listed in after\n    //\"ongoing-mgmt-plan\": {id: \"c2\", before: [ ], beforeOp: \"\", after: [\"bsi\", \"scene-size-up\", \"primary-survey\", \"history-taking\",\"secondary-assessment\"], afterOp: \"and\", type: \"commonSense\"},\n    // have two second args in below because some of Observer logs have one of these ids and some have the other\n    //\"assess-injury-mechanism\": {id: \"c7\", before: [\"required-action-consider-stabilization-of-spine\", \"required-action-considers-stabilize-spine\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"commonSense\"},\n    //\"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"c8\", before: [\"intv-control-severe-bleeding-technique-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n    //\"intv-control-severe-bleeding-technique-tourniquet\": {id: \"c9\", before: [\"intv-control-severe-bleeding-technique-2nd-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n     \n}\n\n//constraints that depend on whether certain conditions hold within a scenario\n//based on the scenario and the constraint ids listed under the scenario in\n//scenarioConstraintIDs, the constaints defined here with the ids for the current\n//scenario will be added to the general constraints about for temporal constraint testing\n\n// Used convention of appended -c and a one up number just to indicate it is a conditional constraint.  No software\n// requires this convention for the ids so it can be changed\n\nexport const conditionalConstraints = {\n    // first is a hold over from testing for M2CA\n    \"assess-major-bleeding\": {id: \"c1\", before: [\"airway\",\"breathing\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-transport\" : {id: \"T2-c1\", before: [\"into-establish-IV\", \"intv-control-shock-technique-administer-iv-boluses\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"}, \n    \"secondary-assessment\": {id: \"T6-c1\", before: [\"intv-transfer\", \"ongoing-mgmt-plan\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"pulse-checks\": {id: \"T12-c1\", before: [\"airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"}\n    \n    \n}\n\n\n// used to simulate conditional constraints, i.e. we hardcode which conditional constraint ids as\n// defined under conditionalConstraints (above) are relevant to each scenario\n\n// although one could put global constraint ids under scenarios here, it would be redundant and may cause software\n// issues\nexport const scenarioConstraintIDs = {\n    \"M2CA\": [\"c1\", \"T6-c1\"],\n    \"B4CA\": [],\n    \"B7CA\": [],\n    \"SC8CP\": [\"T2-c1\",\"T6-c1\", \"T12-c1\"],\n    //\"\": [],\n    //\"\": []\n}\n\n\n//below are examples of interventions in which status should be checked.  The key intvStatusNeeded\n//is true or false.  If true it means should have requested status of this intervention.  If vitals key is\n//not empty then should have checked all of these vitals as well.  Will only check entries after an intervention\n//up until something other than an intervention check is done\n\n//updates wrt SC8CP-combined-goals-4-4\nexport const intvChecks = {\n    \"intv-nasopharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-oropharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-orotracheal-intubation\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-ventilation-technique-bag-valve-mask\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\" ]},\n    \"intv-sedation-assisted-intubation\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\"]},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},\n    //test cases for now.  First 3 are likely to become relevant for scenarios like M2CA\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []}, \n    //\"intv-control-shock-technique-administer-iv-boluses\": {intvStatusNeeded: false, vitalsNeeded: [\"BP\"]},\n        \n    }\n\n","import { formatAsMinSecs } from \"../utils\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport {colorTypes, iconTypes, assessmentEntries, phaseStatusList} from \"@meddbriefer/feedback-data\"\nimport { scenarioConstraintIDs, conditionalConstraints, globalConstraints } from \"@meddbriefer/feedback-data\"\n\n   \nexport const pushNew = (elt,array) => {\n    if (!array.includes(elt)) {\n        array.push(elt)\n    }\n}\n\nexport const getPhaseStatus = (statuses) => {\n    //for collecting first unique item statuses and then\n    //unique phase statuses\n    let itemStatuses = []\n    let phaseStatuses = []\n\n    //get a unique list of item status values\n    statuses.forEach(status => {\n        pushNew(status,itemStatuses)\n        /* if (!itemStatuses.includes(status)){\n            itemStatuses.push(status)\n        } */\n    })\n    \n    //turn the item status values into phase level status values\n    let res\n    for (const [key, val] of Object.entries(phaseStatusList)) {\n        res = val.filter(value => itemStatuses.includes(value))\n        //if there is an intersection, save the key (i.e. is unique)\n        if (res.length !== 0)\n            pushNew(key,phaseStatuses)\n            /* if (!phaseStatuses.includes(key)){\n                phaseStatuses.push(key)} */\n        }\n\n    if (phaseStatuses.length === 1){return phaseStatuses[0]}  // to be absent or good, all entries must be good or absent\n    else {return \"errors\"}  //otherwise they are not all good to that translates to errors\n       \n    }\n\n\n\n// functions that extract info from above or create the feedback from the above \n\n//returns a list of all the state values associated with the input status (e.g. status is one of \"Problem\", \"Good\", \"Caution\")\nexport const getStatesForStatus = (status) => {\n    let stateList = []\n    for (const [state, entry] of Object.entries(assessmentEntries)) {\n        let stateStatus = entry[0]\n        if (stateStatus === status){\n            stateList.push(state)}\n        }\n    //console.log(\"In getStatesForStatus\", stateList)\n    return (stateList)}\n        \n\n//returns the entry under that state\nconst getAssessmentEntry = (currentEntry,aIndex) => {\n    let assessmentEntry = \"\"\n    if (currentEntry.type === \"header\"){\n        assessmentEntry = assessmentEntries[currentEntry.displayColor] \n        if (!assessmentEntry) {assessmentEntry = assessmentEntries[currentEntry.status]}\n    }\n    else{\n        if (!assessmentEntries[currentEntry.status]){\n            assessmentEntry = assessmentEntries[\"default\"]}\n        else{assessmentEntry = assessmentEntries[currentEntry.status]}}\n    if (assessmentEntry){\n        return assessmentEntry[aIndex]}\n}\n\n//returns the html icon to use in condition 1 for the state\nexport const getAssessmentIcon = (currentEntry) => {  \n    let val = iconTypes[getAssessmentEntry(currentEntry,0)]\n    return val;\n}\n\n//returns the html color to use in condition 1 for the state\nexport const getColor = (currentEntry) => {\n    return colorTypes[getAssessmentEntry(currentEntry,0)];\n}\n\n//add protexted spaces after a . except for the very last .  \n//Otherwise html reduces continguous regular spaces to a single space.\n//Need this for text strings that will appear in one array entry because\n//of substitution\nconst fixStrSp = (textString) => {\n    if (!!textString){\n        let textArray = textString.split(\" \");\n        let lenTextArray = textArray.length;\n        textArray.forEach((item, i) => {\n            let newItem = item.trim()\n            if (newItem[item.length-1] === \".\" && i < lenTextArray-1){\n                //add protected space to the string\n                newItem = newItem + \"\\xa0\\xa0\"}\n            textArray[i] = newItem \n        })\n        let newString\n        for (let item of textArray){\n            if (!!newString){\n            newString = newString + \" \" + item;}\n            else{newString = item}\n\n     }\n        //console.log(newString, textArray)\n        return newString}\n    else {return \"\"}\n}\n\nconst generateIntvStatusFB = (currentEntry) => {\n    let checked = []\n    let notChecked = []\n    let fb\n    for (let entry of currentEntry.intvStatus){\n        if (entry.foundCk){\n            checked.push(entry.label)}\n        else {notChecked.push(entry.label)}\n    }\n    if (notChecked.length > 0){\n        fb = \"Remember to check the effect of this action by asking for: \" + notChecked + \".\"\n        if (checked.length > 0){\n            fb = fb + \" That is in addition to what you did ask for: \" + checked + \".\"\n        }\n    }\n    return fb\n}\n\n\n\n\nexport const getFeedback = (currentEntry) => {\n    if (!!currentEntry.intvStatus && currentEntry.intvStatus.length > 0){\n        //add our generated feedback string to the currentEntry\n        currentEntry.intvStatusFB = generateIntvStatusFB(currentEntry)\n    }\n    let feedbackTemplate = fixStrSp(getAssessmentEntry(currentEntry,1)).trim()\n    //Find any @ actions in the template and substitute with the indicated entry field\n    let feedbackArray = feedbackTemplate.split(\" \");\n    //Process all @ substitutions first since +eos does one forward action\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let newString = item.substring(1)\n        //trim off excess blanks before and after each word\n        feedbackArray[i] = feedbackArray[i].trim()\n        switch(firstChar){\n            case \"@\":\n                if (!!currentEntry[newString])\n                    //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"[value for \" + newString + \" is missing]\" }\n                break\n            case \"?\":\n                if (!!currentEntry[newString])\n                //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"\"  \n                    if (feedbackArray[i-1]  === \"+bos\"){feedbackArray[i-1] = \"\"}\n                    if (feedbackArray[i+1]  === \"+eos\"){feedbackArray[i+1] = \"\"}\n                }\n                break  \n            default:\n        }\n    })\n    //Now address the + actions in the template\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let previousString = \"\"\n        switch(firstChar){\n        case \"+\":\n            let afterPlusChar = item.substring(1)\n            switch(afterPlusChar){\n            case \"eos\":\n                //removes existing/redundant . if present so can be certain putting in single . \n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence and a protected space.  When stiched back into\n                //a single string a protected space will be added between each substring\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\"  //get rid of the command since was applied\n                break\n            case \"bos\":\n                //removes existing/redundant . if present so can put in single .\n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence .\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\" //get rid of the command since was applied\n                //Captitalize the beginning of the sentence\n                let nextString = feedbackArray[i+1].trim()\n                feedbackArray[i+1] = nextString.charAt(0).toUpperCase() + nextString.slice(1);\n                break\n            default:\n            }\n            break\n        default:\n    }}\n    )\n    //stitch back into a single string\n    let feedbackString\n    for (let item of feedbackArray){\n        if (!!feedbackString) {\n            if (item !== \"\"){\n                feedbackString = feedbackString + \"\\xa0\" + item;}} \n        else {if (item !== \"\"){feedbackString = item}}\n    }\n    //console.log(feedbackString)\n    return feedbackString\n}\n\n//built by the function initializeConstraints\nvar scenarioConstraints = {}\n\n// adds on scenario specific constraints where the constraint is only applicable if certain patient\n// conditions hold.  Since assessment callouts are text and have no associated representation, we\n// can yet implement true conditional constraints.\nexport const initializeConstraints = (scenarioName) => {\n    // look up applicable conditional constraints from const structure scenarioConstraintIDs \n    let constraintIDs = scenarioConstraintIDs[scenarioName] \n    scenarioConstraints = globalConstraints\n    for (const [key, val] of Object.entries(conditionalConstraints)) {\n            if (constraintIDs.includes(val.id)){\n                scenarioConstraints[key] = val\n            }\n        }\n}\n\n\n\n//gets one constraint since each id/label would be a key\n//in the constraints definitions\nexport const getConstraint = (item) => {\n    let id = item.id\n    let label = item.label\n    let constraints = scenarioConstraints[id] \n    if (!constraints){constraints = scenarioConstraints[label]}\n    return constraints \n}\n\n\n// This section is for looking up items in the analysis log\n\nexport const getEvents = (events,field,val) => {\n    return events.filter(entry => entry[field] === val)\n}\n\nexport const getEventsByIdTime = (events,id,timestamp) => {\n    return getEvents(getEvents(events,\"timestamp\",timestamp),\"id\",id)\n}\n\n// This ends the section for looking up items in the analysis log\n\n\n\n//This starts section for saving/loading the debriefing log\n    \nconst _ = require(\"lodash\"); \n\nexport const saveAnalysisLog = (log, actions, hierAssessResults, hierProblemResults, constraintsViolated) => {\n    console.log(\"In savingDebriefingLog\")\n    const docRef = db.collection(\"debriefing-feedback-logs\").doc(log.id)\n    let data = {\n        userName: log.userName,\n        ObserverFileCreater: log.userName,\n        label: log.label,\n        ObserverFileName: log.label,\n        commenter: \"\",\n        scenarioID: log.scenarioID,\n        scenarioName: log.scenarioName,\n        schemaVersion: log.schemaVersion,\n        timestamp: Date().toLocaleString(),\n        hierAssessResults: hierAssessResults,\n        hierProblemResults: hierProblemResults,\n        constraintsViolated: constraintsViolated\n    }\n\n    let newActionsList = [];\n    let newObj = {};\n    let filterUnknown = false;\n\n    //included for debugging puposes only\n    actions.forEach(function (logObj, index){\n        for (let [key, val] of Object.entries(logObj)) {\n            if (undefined === val) {\n                console.log(\"filtered out from events; index: \", index, \" key: \", key, \" value: \", val)\n                filterUnknown = true;}\n             }\n        }\n    )\n        \n    if (filterUnknown) {\n        actions.forEach(function (logObj, index) {\n            newObj = _.pickBy(logObj, function (value, key) {\n                return !(value === undefined);\n            });\n            newActionsList.push(newObj)\n        })\n        data[\"events\"] = newActionsList\n    }\n    else (data[\"events\"] = actions);\n\n\n    //data[\"events\"] = formattedActions;\n    //console.log(JSON.stringify(data, null, 4))\n    docRef.set(data) \n}\n\n//not in use\n\nexport const retrieveDebriefing = (log) => { \n    //console.log(log.events) \n    return (log.events)  \n}  \n\n//This ends section for saving/loading the debriefing log\n\n\n\nexport const getTimestamp = (currentEntry) => {\n    if (currentEntry.status === \"criticalActionHeader\") {\n        return \"\";\n    }\n    if (currentEntry.timestamp === -1) {\n        return \"\\xa0\\xa0\";  // formatAsMinSecs would convert this to 59:59\n    }\n    return formatAsMinSecs(currentEntry.timestamp);\n}\n\n\n","import { MDB_TYPES, ANALYSIS_TYPES } from '@meddbriefer/scenario-data/constants.js';\nimport { getPhaseStatus, initializeConstraints, getConstraint, getStatesForStatus, saveAnalysisLog, getEventsByIdTime, //pushNew\n} from \"./debriefingUtils\"\nimport { intvChecks, exceptionDefs } from \"@meddbriefer/feedback-data/analysisData\"\nimport { getChecklistItemsByType, getChecklistHierarchy, groupByKey } from './scenarioDataAccesors';\nimport { summarizeAnalysis } from './summarizeAnalysis';\n//import { foo } from \"@meddbriefer/feedback-data\"\n\n//console.log(foo())\n\nconst problemStates = getStatesForStatus(\"Problem\")\nconst cautionStates = getStatesForStatus(\"Caution\")\nlet hierAssessResults \nlet hierProblemResults \nlet constraintsViolated \nlet insertInterventionHeader = false  //setting to true helps during debugging analysis, shows headers for problems\n//index of subphase names and value is phase id to which belongs\nlet subPhases = {}\n// list of all subphase IDs\nlet requiredSubphases\nlet requiredPhaseNames\nlet requiredPhaseAndSubPhases\nlet scenario\nexport var itemByID\nexport var itemByLabel\n// sts 1/23/22 - added as global\nlet checklistHierarchy\n\nfunction initGlobals(scen) {\n    scenario = scen\n    initializeConstraints(scen.name)\n    itemByID = initializeItemLookupByID(scen)\n    itemByLabel = initializeItemLookupByLabel(scen)\n    requiredPhaseNames = getChecklistItemsByType(scen, MDB_TYPES.PHASE).map(e => e.id).concat([\"Unknown\"])\n    requiredSubphases = getChecklistItemsByType(scen, MDB_TYPES.SUB_PHASE).map(e => e.id)\n    checklistHierarchy = getChecklistHierarchy(scen)\n    requiredPhaseAndSubPhases = findPhaseSubphasesOrdered(checklistHierarchy)\n    checklistHierarchy.forEach(ph => {\n        if (undefined === ph.subPhases) {\n            subPhases[ph.id] = ph.label} \n        else {\n            ph.subPhases.forEach(sp => {\n                subPhases[sp.id] = ph.label})}})\n    subPhases[\"Unknown\"] = \"Unknown\"\n    hierAssessResults = {}\n    hierProblemResults = {}\n    constraintsViolated = []\n}\n\n//This starts section for accessing checklist and intervention components by id or label\nconst initializeItemLookupByID = (scenario) => {\n    let checklistLookupByID = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let intvLookupByID = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let result = Object.assign(checklistLookupByID, intvLookupByID)\n    return result}\n\nconst initializeItemLookupByLabel = (scenario) => {\n        let checklistLookupByLabel = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let intvLookupByLabel = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let result = Object.assign(checklistLookupByLabel, intvLookupByLabel)\n        return result}\n\n\nconst findPhaseSubphasesOrdered = (phases) => {\n    let result = []\n    phases.forEach(ph => {\n        if (!!ph.subPhases){\n            let subPhIds = ph.subPhases.map(e => e.id)\n            //not currently useful to collect parent phases unless there were no subphases\n            //if parent phase included subphases and steps then it should be in this result\n            //result = result.concat(ph.id)\n            result = result.concat(subPhIds)\n        }\n        else {result = result.concat(ph.id)}})\n    return result\n}\n\nconst collectScenAssessments = (problems) => {\n    let assessments = []\n    problems.forEach(prob => {\n        if (prob.assessments !== \"\"){\n            assessments = assessments.concat(prob.assessments)}})\n    return assessments\n}\n\n//will need to update to comply with any relevant constraints on phases and subphases\n//currently looks for missing phases/subphases and inserts them into the analysis list\n//based on where last preceding phase appeared\nconst insertMissingSubphases = (phases,phaseNames) => {\n    let priorPh\n    requiredPhaseAndSubPhases.forEach((phase, i) => {\n        if (!phaseNames.includes(phase)) {\n            //find last index for phase before and splice that    \n            if (i === 0){\n                priorPh = requiredPhaseAndSubPhases[0]\n            }\n            else {priorPh = requiredPhaseAndSubPhases[i-1]}\n\n            let insertionIndex = 0\n            if (priorPh !== phase){\n                insertionIndex = phaseNames.lastIndexOf(priorPh)  //if prior phase was missing it will have been inserted earlier\n                insertionIndex = insertionIndex + 1}\n            \n            phaseNames.splice(insertionIndex, 0, phase); //insert it where it should have appeared\n            phases.splice(insertionIndex, 0, []); //add the empty array for phase objects\n        }});\n    return[phases,phaseNames]\n}\n\n\n//as vital requests and intervention requests are made, update that it was requested\n//if it is one that we are tracking for post intervention success.  \nconst updateVital = (vitalEntries, timestamp) => {\n    let updatedEntries = []\n    vitalEntries.forEach(vitalEntry => {\n        if (vitalEntry.timestamp < timestamp){\n            vitalEntry[\"foundCk\"] = true}\n        updatedEntries.push(vitalEntry)\n    })\nreturn updatedEntries\n}\n\n//initial review of observer log to add annotations to what was found in the observer log.  Filters out things not useful to\n//analysis or is not yet being analyzed in the codep.  It also\n// pulls together interventions and prompt answers into one event and adds fields to each event that will fill in in later analysis,\n// fills in problem information for interventions found in observer log and\n// sets up the phases and phaseNames structures for events in the observation log and initiates\n// record of what have encountered so far in the observations in order to recognize what is missing in later stages of analysis\nconst annotateInputEvents = (events,problems) => {\n    let confirmedEvents = [];\n    let interventionsConfirmed = [];  //needed for vital checking\n    //instead of a multi-dimensional array, am using an array of phase and subphase names e.g. \"BSI\", \"prinary\" ...\n    let phaseNames = [];\n    let phases = []; //and another array with the actual content for each phase.  I can search phaseNames for the index into phases\n    let phaseObjects = [];\n    let trackForStatus = {};  //save correct interventions that were done that require status checks later\n    \n\n    // phases entry of that name and then use that index to retrieve the appropriate phase entried to\n    //add on the missing items (assessment or intervention) for that phase\n    let priorPhase = \"\";\n    let parentPhase = \"\"\n    let parentIndex = 0\n    let phaseIndex = 0;\n    let newPhaseStart = true\n    let assessmentTypes = [\"assessment\", \"required-action\", \"decision-option\", \"assessment-option\"]\n\n    // created annotated object for each event\n    events.forEach((event, i) => {\n        // Each eventObj is one of the lines in the displayed base log\n        // Set up fields for extra annotations for this event after analyzing each event\n        let eventObj = {\n            \"comment\": \"\",\n            \"numericalID\": i,\n            \"status\": \"\",\n            \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n            \"contraindicatedWhy\": \"\",\n            \"minimalWhy\": \"\",\n            \"why\": \"\",\n            \"answerCorrect\": true,\n            \"answerDetails\": {},\n            \"expertPhase\": \"\",  //filled in only for interventions\n            \"workingPhase\": \"\",  //is subphase of phase if there is no subphase\n            \"suggestedPhase\": \"\", //mostly for interventions so don't override info on when was originally done\n            \"protocol\": \"\",\n            \"probLabel\": \"\",\n            \"assessments\": \"\",\n            \"required\": false,\n            \"actionDescription\": \"\",\n            \"assessmentFB\": \"\",\n            \"incorrectAnswersFB\": \"\",\n            \"orderingFB\": \"\",\n            \"processingState\": \"good\" // values of good/bad used to filter out events not needed for analysis or displaying\n        };\n\n        // copy over the event fields that exist in the input log from observer UI (which is type dependent)\n        const EVENT_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"vitalType\", \"vital\", \"value\", \"type\", \"prompt\", \"promptID\", \"intervention\", \"timestamp\"];\n        EVENT_FIELDS.forEach(fldName => {\n            if (!!event[fldName]) {\n                eventObj[fldName] = event[fldName];\n            }\n        });\n\n        //copy event fields if defined to initialize some of the above annotation fields\n        if (!!event.label) { eventObj.actionDescription = event.label; }\n        if (!!event.type) { eventObj.status = event.type; }\n        // prefer subPhase if available\n        if (!!event.subPhase) { eventObj.workingPhase = event.subPhase; }\n        else {\n            if (!!event.phase) { eventObj.workingPhase = event.phase; }}\n        eventObj.expertPhase = eventObj.workingPhase;\n\n        //if current phase same as prior then keep on with the current phase\n        // otherwise initialize for a new phase but don' let an intervention\n        // or intervention answer set a new phase since this info in event is\n        // not reliable  \n            \n        if (priorPhase !== eventObj.workingPhase || parentPhase !== eventObj.phase){ \n            if (priorPhase !== \"\" && assessmentTypes.includes(eventObj.type)) {  \n                //have a non initial phase change and we have an assessment type (i.e. we can't base phase changes on interventions)\n                newPhaseStart = true\n                phases[phaseIndex] = phaseObjects;\n                if (phaseIndex !== parentIndex){\n                    phases[parentIndex] = phases[parentIndex].concat(phaseObjects);  \n                }\n                phaseIndex++\n                \n                //if upcoming parent phase is different than current parent phase then set up\n                //for a new parent phase\n                if (eventObj.phase !== parentPhase){ \n                    parentPhase = eventObj.phase\n                    parentIndex = phaseIndex\n                    // if the upcoming is truly a parent with subphases \n                    // then add an extra entry for the new parent phase \n                    if (eventObj.phase !== eventObj.workingPhase) {\n                        //create the new parent phase\n                        phases[parentIndex] = []\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++\n                    }}}\n            else {\n                if (priorPhase === \"\" && assessmentTypes.includes(eventObj.type)){\n                // first item in events so initialize\n                    parentPhase = eventObj.phase\n                    // if the event parent phase is not the same as the subPhase\n                    // then we need to save that parent phase in phases and phaseNames\n                    if (parentPhase !== eventObj.workingPhase) {\n                        parentPhase = eventObj.phase\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++;}}\n                \n                else{ \n                    if (priorPhase === \"\"){\n                        //did an intervention before doing any assessments\n                        //so make up an initial phase of unknown\n                        parentPhase = \"Unknown\"\n                        eventObj.workingPhase = parentPhase\n                        eventObj.phase = parentPhase\n                        eventObj.subPhase = \"\" }\n                    else {newPhaseStart = false}}}\n\n                \n            \n            //now setup for collecting for the current phase if not skipping new phase start\n            if(newPhaseStart){\n                priorPhase = eventObj.workingPhase;\n                phaseObjects = [];\n                phaseNames[phaseIndex] = priorPhase;\n                phases[phaseIndex] = []}\n            else {newPhaseStart = true}\n            }\n        \n\n        let eventType = eventObj.type;\n        // List of types in log that are currently processed.  Rest are filtered out.\n        let processedTypes = [\"assessment\", \"required-action\", \"intervention\", \"answer\", \"obtain-vital-sign\", \"decision-option\", \"assessment-option\"];\n\n        //skip over adding anything not of these types to the debriefing display for now\n        if (!processedTypes.includes(eventType)) {\n            eventObj.processingState = \"bad\";\n        }\n\n        // when get an answer for an intervention prompt, grade the response.  The intervention itself is later in the event log, so\n        // accumulate the answers and grading and then when an intervention is later found we can use the intervention\n        // event itself and move all the answer results into it\n        let prioreventObj = [];\n        if (eventType === \"answer\") {\n            //make sure we have answer info for this promptID\n            let correctAnswerLabel = getCorrectAnswerLabel(event.promptID, true);\n            let givenAnswerLabel = getAnswerLabel(event.id, true);\n            //if we don't have answer info for this prompt ID then just ignore this entry\n            if (!correctAnswerLabel) {\n                eventObj.processingState = \"bad\"}\n            else {\n                //currently returns correct answer-id if has answered incorrectly or false if answered correctly\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, true);\n                //store details of this answer and its grading\n                let answerDetails = {\"correctAnswer\": correctAnswerLabel, \"givenAnswer\": givenAnswerLabel, \"correct\": !wrongAnswer}\n                \n                //have answer to prior question for this intervention \n                //(i.e. there is more than one question associated with this intervention)\n                if (confirmedEvents.includes(eventObj.intervention)) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    //add the answer student gave to the action description\n                    eventObj.actionDescription = prioreventObj.actionDescription + \", \" + givenAnswerLabel;\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        if (prioreventObj.incorrectAnswersFB === \"\") {\n                            eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                            }\n                        else {eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB + \", and \" + correctAnswerLabel;\n                            }}\n                    else {\n                        eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                        eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    }}\n                //first answer for this intervention\n                else { \n                    //put the answer student gave in the action description\n                    //responding to first question for the intervention\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                    }\n                    else { eventObj.incorrectAnswersFB = \"\"; }\n                    //pushNew(eventObj.intervention,confirmedEvents)\n                    confirmedEvents.push(eventObj.intervention)\n                }\n                //storing the prompt/answer details \n                eventObj.answerDetails[event.promptID] = answerDetails}}\n\n        if (eventType === \"intervention\") {\n            prioreventObj = phaseObjects.slice(-1)[0]; //slice returns an array rather than the last object in array\n            //check to find if prior phaseObjects contains an answer and if it does then consolidate that answer\n            //event into the associated intervention\n            if (prioreventObj && prioreventObj.type === \"answer\"){\n                if (prioreventObj.intervention === eventObj.id) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                    eventObj.actionDescription = eventObj.actionDescription + \".\\xa0\\xa0\" + prioreventObj.actionDescription}\n                else {\n                    prioreventObj = phaseObjects.pop();  //discard this answer, it is for an intervention that was not done\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                 }}\n        }\n\n        if (eventObj.processingState === \"good\") {\n\n            if (eventObj.type === \"obtain-vital-sign\"){\n                //if it is an intervention status check then the vital field contains\n                //the intervention id and otherwise the vital label\n                let vital = eventObj.vital \n                let type = \"\"\n                if (eventObj.vitalType === \"intervention-status\"){\n                    if (interventionsConfirmed.includes(vital)){\n                        type = \"intv\"}\n                    else {type = \"noIntv\"}\n                    }\n                else {type = \"vital\"}\n                \n                //update trackForStatus relative to this \"vital\"\n                let vitalEntry = trackForStatus[vital]  \n                //set the status for this particular vital (i.e. makes sense to ask for it or not)\n                switch (type){\n                    case \"intv\": \n                        eventObj.status = \"patientIntvCheck\"\n                        if (vitalEntry && (vitalEntry.timestamp < eventObj.timestamp)){\n                            vitalEntry[\"foundCk\"] = true\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    case \"noIntv\":\n                        eventObj.status = \"intvCheckWNoIntvFound\"\n                        break\n                    case \"vital\":\n                        eventObj.status = \"patientVitalCheck\" \n                        if (vitalEntry){\n                            vitalEntry = updateVital(vitalEntry,eventObj.timestamp)\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    default: eventObj.status = \"unexpectedPatientIntvCheck\"}\n\n\n                    \n            }\n            // add additional annotations per type\n            if (eventObj.type === \"intervention\") {\n                // iterate through all problem actions looking how to format the\n                // data structue for the current \"event\"\n                problems.forEach((prob, j) => {\n                    // We're going through things in the order standard, contraindicated since\n                    // it is possible but unlikely to have multiple matches and we want the last one to win.\n                    // Also, we are assuming minimal is always a subset of standard\n                    const PROBLEM_ACTION_FIELDS = [\"why\", \"probLabel\"];\n                    \n\n                    // check for this action to be an intervention for a problem\n                    prob.actions?.forEach((action, k) => {\n                        if (action.id === eventObj.id) {\n                            //see if this is an event whose status should be checked by the student\n                            //and initialize its tracking.  Not yet limiting to event id when\n                            //defining what needs to be tracked in the structure intvChecks\n                            //so also checking event label\n                            let statusChecking  //the entry retrieve from intvChecks\n                            let intv = eventObj.id\n                            statusChecking = intvChecks[eventObj.label]\n                            if (!statusChecking){\n                                statusChecking = intvChecks[eventObj.id]}\n\n                            if (!!statusChecking){\n                                let initialEntry = {\"intervention\": intv, \"timestamp\": eventObj.timestamp, \"foundCk\": false}\n                                //put the intervention on the list if there is a direct status check possible for it\n                                if (statusChecking.intvStatusNeeded){\n                                    trackForStatus[intv] = Object.assign({}, initialEntry)}\n                                //if any vitals are listed for this intervention as a way of checking its status then\n                                //put those on the statusChecking list.  Anytime a vital is checked after the timestamp\n                                //it will count towards checking the status of the intervention\n                                statusChecking.vitalsNeeded.forEach(vital => {\n                                    if (!trackForStatus[vital]){trackForStatus[vital] = [Object.assign({}, initialEntry)]}\n                                    else {trackForStatus[vital].push(Object.assign({}, initialEntry))}})}\n                                \n                            // fill out problem related fields in the action event\n                            if (!!action.assessments) {eventObj.assessmentsNeeded = action.assessments}\n                            if (!!action.phase) {eventObj.when = action.phase};\n                            if (!action.optional) { eventObj.required = true};\n                            if (!!prob.protocols) {eventObj.protocol = prob.protocols}\n                            if (eventObj.answerCorrect) {\n                                eventObj.status = \"standard\";}\n                            else { eventObj.status = \"incorrect-answers\"; }\n                            if (!!action.phase) {eventObj.suggestedPhase = action.phase};\n                            eventObj.probLabel = prob.probLabel;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!action[fldName]) {\n                                    eventObj[fldName] = action[fldName];\n                                }});\n                            if (!!action[\"id-label\"]) { eventObj[\"label\"] = action[\"id-label\"]; }  //dealing with residual name changes\n                        }});\n\n                    // check for this action to be a contraindication for a problem solution\n                    prob.contraindications?.forEach((contra, j) => {\n                        if (contra.id === eventObj.id) {\n                            eventObj.status = \"contraindicated\";\n                            if (!!contra.why) { eventObj.contraindicatedWhy = contra.why; }\n                            if (!!contra[\"id-label\"]) { eventObj.label = contra[\"id-label\"]; }\n                            if (!!contra.protocol) { eventObj.protocol = contra.protocol; }\n                            if (!!prob.probLabel) { eventObj.probLabel = prob.probLabel; }\n                        }}) \n                    })}\n\n            if (eventObj.type === \"decision-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"decision-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n\n            if (eventObj.type === \"assessment-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"assessment-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n            // add the formatted object to our list of formatted objects for the current phase and the id to our set of confirmed ids\n            if (eventObj.type === \"intervention\"){\n                confirmedEvents.push(eventObj.id + \"+\" + eventObj.probLabel)\n                interventionsConfirmed.push(eventObj.id)\n            }\n            else {confirmedEvents.push(eventObj.id)}\n            phaseObjects.push(eventObj)}});\n\n    // store the last phase processed\n    phases[phaseIndex] = phaseObjects;\n    if (phaseIndex !== parentIndex){\n        phases[parentIndex] = (phases[parentIndex]).concat(phaseObjects)};\n    return [phases,phaseNames,confirmedEvents,trackForStatus]\n}\n\n//start support functions for constraint checking\n\nconst findNameNumID = (names, entries, item, occurrence) => {\n    let result = undefined\n    let index = undefined\n    for (let i = 0; i < names.length; i++) {\n        if (item.id === names[i]) {\n            result = entries[i]\n            if (occurrence === \"start\") {\n                break}}}\n    if (!!result) {\n        if (result.numericalID === -1) {\n            if (occurrence === \"start\") {\n                index = result.numericalIDStart}\n            else { index = result.numericalIDEnd }}\n        else { index = result.numericalID }}\n\n    return index\n}\n\nlet unknownItem = {id: \"Unknown\", label: \"Unknown\"}\n\nconst getItem = (val) => {\n    if (val === \"Unknown\"){return unknownItem}\n    let item = itemByID[val]\n    if (!item){\n        item = itemByLabel[val]}\n    if (item){return item[0]}\n}\n\nconst findObjByNumerialID = (numericalID,phases,phaseNames) => {\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            for (let entry of phaseObjects){\n                if (entry.numericalID === numericalID){\n                    return entry}\n            }}}}\n\n\nconst storeMisOrderedArgs = (numericalID, arg2, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (!objToModify.arg2){\n            objToModify.arg2 = [arg2.id]}\n        else {objToModify.arg2 = objToModify.arg2.concat([arg2.id])}}\n}\n\nconst storeMisOrderedFB = (numericalID, FB, constraintType, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (objToModify.orderingFB !== \"\") {\n            objToModify.orderingFB = objToModify.orderingFB + \".\\xa0\\xa0\" + FB}\n        else { objToModify.orderingFB = FB }\n        let status\n        \n        let appendString = \"\"\n        if (constraintType === \"phase\"){\n            appendString = \"misOrdered-phase-\"}\n        if (constraintType === \"item\"){\n            appendString = \"misOrdered-\"}\n        if (!(objToModify.status.includes(appendString)))\n                {status = appendString + objToModify.status \n                objToModify.status = status}}\n}\n\n\n//flattens out the phases and phaseNames data structures so that all phase and subphase\n//names have their own entry and each item under a phase or subphase has its own entry.\n//Collect and return unique names because phase and subphase names can appear multiple times in the \n//phases and phaseNames ds.  Having a unique list of names means that a constraint will only be checked once.\n\n\nconst collectEntriesToCheckConstraints = (phases, phaseNames) => {\n    let listOfNames = []\n    let listOfEntries = []\n    let uniqueListOfNames = []\n    let counter = -1\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let startIndex = phaseObjects[0].numericalID\n        let endIndex = phaseObjects[phaseObjects.length-1].numericalID\n\n        //handle phases and subphases first\n    \n        if (requiredPhaseNames.includes(phaseName) || requiredSubphases.includes(phaseName)) {\n            listOfEntries.push({ id: phaseName, numericalID: counter, numericalIDStart: startIndex, numericalIDEnd: endIndex })\n            listOfNames.push(phaseName)\n            if (!uniqueListOfNames.includes(phaseName)){uniqueListOfNames.push(phaseName)}}\n\n        //can't be an else to above because a phase can have entries but a subphase cannot\n        \n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            let phaseObjectNames = phaseObjects.map(obj => obj.id)\n            listOfEntries = listOfEntries.concat(phaseObjects)\n            uniqueListOfNames = uniqueListOfNames.concat(phaseObjectNames)\n            listOfNames = listOfNames.concat(phaseObjectNames)\n        }\n    }\nreturn [listOfNames, uniqueListOfNames, listOfEntries]\n\n}\n\nconst saveFailedConstraint = (lateArg, otherArg, constraintID) => {\n    let type\n    if ([\"phase\", \"sub-phase\"].includes(lateArg.type)){\n        type = \"phase\"}\n    else {type = \"item\"}\n    constraintsViolated.push({constraintID: constraintID, arg1: lateArg, op: \"before\", arg2: otherArg, type: type}) \n    return type\n}\n\nconst addToListOfFeedback = (parPhFB, last, label, repeating) => {\n    //feedback for nonphase\n    if (repeating){\n        if (last) {\n            parPhFB = parPhFB + \" and \"\n        }\n        else {parPhFB = parPhFB +  \", \"}}\n    parPhFB = parPhFB + label.toLowerCase()\n    return parPhFB\n}\n\n\n\nconst checkAgainst2ndArgs = (arg1st,args2nd,op,direction,constraintID,entryNames,entries,phases,phaseNames) => {\n    let endNum1st = findNameNumID(entryNames, entries, arg1st, \"end\")\n    let startNum1st = findNameNumID(entryNames, entries, arg1st, \"start\")\n    let label1st = arg1st.label\n    let phFB = \"\"\n    let par1PhFB = \"\"\n    let par2PhFB = \"\"\n    let repeating\n    let constraintType\n    if (args2nd.length > 0) {\n        let counter = 0\n        let violations = 0\n        for (let arg of args2nd) {\n            let last = false\n            let arg2nd = getItem(arg)\n            if (!!arg2nd) {\n                counter++\n                if (counter === args2nd.length){\n                    last = true}\n                let label2nd = arg2nd[\"label\"]\n                let startNum2nd = findNameNumID(entryNames, entries, arg2nd, \"start\")\n                let endNum2nd = findNameNumID(entryNames, entries, arg2nd, \"end\")\n                \n                switch (direction){\n                case \"before\":\n                    if (!!endNum1st && !!startNum2nd) {\n                        if (!(endNum1st < startNum2nd)) {  //if failed constraint i.e. arg1 is late\n                            //result = collectFB (constraintID, counter, arg1st, arg2nd, startNum1st, startNum2nd, endNum1st, endNum2nd, label1st, label2nd, last, constraintType, phases, phaseNames)\n                            //feedback for item\n                            violations++\n                            if (par1PhFB === \"\"){\n                                if (startNum1st === endNum1st) { \n                                    par1PhFB = \"You should have done \"\n                                    par1PhFB = addToListOfFeedback(par1PhFB, last, label1st, false)}     \n                                //feedback for phase\n                                else { \n                                    par1PhFB = \"You should have completed \"\n                                    par1PhFB = addToListOfFeedback(par1PhFB, last, label1st, false)}} \n                            if (startNum2nd === endNum2nd) {\n                                if (par2PhFB === \"\"){\n                                        par2PhFB = par2PhFB + \" before you did \"}  //feedback for item\n                                    if (violations > 1){repeating = true}\n                                    else {repeating = false}\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label2nd, repeating)}\n                            else { \n                                if (par2PhFB === \"\"){\n                                    par2PhFB = par2PhFB + \" before starting \"}  //feedback for phase\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par2PhFB = addToListOfFeedback(par2PhFB, last, label2nd, repeating)}\n                            storeMisOrderedArgs(startNum1st, arg2nd, phases, phaseNames)\n                            constraintType = saveFailedConstraint(arg1st, arg2nd, constraintID)\n                        }\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                case \"after\":  //for after just reverse 1st and 2nd args\n                    if (!!startNum1st && !!endNum2nd) {\n                        if (!(startNum1st > endNum2nd)) { //if failed constraint  i.e. arg2 is late  \n                            violations++                         \n                            if (startNum1st === endNum1st){\n                                //feedback for item \n                                if (par1PhFB === \"\")                              \n                                    {par1PhFB = \"You should have done \"}\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par1PhFB = addToListOfFeedback(par1PhFB, last, label2nd, repeating)}\n                            //feedback for phase \n                            else{\n                                if (par1PhFB === \"\")                               \n                                    {par1PhFB = \"You should have completed \"}\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par1PhFB = addToListOfFeedback(par1PhFB, last, label2nd, repeating)}\n                            if (par2PhFB === \"\"){\n                                if (startNum2nd === endNum2nd){     \n                                    par2PhFB = par2PhFB + \" before you did \"\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label1st, false)}\n                                else {                                 \n                                    par2PhFB = par2PhFB + \" before starting \" //feedback for nonphase\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label1st, false)}}\n                            storeMisOrderedArgs(startNum2nd, arg1st, phases, phaseNames)   //feedback for phase\n                            constraintType = saveFailedConstraint(arg2nd, arg1st, constraintID)}\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                default: break\n                }\n            }     \n        }        \n        phFB = par1PhFB + par2PhFB\n        if (phFB !== \"\") {\n            storeMisOrderedFB(startNum1st, phFB, constraintType, phases, phaseNames)}    \n    }\n}\n\n\n\nconst checkConstraintsForArg = (arg1st, constraint, phases, phaseNames, entryNames, entries) => {\n    \n    let args2nd = constraint.before\n    let op = constraint.beforeOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"before\",constraint.id,entryNames,entries,phases,phaseNames)\n\n    args2nd = constraint.after\n    op = constraint.afterOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"after\",constraint.id,entryNames,entries,phases,phaseNames)}\n    \n    \n  //end support functions for constraint checking              \n                        \n\n\n//To DO: filter constraints in/out based on findings available for this scenario\n\n//main function for constraint checking \nconst checkAgainstKB = (phases, phaseNames) => {\n\n    let result = collectEntriesToCheckConstraints(phases, phaseNames)\n    let entryNames = result[0]\n    let uniqueEntryNames = result[1]\n    let entries = result[2]\n    uniqueEntryNames.forEach(firstArg => {\n        let firstArgItem = getItem(firstArg)\n        if (!!firstArgItem) {        \n            let constraint = getConstraint(firstArgItem)  //will find only one constraint per 1st arg\n            if (!!constraint) {\n                checkConstraintsForArg(firstArgItem, constraint, phases, phaseNames, entryNames, entries)}}})            \n    //only expect to change objects in phases\n    return [phases, phaseNames]\n}\n\n\n//main function for dealing with missing assessment steps\n\nconst checkForMissingAssessments = (problems,events,confirmedEvents,phaseNames,phases) => {\n    let neededScenAssessments = collectScenAssessments(problems)\n    let indexCounter = events.length;\n    var checklistSteps = scenario.checkListMetaData.filter(md => [MDB_TYPES.ASSESS, MDB_TYPES.REQUIRED].includes(md.type));\n\n    // before evaluating assessment steps, deal with exceptional cases where one or more steps is not\n    // necessary for a given scenario.  Because GCS value is a string and not a formatted object\n    // we can't reliably parse out values and units to do more general checks so can only set what\n    // steps should not be assessed for a particular scenario.  Requires info on feedback to give as\n    // well.\n    // Get any exceptional steps associated with the current scenario\n    var exceptions = [];\n    for (let exceptionDef of exceptionDefs) {\n        if (exceptionDef.scenarioName === scenario.name) {\n            exceptions = exceptionDef.exceptions;\n            break;\n        }\n    }\n\n    exceptions.forEach((exception, j) => {\n        // remove the step from the checklist as it is not required\n        checklistSteps = checklistSteps.filter(entry => entry.id !== exception[0]);\n\n        // if the step was done during the observation then mark it as an issue\n        if (confirmedEvents.includes(exception[0])) {\n            // it could appear in any phase so check all phases and mark\n            // each instancs as unnecessary\n            phases.forEach((phaseObjects, j) => {\n                phaseObjects.forEach((action, i) => {\n                    if (action.id === exception[0]) {\n                        action.why = exception[1];\n                        action.status = \"notNecessary\";\n                    }\n                });\n            });\n        }\n\n    });\n\n    // iterate through all checklist steps for ones for which we don't have formated objects\n    checklistSteps.forEach((cls, i) => {\n        if (!confirmedEvents.includes(cls.id)) {\n            // add so we don't check for the missing checklist item again\n            confirmedEvents.push(cls.id);\n            let phaseObject = {\n                \"comment\": \"\",\n                \"numericalID\": indexCounter,\n                \"status\": \"missingRequiredAssessment\",\n                \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                \"expertPhase\": \"\",\n                \"workingPhase\": \"\",\n                \"contraindicatedWhy\": \"\",\n                \"minimalWhy\": \"\",\n                \"why\": \"\",\n                \"probLabel\": \"\",\n                \"protocol\": \"\",\n                \"actionDescription\": \"\",\n                \"assessmentFB\": \"\",\n                \"timestamp\": -1\n            };\n\n            //copy over the step fields that exist (type dependent)\n            const STEP_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"type\", \"prompt\"];\n            STEP_FIELDS.forEach(fldName => {\n                if (!!cls[fldName]) {\n                    phaseObject[fldName] = cls[fldName];\n                }\n            });\n            if (!!cls.subPhase) { phaseObject.workingPhase = cls.subPhase; }\n            else { if (!!cls.phase) { phaseObject.workingPhase = cls.phase; } }\n            phaseObject.when = phaseObject.workingPhase;\n            phaseObject.expertPhase = phaseObject.workingPhase;\n\n            if (!!phaseObject.label) { phaseObject.actionDescription = phaseObject.label; }\n            \n            //let findings = scenario.assessmentFindings[cls['id']]\n            //if (!!findings & findings !== \"Unremarkable\" & findings !== \"Stable\"){\n\n            if (neededScenAssessments.includes(cls['id'])){\n                phaseObject.assessmentFB = \"Thus you missed finding: \" + scenario.assessmentFindings[cls['id']]}\n            if (phaseObject.type === \"required-action\"){\n                phaseObject.status = \"missingRequiredAssessment\"\n            }\n            insertInPhaseInOrder(phaseNames, phases, phaseObject, i);\n            indexCounter++;\n        }\n    });\n    return[confirmedEvents, phaseNames, phases, indexCounter]\n}\n\n//support functions for updating and searching the phaseNames and phases data structures\nconst insertInPhaseInOrder = (phaseNames, phases, object, objIndex) => {\n    let phase\n    phase = object.when;  //what phase should it be added to\n    let phaseIndex = phaseNames.lastIndexOf(phase); //get the index for the last instance of the phase\n    let phaseObjects = phases[phaseIndex];  //get the objects associated with that phase\n    if (!phaseObjects) { phaseObjects = []; }\n    phaseObjects.splice(objIndex - 1, 0, object);  //insert it at the place indicated by input objIndex\n    phases[phaseIndex] = phaseObjects;\n};\n\nconst getEndSubPhase = (inPhaseId, phaseNames) => {\n    let subPhases = getSubPhases(inPhaseId);\n    let subPhaseName;\n    let reversedSubPhases = [...subPhases].reverse();\n    for (let subPhase of reversedSubPhases) {\n        subPhaseName = phaseNames.find(id => id === subPhase.id);\n        if (!!subPhaseName) { break; }\n    }\n    return subPhaseName;\n};\n\nconst getEndSubPhaseIndex = (inPhaseId, phaseNames) => {\n    let subPhaseName = getEndSubPhase(inPhaseId, phaseNames);\n    let index = phaseNames.lastIndexOf(subPhaseName);\n    //console.log(subPhaseName,index)\n    return index;\n};\n\n// sts 01/23/22\nconst getSubPhases = (phaseId) => {\n    return checklistHierarchy.find(phase => phase.id === phaseId).subPhases\n    // let mainPhases = findPhases();\n    // let phaseEntry = mainPhases.find(phase => phase.id === phaseId);\n    // return (phaseEntry.subPhases);\n};\n\nconst hasSubPhases = (phaseId) => {\n    let phase = checklistHierarchy.find(phase => phase.id === phaseId)\n    if (!!phase && !!phase.subPhases){\n        return true}\n    else {return false}\n}\n\n  \n//given a numerical id, what is its parent phase or subphase\n//find the header under which the input numericalID appears\nconst findHeaderFor = (numericalID, log) => {\n    let candidateHeader = {};\n    let foundHeader = {};\n    for (let entry of log) {\n        if (entry.id === \"problemHeader\") {\n            candidateHeader = entry;\n        }\n        else {\n            if (entry.numericalID === numericalID) {\n                foundHeader = candidateHeader;\n                break;\n            }\n        }\n    }\n    return (foundHeader);\n};\n\n//rearrange the problem data structure for use during analysis\n\nconst setupProblems = (defs, sols, actions) => {\n    let problems = [];\n    for (let problemDef of defs) {\n        let problem = {};\n        let solutionID = problemDef.solutions[0];\n\n        //new interface\n        if (!!sols && !!actions){\n            let probSols = sols.filter(sol => sol.problemID === problemDef.id)\n            let sol = probSols.filter(sol => sol.id === solutionID)\n            problem.probLabel = problemDef.label;\n            problem.id = problemDef.id\n            problem.lifeThreat = problemDef.lifeThreat\n            problem.vitals = problemDef.vitals\n            problem.assessments = problemDef.assessments\n            problem.actions = []\n            let actEntries\n            let actIDs = sol[0].actions\n            actEntries = actions.filter(act => actIDs.includes(act.id))\n            \n            for (let entry of actEntries){\n                let act = Object.assign({}, entry)\n                act.id = act.interventionID\n                let item = itemByID[act.id]\n                if (!!item){\n                    act[\"id-label\"] = item[0].label}\n                else {act[\"id-label\"] = act.id}\n                if (act.protocolRelationship === \"contraindicated\"){\n                    problem.contraindications.push(act)\n                    }\n                else {\n                    if (act.protocolRelationship === \"minimal\"){\n                        act.optional = false\n                        act.minimal = true}\n                    else {act.optional = true\n                        act.minimal = false}\n                    problem.actions.push(act)\n                }\n            }\n            problem.minimalWhy = sol.minimalWhy\n            problem.protocols = sol.protocols\n        }\n        // old interface\n        else {\n            problem.probLabel = problemDef.problem;\n            problem.lifeThreat = problemDef.lifeThreat\n            problem.actions = solutionID.actions;\n            problem.minimalWhy = solutionID.minimalWhy;\n            problem.protocols = solutionID.protocols\n            problem.assessments = problemDef.assessments;\n            problem.contraindications = solutionID.contraindications;\n\n            //not in new interface\n            problem.allProblemProtocols = problemDef.protocol;\n            \n            }\n        problems.push(problem);\n        \n    }\n    return (problems);\n    //console.log(problems)\n};\n\n// this approximates the placement for a missing intervention based on ordering of interventions\n// in the problems definitions, what appears in the log that is just before and just after\n// the item to be inserted, and what is marked as required that is in the log just before and after.  An approach that\n// utilizes partial ordering constraints would be better.  Also it is not clear what to do for really badly ordered\n// actions on the part of the student.  Note that it only looks for two anchor points before and two anchor points after\n// rather than all potential anchor points.  Also it does not deal with a phase that is split into multiple time periods\n// within a log. It looks for the best placement in the last phase found.\n\n//input orderedArrayObjects is the interventions for a problem as ordered in the problem def\n// objIndex is the index in orderedArrayObjects for the intervention object that needs to be inserted in phases\nconst insertInPhaseRelativeToSuggestedOrder = (phaseNames, phases, object, orderedArrayObjects, objIndex) => {\n    // if expertPhase in object is a phase then find the last subphase and insert there instead of at the beginning\n    let phaseIndex = -1;\n    //console.log(object);\n    // if it is a subphase or a phase with no subphases then get the last entry for a proposed initial insertion point\n    // object.expertPhase is the phase recommended for this action to appear\n    if (object.expertPhase === \"\"){\n        /* let errorMsg = 'No phase specified in the problem defs for object: ' + object.actionDescription;\n        throw new Error(errorMsg) */\n        //just use the next to last phase if none is specified\n        object.expertPhase = requiredPhaseNames[requiredPhaseNames.length - 2]}\n        \n\n    if (requiredSubphases.includes(object.expertPhase) || !getSubPhases(object.expertPhase)) {\n        phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    }\n    // if it is a phase then get the last entry of the last suphase within it for a proposed intial insertion point\n    else {\n        phaseIndex = getEndSubPhaseIndex(object.expertPhase, phaseNames);}\n        \n    //update object when field which is mostly to see what gets computed for the insertion point\n    object.when = phaseNames[phaseIndex];\n        \n    \n\n    let objectsBefore = orderedArrayObjects.slice(0, objIndex - 1);\n    let objectBefore = orderedArrayObjects[objIndex - 1];\n    // console.log(\"Objects before in def\", {...objectsBefore})\n    let requiredObjectBefore = [...objectsBefore].reverse().find(entry => entry.required);\n    let objectAfter = orderedArrayObjects[objIndex + 1];\n    let objectsAfter = orderedArrayObjects.slice(objIndex + 1);\n    let requiredObjectAfter = objectsAfter.find(entry => entry.required);\n    //let phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    let phaseObjects = [...phases[phaseIndex]]; //trying for a deep copy of the array mainly for debug via console.log\n\n    //console.log(phaseObjects)\n    let indexBefore = -1;\n    let indexAfter = -1;\n    let indexRequiredBefore = -1;\n    let indexRequiredAfter = -1;\n    let insertionIndex = false;\n    if (objectBefore) { indexBefore = phaseObjects.findIndex(entry => entry.id === objectBefore.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    if (requiredObjectBefore) { indexRequiredBefore = phaseObjects.findIndex(entry => entry.id === requiredObjectBefore.id); }\n    if (requiredObjectAfter) { indexRequiredAfter = phaseObjects.findIndex(entry => entry.id === requiredObjectAfter.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    // There is a more compact way to do the below but this made\n    // it easier for me to get the logic right\n    // insert according to required before first as we want to follow something that was required\n    if (indexRequiredBefore !== -1) {\n        insertionIndex = indexRequiredBefore + 2;\n        // but if the just before object is greater then insert relative to it\n        if (indexBefore > indexRequiredBefore) { insertionIndex = indexBefore + 2; }\n    }\n    //if no required before and not required after then insert relative to\n    //required item after in actions definition\n    if (!insertionIndex && indexRequiredAfter !== -1) {\n        insertionIndex = indexRequiredAfter + 1;\n        // unless the just after is smaller then override and insert relative to it\n        if (indexAfter < indexRequiredAfter) { insertionIndex = indexAfter + 1; }\n    }\n    //otherwide if have a just before insert relative to it\n    if (!insertionIndex && indexBefore !== -1) {\n        insertionIndex = indexBefore + 2;\n    }\n    //otherwise if have a just after insert relative to it\n    if (!insertionIndex && indexAfter !== -1) {\n        insertionIndex = indexAfter + 1;\n    }\n    //otherwise put at end of phase\n    if (!insertionIndex) {\n        insertionIndex = phaseObjects.length + 2;\n    }\n    insertInPhaseInOrder(phaseNames, phases, object, insertionIndex);\n\n};\n\nconst determineHLcolor = (lowerColor, higherColor) => {\n    let newColor = higherColor\n    if (lowerColor === \"red\") {\n        newColor = \"red\"\n    }\n    if (lowerColor === \"yellow\" && newColor !== \"red\") {\n        newColor = \"yellow\"\n    }\n    return newColor\n}\n\n//to display the log using the phase structures accumulated\n// i.e. puts the phases data together in the order in which\n// should be displayed in debriefing log\nconst organizeLogDisplay = (phaseNames, phases) => {\n    let displayObjects = [];\n    let entryIndex = 1;\n    let headerIndex = 1;\n    let problemHeaderColor = \"green\"\n    let subPhaseColor = \"green\"\n    let subPhaseStatuses = []\n    let phaseStatuses = []\n    let newPhaseObjects = []\n    let headerObj = {\n        \"id\": \"assessmentHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"protocol\": \"\"\n    };\n    let subHeaderObj = {\n        \"id\": \"assessmentSubHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"phaseID\": \"\",\n        \"protocol\": \"\"\n    };\n    \n    let priorHLPhaseItem = \"\"\n    let endEntry = false\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let iPhaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let process = true\n        \n        if (requiredPhaseNames.includes(phaseName) && hasSubPhases(phaseName)) {\n            process = false}\n\n        if (iPhaseObjects.length > 0 && process) {\n                //for this set of objects, find the worst scoring item\n            let phaseObjects = phases[phaseIndex];\n            subPhaseColor = \"green\"\n            for (let phaseObject of phaseObjects) {\n                if (phaseObject.type !== \"intervention\"){\n                    subPhaseStatuses.push(phaseObject.status)}\n                //else {hierProblemResults.push(phaseObject)} \n                if (problemStates.includes(phaseObject.status)) {\n                    subPhaseColor = \"red\";     \n                }\n                // Red has a higher priority than yellow so will allow to override it\n                if (cautionStates.includes(phaseObject.status) && subPhaseColor !== \"red\") {\n                    subPhaseColor = \"yellow\";    \n                }               \n                phaseObject.numericalID = entryIndex++;\n                //entryIndex++;\n            };\n\n            let subheader = Object.assign({}, subHeaderObj)\n            let localPhaseName = phaseNames[phaseIndex]\n            let localPhaseItem = getItem(localPhaseName)\n            subheader.label = localPhaseItem.label\n            subheader.labelID = localPhaseItem.id\n            subheader.status = getPhaseStatus(subPhaseStatuses)\n            subheader.displayColor = subPhaseColor\n            let highLevelPhase = subPhases[localPhaseName]\n            let highLevelPhaseItem = getItem(highLevelPhase)\n            subheader.phaseID = highLevelPhaseItem.id\n\n            //Note that the inserted headers will have their own numerical id and\n            //am dividing by 1000 for headers so their numerical id will be unique\n            //to headers.  Am assuming we would never have more than 1000 events\n            //observed.  Will use the numerical ids for testing before and after\n            //constraints.       \n            \n            if (priorHLPhaseItem === \"\") {\n                priorHLPhaseItem = highLevelPhaseItem\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n            }\n            \n            if (phaseIndex === phaseNames.length - 1) {\n                //this closes out the prior phase and the new subphase \n                let header = Object.assign({}, headerObj)\n                if (highLevelPhase !== priorHLPhaseItem.label){    //ending with start of a new phase\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    newPhaseObjects = []}\n\n                header = Object.assign({}, subheader)\n                header.label = highLevelPhaseItem.label\n                header.labelID = highLevelPhaseItem.id\n                header.id = \"assessmentHeader\"\n                header.numericalID = headerIndex++ / 1000 \n                displayObjects.push(header)\n                      \n                if (highLevelPhase === subheader.label) { \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(...phaseObjects)}\n                else {\n                    subheader.numericalID = headerIndex++ / 1000 \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(subheader)\n                    displayObjects.push(...phaseObjects)}          \n                endEntry = true;\n            }\n\n            //save the accumulated high-level phase if the phase changes \n            if (!endEntry) {\n                if (highLevelPhase !== priorHLPhaseItem.label) {\n                    let header = Object.assign({}, headerObj)\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    phaseStatuses = []\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    //reinitialize for the new phase   \n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects = [...phaseObjects]\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects = [subheader]\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    priorHLPhaseItem = highLevelPhaseItem\n                    problemHeaderColor = determineHLcolor(subPhaseColor, \"green\")\n                }\n                else {\n                    problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects.push(subheader)\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                }\n            }\n        \n        }\n    }\n    return displayObjects;\n}\n\n\n\n\nconst evalForIncorrectAnswer = (promptID, answerID, isIntervention) => {\n        //check each prompt and if is the appropriate one then\n        let answers = undefined\n        if (isIntervention) {\n            answers = scenario.associations[promptID];\n        }\n        else { answers = scenario.checkListCorrectness[promptID]; }\n\n        if (answers === undefined) { console.log(\"didn't find answers for \", promptID); return (false) }  //can't grade if answers not found in spec\n\n        if (Array.isArray(answers)) {\n            //returns bool regarding whether answerID NOT in answers\n            return !(answers.find(ansId => ansId === answerID));\n\n        }\n        else {\n            return !(answers === answerID);\n        }\n};\n\n\nconst getCorrectAnswerLabel = (promptID, isIntervention) => {\n    let answers\n    let metaData\n    if (isIntervention){\n        answers = scenario.associations[promptID];\n        metaData = scenario.intvMetaData}\n    else {answers = scenario.checkListCorrectness[promptID];\n        metaData = scenario.checkListMetaData}\n    let answerLabels = false;\n    if (Array.isArray(answers)) {\n        answers.forEach((answer, j) => {\n            metaData.forEach((entry, i) => {\n                if (entry.id === answer) {\n                    if (answerLabels === false) {\n                        answerLabels = entry.label;\n                    }\n                    else { answerLabels = answerLabels + \", \"; }\n                    return;\n                }\n            });\n        });\n    }\n\n    else {\n\n        metaData.forEach((entry, i) => {\n            /* //needed to find out what the types are for debugging\n            let answertypes = []\n            if (!answertypes.find(type => type === entry.type)){\n                answertypes.push(entry.type)} */\n\n            if (entry.id === answers) {\n                answerLabels = entry.label;\n            }\n        });\n    }\n    //answerLabels = answerLabels.charAt(0).toLowerCase() + answerLabels.slice(1);\n    /* if (answerLabels){\n        answerLabels = \"'\" + answerLabels + \"'\";} */\n    return answerLabels\n};\n\nconst getAnswerLabel = (answerID, isIntervention) => {\n    let metaData\n    if (isIntervention){\n        metaData = scenario.intvMetaData}\n    else {metaData = scenario.checkListMetaData}\n    let answerLabel = \"\";\n    metaData.forEach((entry, i) => {\n            if (entry.id === answerID) {\n                answerLabel = entry.label;\n            }\n        });\n    return (answerLabel || false) ;\n}\n\n// create structure for tracking whether interventions are checked\nconst insertMissingIntvChecks = (events, statusTracking) => {\n    let toUpdate\n    for (const [key, entry] of Object.entries(statusTracking)) {\n        if (Array.isArray(entry)){\n            for (let obj of entry) {\n                let newObj = {\"label\": key, \"foundCk\": obj[\"foundCk\"]}\n                toUpdate = getEventsByIdTime(events,obj[\"intervention\"],obj[\"timestamp\"])\n                for (let intv of toUpdate) {\n                    if (!intv[\"intvStatus\"].includes(newObj)){\n                       intv[\"intvStatus\"].push(newObj)}\n                }}}\n        else {\n            let newObj = {\"label\": \"intervention status\", \"foundCk\": entry[\"foundCk\"]}\n            toUpdate = getEventsByIdTime(events,key,entry[\"timestamp\"])\n            toUpdate.forEach(intv => {\n                if (!intv[\"intvStatus\"].includes(newObj)){\n                    intv[\"intvStatus\"].push(newObj)}})}\n    }\n    return events\n}\n\nconst insertMissingInterventions = (problems,confirmedEvents,indexCounter,phaseNames,phases) => {\n    problems.forEach(prob => {\n        const actions = prob.actions\n        // now we just have to examine action ids to see what is missing\n        actions.forEach((action, k) => {\n            if (!confirmedEvents.includes(action.id + \"+\" + prob.probLabel)) {\n                confirmedEvents.push(action.id + \"+\" + prob.probLabel);\n                let phaseObject = {\n                    \"comment\": \"\",\n                    \"numericalID\": indexCounter,\n                    \"status\": \"\",\n                    \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                    \"required\": true,\n                    \"when\": \"\",\n                    \"suggestedPhase\": \"\",\n                    \"expertPhase\": \"\",\n                    \"probLabel\": \"\",\n                    \"minimalWhy\": \"\",\n                    \"assessmentsNeeded\": \"\",\n                    \"protocol\": \"\",\n                    \"actionDescription\": \"\",\n                    \"type\": \"intervention\",\n                    \"timestamp\": -1\n                };\n\n                //copy over the step fields that exist (type dependent)\n                const ACTION_FIELDS = [\"id\", \"phase\", \"why\", \"optional\", \"minimal\"];\n                ACTION_FIELDS.forEach(fldName => {\n                    if (!!action[fldName]) {\n                        phaseObject[fldName] = action[fldName];\n                    }\n                });\n\n                //copy over the step fields that exist (type dependent)\n                const PROBLEM_FIELDS = [\"probLabel\", \"minimalWhy\"];\n                PROBLEM_FIELDS.forEach(fldName => {\n                    if (!!prob[fldName]) {\n                        phaseObject[fldName] = prob[fldName];\n                    }\n                });\n\n                //initialize some fields above that come from problem and action if they are defined\n                if (!!prob.assessments) {phaseObject.assessmentsNeeded = prob.assessments}\n                if (!!prob.protocols) {phaseObject.protocol = prob.protocols}\n                if (!!action.optional) { phaseObject.required = !action.optional; }\n                if (!!action[\"id-label\"]) { phaseObject.label = action[\"id-label\"]; }\n                if (!!action[\"id-label\"]) { phaseObject.actionDescription = action[\"id-label\"]; }\n                if (!!action.phase) {\n                    phaseObject.when = action.phase;\n                    phaseObject.expertPhase = action.phase;\n                    phaseObject.suggestedPhase = action.phase;\n                }\n\n\n                if (phaseObject.required) {\n                    phaseObject.status = \"missingRequired\";\n                }\n                else {\n                    if (!phaseObject.optional) { phaseObject.status = \"missingRequired\"; }\n                    else { phaseObject.status = \"missingOptional\"; }\n                }\n                //assume actions are in the suggested order to solve a problem\n                if (phaseObject.status !== \"missingOptional\") {\n                    insertInPhaseRelativeToSuggestedOrder(phaseNames, phases, phaseObject, actions, k);\n                    indexCounter++;\n                }\n            }\n\n        });\n    });\nreturn [indexCounter,phaseNames,phases]}\n\n//the main function for analyzing the observation log\nfunction analyzeEvents(scen, log) {\n    let events = log.events;\n    console.log(\"in analyzeEvents\")\n    // sts 1/23/22 moved the setting of the following into initGlobals()\n    // setScenario(scenario)\n    // setupSubphasePhaseLookup()\n    // findSubphases();\n    initGlobals(scen)\n\n    //preprocess some of data from problems/solutions\n    //and for now just flatten it some to set it up to\n    //look more like the original problem actions in scenario\n    // assumes there is just one solution per problem for now.\n    let problemDefs = scenario.problems;\n    let problemActions = scenario.actions;\n    let problemSolutions = scenario.solutions;\n    let problems = setupProblems(problemDefs, problemSolutions, problemActions);\n    \n    //In the remainder, just dealing with the first solution for each problem\n    //so if we ever have more than one solution for a problem this code needs to\n    //be updated.  Would need to consider the additional solutions to decide which\n    //solution is the best fit for the observer student\n\n\n    let formattedActions = [];\n    let annotatedResults = annotateInputEvents(events,problems)\n    //phaseNames and phases are two arrays synchronized be array indices\n    //phases contains just the steps under the phase (thus could be a phase or subphase in observer interface)\n    //phaseNames contains the label for each phase in phases.  Makes it a bit easier to search phaseNames to get the\n    //indice for last instance of a phase label and access its objects\n    let phases = annotatedResults[0];  \n    let phaseNames = annotatedResults[1]; \n    let confirmedEvents = annotatedResults[2]\n    let intvsTracking = annotatedResults[3]\n    \n\n    /* //now create some similar structures for the parents of the above phases\n    //so have all the associated event objects in parents and parentNames\n    //for easy lookup\n    let parentResults = collectParentPh(phaseNames)\n    let parents = parentResults[0]  //events under this parent\n    let parentNames = parentResults[1] */\n\n    //update relative to constraints and comprises definitions\n    //for now it just compares two constraint args of the same type\n    //for what currently exists\n    let kbUpdates = checkAgainstKB(phases,phaseNames)\n    phases = kbUpdates[0]\n    phaseNames = kbUpdates[1]\n    \n    //add missing phase names to phaseNames\n    //as do insertions should consider the temporal ordering constraints\n    \n    let updatedPhases = insertMissingSubphases(phases, phaseNames)\n    phases = updatedPhases[0]\n    phaseNames = updatedPhases[1]\n\n\n    // check for missing checklist steps\n    //as do insertions should consider the temporal ordering constraints\n    let postAssessmentReview = checkForMissingAssessments(problems,events,confirmedEvents,phaseNames,phases)\n    confirmedEvents = postAssessmentReview[0]\n    phaseNames = postAssessmentReview[1]\n    phases = postAssessmentReview[2]\n    let indexCounter = postAssessmentReview[3]\n\n\n\n    // this section could be moved into a separate function so that\n    // the parts of the main analysis are clearer\n\n    // start insert missing interventions\n\n    let postInterventionReview = insertMissingInterventions(problems,confirmedEvents,indexCounter,phaseNames,phases)\n    indexCounter = postInterventionReview[0]\n    phaseNames = postInterventionReview[1]\n    phases = postInterventionReview[2]\n    // search for missing interventions for each action\n    // Doing this separately from the earlier actions loop because\n    // we wanted to add in missing assessment steps first\n    // since interventions depend on appropriate assessments having \n    // been done\n\n\n\n   // end insert missing interventions\n    \n    \n    // put together the phases into a single array ordered as directed by phases\n    \n    formattedActions = organizeLogDisplay(phaseNames, phases);\n    //console.log(\"formattedActions after organizeLogDisplay = \", formattedActions)\n\n    // Now that it is all rejoined into a single list, do some updating with additional\n    // analysis results\n\n    formattedActions = insertMissingIntvChecks(formattedActions, intvsTracking)\n    \n    \n    let priorProb = \"N/A\";\n\n    let finalActions = [];\n    //console.log(\"formattedActions = \", formattedActions)\n\n    formattedActions.forEach((eventObj, j) => {\n        let intvHeaderIndex = 1\n\n        if (insertInterventionHeader && eventObj.type === \"intervention\" && eventObj.probLabel && !(priorProb === eventObj.probLabel)) {\n            priorProb = eventObj.probLabel;\n            let headerObject = {\n                \"id\": \"interventionHeader\",\n                \"status\": \"good\",\n                \"phaseOrderStatus\": \"good\",\n                \"labelID\": eventObj.probLabel,\n                \"type\": \"header\",\n                \"numericalID\": intvHeaderIndex++/3000,\n                \"displayColor\": \"green\",\n            //    \"why\": \"\",\n                \"probLabel\": eventObj.probLabel,\n                \"protocol\": \"\"\n            };\n            finalActions.push(headerObject);\n        }\n        finalActions.push(eventObj);\n    });\n\n    // start overall analysis to determine if all actions to solve a problem are present\n\n    // now we analyze all that we've found in the log to see whether\n    // all the actions were done for each problem and reset\n    // the status if not all are there but should be counted\n    // as minimal for the feedback.\n    let pActions = []; //here we will store the actual problem actions that student did\n    let pNames = []; //here we will store the problem names for the above with same order\n    let pIndex = 0;\n    let pActIndex = -1;\n\n    //console.log(\"finalActions before minimal check = \", finalActions)\n\n    finalActions.forEach((action, j) => {\n        if (action.type === \"intervention\") {\n            //good interventions can have these status values\n            if (!!action.status && action.status.includes(\"standard\", \"incorrect-answers\", \"minimal\", \"misOrdered-standard\", \n            \"misOrdered-incorrect-answers\", \"misOrdered-incorrect-answers\", \"minimal\", \"misOrdered-minimal\", \n            \"misOrdered-minimal-incorrect-answers\",\n            \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\", \"misOrdered-phase-minimal\")) {\n                if (!pNames.includes(action.probLabel)) {\n                    pActIndex = pIndex;\n                    pNames[pActIndex] = action.probLabel;\n                    pIndex++;}\n                else { pActIndex = pNames.indexOf(action.probLabel); }\n                let actions = pActions[pActIndex];\n                if (!actions) { actions = []; }\n                actions.push(action);\n                pActions[pActIndex] = actions;\n            }\n        }\n    });\n\n    // If all the minimal were found but not all the action were, then we\n    // need to re-mark the action objects created for the minimal events\n    // to be minimal instead of standard.  It isn't\n    // appropriate to give this feedback if all actions are present.\n    // Waited until now so that all the events are in one list instead of\n    // a list per phase,\n    let processedIds = formattedActions.map(event => event.id);\n    let pIds = problems.map(a => a.probLabel);\n    pNames.forEach((pEntry, j) => {\n        //get the action definition for this problem\n        let pIndex = pIds.indexOf(pEntry);\n        let prob = problems[pIndex];\n        let actionNeeded = prob.actions.filter(obj => !obj.optional).map(obj => obj.id);\n        //collect statuses for these actions\n\n        let minimalNeeded = prob.actions.filter(obj => obj.minimal).map(obj => obj.id);\n        if (minimalNeeded) { //no point in doing anything else if no minimals were defined\n            let foundActions = pActions[j];\n            let found = foundActions.map(a => a.id);\n            let allActionFound = true;\n            let allMinimalFound = true;\n            for (let item of actionNeeded) {\n                if (!found.includes(item)) {\n                    allActionFound = false;\n                    break;\n                }\n            }\n            for (let item of minimalNeeded) {\n                if (!found.includes(item)) {\n                    allMinimalFound = false;\n                    break;\n                }\n            }\n            let numericalIDsChanged = [];\n            if (!allActionFound && allMinimalFound) {\n                minimalNeeded.forEach((foundId, j) => {\n                    let pIndex = processedIds.indexOf(foundId);\n                    let object = formattedActions[pIndex];\n\n                    //find object to modify\n                    object.minimalWhy = prob.minimalWhy;\n                    switch (object.status){\n                        case \"incorrect-answers\":\n                            object.status = \"minimal-incorrect-answers\"\n                            break\n                        case \"standard\":\n                            object.status = \"minimal\"\n                            break\n                        case \"misOrdered-standard\":\n                            object.status = \"misOrdered-minimal\"\n                            break\n                        case \"misOrdered-incorrect-answers\":\n                            object.status = \"misOrdered-minimal-incorrect-answers\"\n                            break\n                        case \"misOrdered-phase-standard\":\n                            object.status = \"misOrdered-phase-minimal\"\n                            break\n                        case \"misOrdered-phase-incorrect-answers\":\n                            object.status = \"misOrdered-phase-minimal-incorrect-answers\"\n                            break\n                        default: \n                            break}\n\n                    numericalIDsChanged.push(object.numericalID);\n                    formattedActions[pIndex] = object;\n                });\n                //redo color for header if needed\n                let header = {};\n                numericalIDsChanged.forEach((numericalID, z) => {\n                    header = findHeaderFor(numericalID, formattedActions);\n                    if (header && header.displayColor === \"green\") { header.displayColor = \"yellow\"; }\n                });\n\n            }\n        }\n\n    });\n\n    // end of overall analysis\n\n    //create summaries for condition 2\n    let summaryResults = summarizeAnalysis(finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated)\n    hierAssessResults = summaryResults[0]\n    hierProblemResults = summaryResults[1]\n\n    \n    //save analysis and summaries for condition 2 to db\n\n    console.log(\"Phase Assessment Status Results\", hierAssessResults)\n    console.log(\"Intervention Status Results\", hierProblemResults)\n    console.log(\"Constraint Violation Results\", constraintsViolated)\n    //console.log(\"Final Analysis:\", finalActions);\n\n\n    // save final analysis in a file\n    saveAnalysisLog(log, finalActions, hierAssessResults, hierProblemResults, constraintsViolated);\n\n    //else {checkOnOverwriting(log, finalActions)}\n\n\n    return (finalActions);\n\n}\n\n\nexport {analyzeEvents}","export const formatAsMinSecs = (seconds) => {\n    return new Date(seconds * 1000).toISOString().substr(14, 5)\n}","import { MDB_TYPES, CHECKLIST_STEP_TYPES, OPTION_TYPES } from \"@meddbriefer/scenario-data/constants\";\n\n// input: list of objects and a fieldName\n// returns: an object who's attributes are the distinct values for that fieldName mapped to the subset\n// of list items which share that field value\nexport const groupByKey = (listOfObjs, fldName) => listOfObjs.reduce(\n    (hash, obj) => ({ ...hash, [obj[fldName]]: (hash[obj[fldName]] || []).concat(obj) }),\n    {}\n)\n\nexport const getChecklistItemsByType = (scenario, itemType) => {\n    return scenario.checkListMetaData.filter(e => e.type === itemType)\n}\n\nexport const getChecklistItems = (scenario) => {\n  return scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(MDB_TYPES.PHASE, MDB_TYPES.SUB_PHASE))  \n}\n\nexport const getChecklistHierarchy = (scenario) => {\n    const phases = getChecklistItemsByType(scenario, MDB_TYPES.PHASE)\n    const subPhases = getChecklistItemsByType(scenario, MDB_TYPES.SUB_PHASE)\n    // filters out items which are display only\n    const clSteps = scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(e.type))\n    // get the options which are associated with some certain types of steps (decisions, assess w/options)\n    const options = scenario.checkListMetaData.filter(e => OPTION_TYPES.includes(e.type))\n    // map the options to their stepId\n    const stepOptions = groupByKey(options, \"parentID\")\n    // if a step has options, add them to that step\n    clSteps.forEach(step => {\n        if (step.id in stepOptions) {\n            step.options = stepOptions[step.id]\n        }\n    })\n    // figure out which checklist items belong to phases or subphases and group them by\n    // the their corresponding phase/subphase ids\n    const phChecklistSteps = groupByKey(clSteps.filter(e => undefined === e.subPhase), \"phase\")\n    const spChecklistSteps = groupByKey(clSteps.filter(e => !!e.subPhase), \"subPhase\")\n    // assign subphase steps to the appropriate subphase\n    subPhases.forEach(sp => {\n        sp.items = spChecklistSteps[sp.id]\n    })\n    // map subphases to their phase\n    const phSubphases = groupByKey(subPhases, \"phase\")\n    // phases have either items or subphases -not both. assign the appropriate stuff\n    // to each phase\n    phases.forEach(ph => {\n        if (ph.id in phChecklistSteps) {\n            ph.items = phChecklistSteps[ph.id]\n        } else {\n            ph.subPhases = phSubphases[ph.id]\n        }\n    })\n    return phases\n}","import { getPhaseStatus, pushNew} from \"./debriefingUtils\"\n\nlet allAssessResults = []\nlet allProblemResults = []\n\nconst getEntriesUnderHeader = (headerID,events,level,populate) => {\n    let header = mergeHeaderStatuses(headerID,events)\n    if (!!header) { \n        let results = [header]\n        if (populate){\n            let eventItems\n            if (level === 2){\n                eventItems = events.filter(e => (e.expertPhase === headerID && e.type !== \"header\"))}\n            if (level === 1){\n                eventItems = events.filter (e => (e.phaseID === header.labelID && e.type === \"header\" && e.id === \"assessmentSubHeader\"))}\n            results = results.concat(eventItems)}\n       return results}\n    else {return false}\n }\n\n//merges a phase or subphase that is temporarly split\nconst mergeHeaderStatuses = (headerID, events) => {\n    let overallStatus = \"unk\"\n    let headerStatuses = []\n    let headerItems = events.filter(e => e.type === \"header\" && e.labelID === headerID)\n    let header = headerItems[0]    \n    for (const item of headerItems){\n        if (!headerStatuses.includes(item.status)){headerStatuses.push(item.status)}\n    }\n    if (headerStatuses.length > 0) {\n        if (headerStatuses.length === 1){overallStatus = headerStatuses[0]}\n        else {overallStatus = \"errors\"}  //must be all good or all absent for either of those to hold\n    }\n    if (!!header) {header.status = overallStatus}\n    return header \n}\n\n// use if there is a possibility that the children headers could have changed because of their merging\n    // across time\n    const updateHeader = (headerID, events) => {\n        if (headerID !== \"Unknown\") {\n            let newStatus\n            let statuses = []\n            let headerItems = events.filter(e => e.type === \"header\" && e.labelID === headerID)\n            let header = headerItems[0]\n            let subitems = events.filter(e => (e.phaseID === header.labelID && e.type === \"header\" && e.id === \"assessmentSubHeader\"))\n            for (let item of subitems) {\n                pushNew(item.status, statuses)\n            }\n            if (statuses.length === 1) { newStatus = statuses[0] }\n            else { newStatus = \"errors\" }\n            header.status = newStatus\n        }\n    }\n\n\n\n    \nexport const summarizeAnalysis = (finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated) => {\n    allAssessResults = []\n    allProblemResults = []\n    let hierAssessResults = {}\n    let hierProblemResults = {}\n    finalActions.forEach(event => {\n        if (event.type !== \"intervention\" && event.type !== \"answer\"){\n            allAssessResults.push(event)}\n        else {allProblemResults.push(event)}\n\n    }) \n    problems.forEach(prob => {\n        let intvHeaderIndex = 1\n        let entries = allProblemResults.filter(e => (e.probLabel === prob.probLabel && e.type !== \"header\"))\n        let statuses = entries.map(e => e.status)\n        let status = getPhaseStatus(statuses)\n        let headerObject = {\n            \"id\": \"interventionHeader\",\n            \"status\": status,\n            \"phaseOrderStatus\": \"good\",\n            \"labelID\": prob.probLabel,\n            \"type\": \"header\",\n            \"numericalID\": intvHeaderIndex++/2000,\n            \"displayColor\": \"green\",\n        //    \"why\": \"\",\n        //    \"protocol\": \"\"\n        };\n        if (entries){\n            hierProblemResults[prob.probLabel] = [headerObject].concat(entries)}\n\n    })\n\n    let subLevel = requiredPhaseAndSubPhases\n    let topLevel = requiredPhaseNames.filter(e => !subLevel.includes(e))\n    \n    //need to update status in headers for lower level first since those\n    //values will percolate upwards\n\n    subLevel.forEach(headerID  => {\n        let entries = getEntriesUnderHeader(headerID,allAssessResults,2,true)\n        //console.log(\"header = \", header, \"entries = \", entries)\n        if (entries){\n            hierAssessResults[headerID] = entries}})\n\n            topLevel.forEach(headerID => {\n                updateHeader(headerID,allAssessResults)  // in case the merging of split subphases above changes a status\n                let entries = getEntriesUnderHeader(headerID,allAssessResults,1,true)\n                //console.log(\"header = \", header, \"entries = \", entries)\n                if (entries){\n                    hierAssessResults[headerID] = entries}})\n        \n            \n            // store phase level contraint feedback at the header level for condition 2 \n            // (Note that for condition 1 it was stored during the analysis at the first\n            // event entry for a phase and is prefaced by misOrderedPhase in status so that\n            // it alone won't count as an error later for condition 2)\n            let entryToModify\n            constraintsViolated.forEach(constraint => {\n                if (constraint.type === \"phase\"){\n                    entryToModify = finalActions.filter(e => e.labelID === constraint.arg1.id)[0]\n                    entryToModify.phaseOrderStatus = \"misOrdered\"\n                    if (!entryToModify.arg2){\n                        entryToModify.arg2 = [constraint.arg2.id]}\n                    else {entryToModify.arg2 = entryToModify.arg2.concat([constraint.arg2.id])}\n            }})\n\n    return [hierAssessResults, hierProblemResults]\n\n}","import React, { useContext } from 'react';\n\nimport {\n    Button,\n    Nav,\n    Navbar,\n    NavbarBrand,\n    NavbarText,\n} from \"reactstrap\";\n\nimport { AuthContext } from \"@meddbriefer/mdb-auth\"\n\n// {/* <Button color=\"primary\" onClick={prefsToggler}>\n//     Preferences\n// </Button> */}\n\n\nconst MDBNavBar = ({title, leftNav = null, rightNav = null }) => {\n\n    const { isAuthenticated, userName, signOutUser } = useContext(AuthContext)\n\n    return (\n        <Navbar color=\"dark\" dark>\n\n            <NavbarBrand href=\"#\">\n                MedDBriefer\n            </NavbarBrand>\n\n            {!!leftNav &&\n                <Nav>\n                {leftNav}\n                </Nav>\n            }\n\n            {!!title &&\n                <NavbarText tag=\"h3\">{title}</NavbarText>\n            }\n\n            <Nav>\n                {isAuthenticated &&\n                <>\n                    <NavbarText>\n                        Welcome, {userName} &nbsp;\n                    </NavbarText>\n                    <Button\n                        color=\"danger\"\n                        onClick={signOutUser}\n                    >\n                        Sign Out\n                    </Button>\n                </>\n                }\n                {!!rightNav &&\n                    rightNav\n                }\n            </Nav>\n\n        </Navbar>\n    )\n}\n\nexport default MDBNavBar;\n","import React, { useState, useEffect } from 'react';\nimport { Button, Table } from 'reactstrap';\nimport MDBNavBar from \"./MDBNavBar\"\nimport { getAssessmentIcon, getColor, getFeedback, getTimestamp, saveAnalysisLog} from \"./debriefingUtils\"\n\n\n\nconst DisplayBaseDebriefing = ({log, actions, scenario, context}) => {\n    const [showCommentColumn, setShowCommentColumn] = useState(false);\n    // eslint-disable-next-line\n    //const [events, setEvents] = useState(log.events);\n    const [formattedActions, setFormattedActions] = useState(undefined);\n\n// const Debriefing = ({ log, metaData, criticalActions, associations }) => {\n    /* const toggleCommentColumn = () => {\n        setShowCommentColumn(!showCommentColumn);\n    } */\n    \n\n    const saveAnalysisLogLocally = () => {\n        saveAnalysisLog(log,formattedActions)\n    }\n\n    const toggleComments = () => {\n        setShowCommentColumn(!showCommentColumn)\n    }\n\n    const dispHeaderRow = (entry) => {\n        return (\n            <>\n                {entry.id ===  \"assessmentHeader\"  || entry.id === \"assessmentSubHeader\"\n                    ? <td colSpan=\"4\" className={getColor(entry)}>\n                        <b>{entry.label}</b>\n                    </td>\n                    : <td colSpan=\"10\" className={\"black\"} >\n                        <div><em>\n                        &nbsp;&nbsp;&nbsp;Intervention Group: {entry.probLabel}</em></div>\n                    </td>}\n            </>\n        )\n    }\n    \n    function getLabel(entry) {\n        return(\n            <>\n            {entry.type === \"obtain-vital-sign\"\n                ? vitalLabel(entry)\n                : regularLabel(entry)\n            }\n            </>\n    \n        )\n    }\n    \n    function getStatusLabel(entry){\n        let metaData = scenario.intvMetaData\n        let metaEntry = metaData.find(me => (entry.vital === me.id))\n        return(<>{metaEntry.label}</>)\n    }\n    \n    function vitalLabel(entry){\n        return(\n            <>\n            {entry.vitalType === \"intervention-status\"\n                ? <>Requested intervention status for: {getStatusLabel(entry)}, <p>Found: <i>{entry.value}</i></p></>\n                : <>Requested vital: {entry.vital}, <p>Found: <i>{entry.value}</i></p></>\n            }\n            </>\n        )\n    }\n    \n    function regularLabel(entry) {\n        return(\n            <>\n            {entry.subPhase && entry.type !== \"intervention\"\n                ? <><b>{entry.subPhase}:</b> {entry.actionDescription}.  {findingsData(entry)}</>\n                : <>{phaseLabel(entry)}</>\n        }\n            </>\n        )\n    }\n    \n    function phaseLabel(entry){\n        return(\n            <>\n            {entry.type === \"intervention\"\n                ? <><b>Intervention:</b> {entry.actionDescription}. {findingsData(entry)} </>\n                : <>{entry.actionDescription}.  {findingsData(entry)}</>\n                }\n            </>\n        )\n    }\n        \n    function findingsData(entry){\n        return(\n            <>\n            {entry.finding\n            ?<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Findings: <i>{entry.finding}</i></p>\n            :<></>\n        }\n            </>\n        )\n    \n    }\n    \n    \n     function saveComment(val) {\n        let orig = val.target.defaultValue;\n        let comment = val.target.value;\n        let entryID = val.target.id;\n        if (orig !== comment){\n            let entry = formattedActions.find(entry => (entry.id === entryID))\n            // if (entry) { entry.comment = comment }}\n            const newEntry = Object.assign({}, entry, {comment: comment})\n            updateFormattedAction(newEntry)\n        }\n    }\n    \n    const dispDataRow = (entry) => {\n        return (\n            <>\n                <td>{entry.numericalID}</td>\n                <td>{getTimestamp(entry)}</td>\n                <td className={getColor(entry)}>\n                    <span className=\"material-icons-outlined\">{getAssessmentIcon(entry)}</span>\n                    {getLabel(entry)}\n                </td>\n                <td>{getFeedback(entry)}</td>\n\n                {showCommentColumn && <td><textarea rows=\"2\" cols=\"50\" defaultValue={entry.comment} onBlur={saveComment} id={`${entry.id}`}/></td>}\n            </>\n        )\n    }\n\n    \n    const updateFormattedAction = (record) => {\n        const index = formattedActions.findIndex(rec => rec.id === record.id)\n        setFormattedActions([\n            ...formattedActions.slice(0, index),\n            record,\n            ...formattedActions.slice(index+1)\n        ])\n    }    \n\n\n    async function displayIt () {\n        \n        \n        if (context === \"review\"){\n            //console.log(\"displaying for review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(true)        \n        }\n        else {\n            //console.log(\"displaying for non-review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(false)\n              }\n\n        setFormattedActions(actions)\n    \n        \n    }\n\n    \n   \n\n\n// eslint-disable-next-line\nuseEffect(\n    () => {\n        displayIt()\n        // eslint-disable-next-line\n    }, [] // empty list means this code will only be run on initial render\n)\n\n\n\nif (undefined === formattedActions) {\n    return (<h3>processing</h3>)\n}\n\nreturn (\n        <>\n            {context === \"review\"\n                ? <><MDBNavBar\n                    title={`Review of: ${log.label}`}\n                    leftNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={saveAnalysisLogLocally}>Save Debriefing Log\n                        </Button>}\n                    rightNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={toggleComments}>Toggle Comments\n                        </Button>}\n                     /></>\n                : <><MDBNavBar\n                    title={`Analysis for: ${log.label}`}\n                    /></>\n            }\n            <form>\n            <div style={{ overflowY: \"auto\", maxHeight: \"700px\" }}>\n                <Table borderless size=\"sm\">\n                    <thead>\n                        <tr>\n                            <th className=\"table-header\"> ID </th>\n                            <th className=\"table-header\"> Timestamp </th>\n                            <th className=\"table-header\"> Action Description </th>\n                            <th className=\"table-header\"> Feedback </th>\n                            {showCommentColumn && <th className=\"table-header\"> Comments </th>}\n                        </tr>\n                    </thead>\n                    <tbody className=\"scrolling\">\n                        {formattedActions.map((currentEntry, index) => (\n                            <tr key={index}>\n                                {currentEntry.type === \"header\"\n                                    ? dispHeaderRow(currentEntry)\n                                    : dispDataRow(currentEntry)\n                                }\n                            </tr>\n                        ))}\n                    </tbody>\n                </Table>\n            </div>\n        </form>\n        </>\n\n    )\n}\n\nexport {saveAnalysisLog}  \nexport default DisplayBaseDebriefing\n","import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID } from '@meddbriefer/scenario-data/index'\nimport {analyzeEvents} from './analyzeEvents'\nimport DisplayBaseDebriefing from './DisplayBaseDebriefing';\n\n\n\nfunction AnalyzeDebriefing ()  {\n    const { logID } = useParams()\n    const [observerLog, setObserverLog] = useState (undefined)\n    const [log, setLog] = useState(undefined)\n    const [scenario, setScenario] = useState(undefined)\n    const [analyzed, setAnalyzed] = useState(false)\n    const [loaded, setLoaded] = useState(false)\n\n    // eslint-disable-next-line\n    \n    // Set to true once all performed actions have been displayed in the log\n    // const [finishedPerformedActions, setFinishedPerformedActions] = useState(false);\n\n    //console.log (\"logID:\", logID)\n\n    function checkOnOverwriting() {\n        if (window.confirm (\"Are you sure you want to overwrite the existing analysis?  Any prior comments previously added will be lost.\")){\n            analyzeEventsHook(scenario, observerLog) \n            \n        }\n\n    }\n\n    async function analyzeEventsHook(scenario, log) {\n      analyzeEvents(scenario, log)}\n\n    \n    async function processEvents ()  {\n        //console.log(\"in processEvents to process a new observer file\")\n        if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n            {analyzeEventsHook(scenario, observerLog)\n            setAnalyzed(true)} \n        else {checkOnOverwriting()} \n        setAnalyzed(true)\n        return (true)    \n    }\n\n    useEffect(\n        () => {\n          getLog(db,logID)\n            .then(observerLogData => {  \n              //console.log(\"retrieve observerLogData\", observerLogData) \n              setObserverLog(observerLogData)    \n            })\n            .catch(error => alert('error fetching observer log', error))   \n        // eslint-disable-next-line\n    }, []\n      )\n    \n      useEffect(\n        () => {\n          !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n            .then(scenData => {\n              console.log(\"retrieve scenario:\", scenData)\n              setScenario(scenData)\n            })\n    \n        }, [observerLog]\n      )\n    \n      useEffect(\n        () => {\n          !!scenario && processEvents()\n          //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n    \n      useEffect(\n        () => {\n          !!analyzed && getDebriefLog(db, logID)\n            .then(logData => {\n              //console.log(\"retrieve Debriefing result:\", logData)\n              setLog(logData)  \n            })\n            .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n    \n      useEffect(\n        () => {\n          !!log && setLoaded(true) \n        }, [log]\n      )\n    \n      if (!loaded) {\n        return (<h3>Loading</h3>)\n      }\n    \n\n\n    return (\n        <DisplayBaseDebriefing\n        log={log}\n        actions={log.events}\n        scenario={scenario}\n        context={\"initial-analysis\"}\n        />\n    )\n}\n\nexport default AnalyzeDebriefing","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLog , getPublishedScenarioByID } from \"@meddbriefer/scenario-data/index\"\nimport AnalyzeDebriefing from '../components/AnalyzeDebriefing'\n\nconst Log = () => {\n\n  const { logID } = useParams()\n  const [ log, setLog ] = useState(null)\n  const [ scenario, setScenario] = useState(null)\n  const [loaded, setLoaded] = useState(false)\n\n  useEffect(\n    () => {\n      getLog(db,logID)\n        .then(logData => {\n          setLog(logData)\n        })\n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      //!!log && getScenarioByName(db, log.scenarioName, \"V2\")\n      !!log && getPublishedScenarioByID(db, log.scenarioID)\n        .then(scenData => {\n          setScenario(scenData)\n          console.log(\"scenario\", scenData)\n        })\n\n    }, [log]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && setLoaded(true)\n    }, [scenario]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n  return ( \n      <AnalyzeDebriefing \n        log={logID} \n      /> \n    )\n\n\n}\n\nexport default Log;\n","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { analyzeEvents } from '../components/analyzeEvents'\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID} from \"@meddbriefer/scenario-data/index\"\nimport DisplayBaseDebriefing from '../components/DisplayBaseDebriefing'\n\n\n\nfunction DisplayDebriefing () {\n\n  const { logID } = useParams()\n  const [observerLog, setObserverLog] = useState(undefined)\n  const [log, setLog] = useState(undefined)\n  const [scenario, setScenario] = useState(undefined)\n  const [analyzed, setAnalyzed] = useState(false)\n  const [loaded, setLoaded] = useState(false)\n\n  \n  \n  async function processLog () {\n    //console.log(\"in processLog to display existing analysis\")\n    if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n          {analyzeEvents(scenario, observerLog) \n          }\n    setAnalyzed(true)\n    return (true)\n  }\n  \n\n  //get observer log first\n\n  useEffect(\n    () => {\n      getLog(db, logID)\n        .then(observerLogData => {  \n          //console.log(\"retrieve observerLogData\", observerLogData) \n          setObserverLog(observerLogData)    \n        })\n        .catch(error => alert('error fetching observer log', error))   \n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n        .then(scenData => {\n          console.log(\"scenario:\", scenData)\n          setScenario(scenData)\n        })\n\n    }, [observerLog]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && processLog()\n      //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n      \n  useEffect(\n      () => {\n        !!analyzed && getDebriefLog(db,logID)\n          .then(logData => {\n            //console.log(\"retrieve Debriefing result:\", logData)\n            setLog(logData)  \n          })\n          .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n\n  useEffect(\n    () => {\n      !!log && setLoaded(true) \n    }, [log]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n\n\n  return (\n    <DisplayBaseDebriefing\n      log={log}\n      actions={log.events}\n      scenario={scenario}\n      context={\"review\"} />\n  )\n\n\n}\n\nexport default DisplayDebriefing;\n","import React from \"react\"\n\nimport MDBNavBar from \"./MDBNavBar\"\n\nconst UnauthedLayout = (props) => {\n\n    return (\n        <>\n            <MDBNavBar\n                title=\"MedDBriefer Authentication\"\n            />\n            { props.children }\n        </>\n    )\n}\n\nexport default UnauthedLayout","import React from \"react\"\n\nimport {\n    HashRouter as Router,\n    Switch,\n} from \"react-router-dom\"\n\nimport { AuthProvider, PrivateRoute } from \"@meddbriefer/mdb-auth\"\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport \"./styles.css\";\n\nimport LogList from \"./routes/LogList\"\nimport Log from \"./routes/Log\"\nimport DisplayDebriefing from \"./routes/DisplayDebriefing\"\n\n\nimport UnauthedLayout from \"./components/UnauthedLayout\"\n\nconst App = (props) => {\n\n    return (\n        <AuthProvider>\n            <Router>\n\n                <Switch>\n                    <PrivateRoute\n                        exact path=\"/logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={Log}\n                    />\n                    <PrivateRoute\n                        exact path=\"/debriefing-feedback-logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={DisplayDebriefing}\n                    />\n                    {/*default (catchall) route*/}\n                    <PrivateRoute\n                        exact match=\"/\"\n                        authFlowLayout={UnauthedLayout}\n                        component={LogList}\n                    />\n                </Switch>\n            </Router>\n        </AuthProvider>\n    )\n}\n\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
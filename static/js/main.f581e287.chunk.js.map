{"version":3,"sources":["../../../libs/mdb-firebase/index.js","components/analyzeEvents.js","../../../libs/scenario-data/constants.js","../../../libs/scenario-data/index.js","../../../libs/scenario-data/intvPrompts.js","../../../libs/scenario-data/intvMenuItems.js","routes/LogList.js","components/debriefingUtils.js","utils.js","components/scenarioDataAccesors.js","components/MDBNavBar.js","components/DisplayBaseDebriefing.js","components/AnalyzeDebriefing.js","routes/Log.js","routes/DisplayDebriefing.js","components/UnauthedLayout.js","App.js","reportWebVitals.js","index.js"],"names":["userApp","getOrInitializeApp","appCfg","name","app","appID","matches","firebase","apps","filter","options","appId","length","getApp","initializeApp","process","REACT_APP_APP_ENV","console","log","apiKey","authDomain","projectId","storageBucket","messagingSenderId","measurementId","requiredSubphases","requiredPhaseNames","requiredPhaseAndSubPhases","scenario","itemByID","itemByLabel","checklistHierarchy","prodApp","db","auth","firestore","ASSESS","ASSESS_OPTION","AWO","DECISION","DECISION_OPTION","INTERV","PHASE","REQUIRED","SUB_PHASE","MDB_TYPES","Object","freeze","ASSESSO","CL_HEADING","CL_PROMPT","DIST_PROMPT","NESTED_CHECKLIST","REQURED","PROMPT_SET","PROMPT","ANSWER","SELECTION_TYPES","ONE","OOM","NONE","CHECKLIST_STEP_TYPES","AW","BR","BL","SH","OPTION_TYPES","ANALYSIS_TYPES","MIN","OPT","CONTRA","getPublishedScenarioByID","ST","interventionID","scenarioID","collection","doc","get","then","data","verifyDocument","collectionId","documentId","a","where","set","empty","getLog","logID","id","getDebriefLog","LogList","useState","logs","setLogs","logsLoaded","setLogsLoaded","useEffect","querySnapshot","docs","map","label","scenarioName","userName","timestamp","result","catch","error","Table","striped","borderless","size","hover","to","exceptionDefs","exceptions","colorTypes","iconTypes","assessmentEntries","getStatesForStatus","status","stateList","entries","state","push","getAssessmentEntry","currentEntry","aIndex","getColor","fixStrSp","textString","newString","textArray","split","lenTextArray","forEach","item","i","newItem","trim","getFeedback","intvStatus","intvStatusFB","fb","checked","notChecked","entry","foundCk","generateIntvStatusFB","feedbackString","feedbackArray","firstChar","charAt","substring","previousString","slice","nextString","toUpperCase","temporalConstraints","before","beforeOp","after","afterOp","type","intvChecks","intvStatusNeeded","vitalsNeeded","getEvents","events","field","val","getEventsByIdTime","_","require","saveAnalysisLog","actions","docRef","ObserverFileCreater","ObserverFileName","commenter","schemaVersion","Date","toLocaleString","newActionsList","newObj","filterUnknown","logObj","index","key","undefined","pickBy","value","getTimestamp","seconds","toISOString","substr","groupByKey","listOfObjs","fldName","reduce","hash","obj","concat","getChecklistItemsByType","itemType","checkListMetaData","e","problemStates","cautionStates","subPhases","initGlobals","scen","initializeItemLookupByID","initializeItemLookupByLabel","phases","clSteps","includes","stepOptions","step","phChecklistSteps","subPhase","spChecklistSteps","sp","items","phSubphases","ph","getChecklistHierarchy","findPhaseSubphasesOrdered","checklistLookupByID","intvLookupByID","intvMetaData","assign","checklistLookupByLabel","intvLookupByLabel","subPhIds","findNameNumID","names","occurrence","numericalID","numericalIDStart","numericalIDEnd","getItem","storeMisOrderedFB","FB","phaseNames","objToModify","phaseIndex","phaseObjects","phaseName","hasSubPhases","findObjByNumerialID","orderingFB","checkAgainst2ndArgs","arg1st","args2nd","op","direction","entryNames","endNum1st","startNum1st","label1st","parPhFB","arg","arg2nd","label2nd","startNum2nd","endNum2nd","checkAgainstKB","listOfNames","listOfEntries","uniqueListOfNames","startIndex","endIndex","phaseObjectNames","collectEntriesToCheckConstraints","uniqueEntryNames","firstArg","firstArgItem","constraint","constraints","collectConstraints","checkConstraintsForArg","insertInPhaseInOrder","object","objIndex","phase","when","lastIndexOf","splice","getEndSubPhaseIndex","inPhaseId","subPhaseName","getSubPhases","reversedSubPhases","reverse","find","getEndSubPhase","phaseId","determineHLcolor","lowerColor","higherColor","newColor","evalForIncorrectAnswer","promptID","answerID","isIntervention","answers","associations","checkListCorrectness","Array","isArray","ansId","getCorrectAnswerLabel","metaData","answerLabels","answer","j","getAnswerLabel","answerLabel","analyzeEvents","problems","problemDefs","problemDef","problem","assessments","allProblemProtocols","protocol","probLabel","lifeThreat","solution","solutions","contraindications","minimalWhy","protocols","setupProblems","formattedActions","annotatedResults","confirmedEvents","trackForStatus","priorPhase","parentPhase","parentIndex","event","eventObj","actionDescription","workingPhase","expertPhase","eventType","processingState","prioreventObj","correctAnswerLabel","givenAnswerLabel","wrongAnswer","answerDetails","intervention","pop","answerCorrect","incorrectAnswersFB","vital","vitalType","vitalEntry","vitalEntries","updatedEntries","updateVital","prob","PROBLEM_ACTION_FIELDS","action","k","statusChecking","intv","initialEntry","assessmentsNeeded","optional","required","suggestedPhase","contra","why","contraindicatedWhy","incorrectAnswerFB","annotateInputEvents","intvsTracking","kbUpdates","updatedPhases","priorPh","insertionIndex","insertMissingSubphases","postAssessmentReview","neededScenAssessments","collectScenAssessments","indexCounter","checklistSteps","md","exceptionDef","exception","cls","phaseObject","assessmentFB","assessmentFindings","checkForMissingAssessments","orderedArrayObjects","objectsBefore","objectBefore","requiredObjectBefore","objectAfter","requiredObjectAfter","indexBefore","indexAfter","indexRequiredBefore","indexRequiredAfter","findIndex","insertInPhaseRelativeToSuggestedOrder","statusTracking","toUpdate","insertMissingIntvChecks","displayObjects","entryIndex","headerIndex","problemHeaderColor","subPhaseColor","newPhaseObjects","headerObj","priorHLPhase","endEntry","iPhaseObjects","localPhaseName","highLevelPhase","header","organizeLogDisplay","finalActions","pActions","pNames","pIndex","pActIndex","indexOf","processedIds","pIds","pEntry","actionNeeded","minimalNeeded","minimal","found","allActionFound","allMinimalFound","numericalIDsChanged","foundId","z","candidateHeader","foundHeader","findHeaderFor","MDBNavBar","title","leftNav","rightNav","useContext","AuthContext","isAuthenticated","signOutUser","Navbar","color","dark","NavbarBrand","href","Nav","NavbarText","tag","Button","onClick","DisplayBaseDebriefing","context","showCommentColumn","setShowCommentColumn","setFormattedActions","getLabel","vitalLabel","regularLabel","getStatusLabel","metaEntry","me","findingsData","phaseLabel","finding","saveComment","orig","target","defaultValue","comment","entryID","newEntry","updateFormattedAction","dispDataRow","className","rows","cols","onBlur","record","rec","displayIt","style","overflowY","maxHeight","colSpan","AnalyzeDebriefing","useParams","observerLog","setObserverLog","setLog","setScenario","analyzed","setAnalyzed","loaded","setLoaded","checkOnOverwriting","window","confirm","analyzeEventsHook","observerLogData","alert","scenData","processEvents","logData","Log","DisplayDebriefing","processLog","UnauthedLayout","props","children","App","exact","path","authFlowLayout","component","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f581e287.chunk.js","sourcesContent":["import firebase from 'firebase/app'\nimport \"firebase/auth\";\nimport \"firebase/firestore\"\n\nconst prodFirebaseCfg = {\n    apiKey: \"AIzaSyBOgWAbXUGckpad2sk0IUo00hZsV4WxG0E\",\n    authDomain: \"meddbriefer-68cd4.firebaseapp.com\",\n    projectId: \"meddbriefer-68cd4\",\n    storageBucket: \"meddbriefer-68cd4.appspot.com\",\n    messagingSenderId: \"1087114796018\",\n    appId: \"1:1087114796018:web:679fbab38dbf78af0ce96b\",\n    measurementId: \"G-Q7QZKC9KHW\"\n}\n\nconst devFirebaseCfg = {\n    apiKey: \"AIzaSyBqnEMwEstp4D7Mvtbw9OTAiNJ7qza0Ses\",\n    authDomain: \"meddbriefer-dev.firebaseapp.com\",\n    projectId: \"meddbriefer-dev\",\n    storageBucket: \"meddbriefer-dev.appspot.com\",\n    messagingSenderId: \"144940722070\",\n    appId: \"1:144940722070:web:4de179ebb58d84a7679fb7\"\n};\n\n\nconst pamFirebaseCfg = {\n    apiKey: \"AIzaSyB9eVT-fu4TOjxHoPAXqsnz9tCcbTJkTOw\",\n    authDomain: \"pamdev-ea800.firebaseapp.com\",\n    projectId: \"pamdev-ea800\",\n    storageBucket: \"pamdev-ea800.appspot.com\",\n    messagingSenderId: \"366450927885\",\n    appId: \"1:366450927885:web:caa5f022ef1de182a0e844\",\n    measurementId: \"G-JC5XZEPYT1\"\n  };\n\n  const scottFirebaseConfig = {\n  apiKey: \"AIzaSyBEhbIdVW2F2vvvfvpNb2SsCDP9Yoc__z8\",\n  authDomain: \"scottdev-f6528.firebaseapp.com\",\n  projectId: \"scottdev-f6528\",\n  storageBucket: \"scottdev-f6528.appspot.com\",\n  messagingSenderId: \"447730403122\",\n  appId: \"1:447730403122:web:1727020dbac4ad4cf6f92b\"\n\n};\n\n// console.log(`NODE_ENV: ${process.env.NODE_ENV}`)\n\nlet userApp\n\nconst getApp = (appID) => {\n    const matches = firebase.apps.filter(app => app.options.appId === appID)\n    // console.log(\"matches\", matches)\n    return (matches.length === 1) ? matches[0] : null\n}\n\nconst getOrInitializeApp = (appCfg, name) => {\n    const app = getApp(appCfg.appId)\n    // console.log(`${appCfg.appId} already exists: ${!!app}`)\n    return (!!app) ? app : firebase.initializeApp(appCfg, name)\n}\n\n// don't reinitialize app if it already exists\n// const prodApp = !firebase.apps.length ? firebase.initializeApp(prodFirebaseCfg) : firebase.app()\n//const prodApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\nif (\"pam\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using pjordan config\")\n    userApp = getOrInitializeApp(pamFirebaseCfg, \"pam\")\n} else if (\"scott\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using scott config\")\n    userApp = getOrInitializeApp(scottFirebaseConfig)\n}\nelse {\n    console.log(\"using production config\")\n    userApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\n}\n\nconst prodApp = userApp;\n// const devApp = function() {\n//     if (process.env.NODE_ENV !== \"production\") {\n//         return getOrInitializeApp(devFirebaseCfg, \"development\")\n//      }\n//      return null\n// }()\n\n// console.log(firebase.apps)\n\n\n\n\nexport const auth = prodApp.auth()\nexport const db = prodApp.firestore()\n\n// export const db = function() {\n//     return process.env.NODE_ENV !== \"production\" ? devApp.firestore() : prodApp.firestore()\n// }()\n","import { MDB_TYPES, ANALYSIS_TYPES } from '@meddbriefer/scenario-data/constants.js';\nimport { collectConstraints, exceptionDefs, getStatesForStatus, saveAnalysisLog, intvChecks, getEventsByIdTime} from \"./debriefingUtils\"\nimport { getChecklistItemsByType, getChecklistHierarchy, groupByKey } from './scenarioDataAccesors';\n//import { foo } from \"@meddbriefer/feedback-data\"\n\n//console.log(foo())\n\nconst problemStates = getStatesForStatus(\"Problem\")\nconst cautionStates = getStatesForStatus(\"Caution\")\nlet insertInterventionHeader = false  //setting to true helps during debugging analysis\n//index of subphase names and value is phase id to which belongs\nlet subPhases = {}\n// list of all subphase IDs\nlet requiredSubphases\nlet requiredPhaseNames\nlet requiredPhaseAndSubPhases\nlet scenario\nexport var itemByID\nexport var itemByLabel\n// sts 1/23/22 - added as global\nlet checklistHierarchy\n\nfunction initGlobals(scen) {\n    scenario = scen\n    itemByID = initializeItemLookupByID(scen)\n    itemByLabel = initializeItemLookupByLabel(scen)\n    requiredPhaseNames = getChecklistItemsByType(scen, MDB_TYPES.PHASE).map(e => e.id)\n    requiredSubphases = getChecklistItemsByType(scen, MDB_TYPES.SUB_PHASE).map(e => e.id)\n    checklistHierarchy = getChecklistHierarchy(scen)\n    requiredPhaseAndSubPhases = findPhaseSubphasesOrdered(checklistHierarchy)\n    checklistHierarchy.forEach(ph => {\n        if (undefined === ph.subPhases) {\n            subPhases[ph.id] = ph.label} \n        else {\n            ph.subPhases.forEach(sp => {\n                subPhases[sp.id] = ph.label})}})\n}\n\n//This starts section for accessing checklist and intervention components by id or label\nconst initializeItemLookupByID = (scenario) => {\n    let checklistLookupByID = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let intvLookupByID = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let result = Object.assign(checklistLookupByID, intvLookupByID)\n    return result}\n\nconst initializeItemLookupByLabel = (scenario) => {\n        let checklistLookupByLabel = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let intvLookupByLabel = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let result = Object.assign(checklistLookupByLabel, intvLookupByLabel)\n        return result}\n\n\nconst findPhaseSubphasesOrdered = (phases) => {\n    let result = []\n    phases.forEach(ph => {\n        if (!!ph.subPhases){\n            let subPhIds = ph.subPhases.map(e => e.id)\n            //not currently useful to collect parent phases unless there were no subphases\n            //if parent phase included subphases and steps then it should be in this result\n            //result = result.concat(ph.id)\n            result = result.concat(subPhIds)\n        }\n        else {result = result.concat(ph.id)}})\n    return result\n}\n\nconst collectScenAssessments = (problems) => {\n    let assessments = []\n    problems.forEach(prob => {\n        if (prob.assessments !== \"\"){\n            assessments = assessments.concat(prob.assessments)}})\n    return assessments\n}\n\n//will need to update to comply with any relevant constraints on phases and subphases\nconst insertMissingSubphases = (phases,phaseNames) => {\n    let priorPh\n    requiredPhaseAndSubPhases.forEach((phase, i) => {\n        if (!phaseNames.includes(phase)) {\n            //find last index for phase before and splice after that    \n            if (i === 0){\n                priorPh = requiredPhaseAndSubPhases[0]\n            }\n            else {priorPh = requiredPhaseAndSubPhases[i-1]}\n\n            let insertionIndex = 0\n            if (priorPh !== phase){\n                insertionIndex = phaseNames.lastIndexOf(priorPh)\n                insertionIndex = insertionIndex + 1}\n            \n            phaseNames.splice(insertionIndex, 0, phase); //insert it where it should have appeared\n            phases.splice(insertionIndex, 0, []); //add the empty array for phase objects\n        }});\n    return[phases,phaseNames]\n}\n\n\n\nconst updateVital = (vitalEntries, timestamp) => {\n    let updatedEntries = []\n    vitalEntries.forEach(vitalEntry => {\n        if (vitalEntry.timestamp < timestamp){\n            vitalEntry[\"foundCk\"] = true}\n        updatedEntries.push(vitalEntry)\n    })\nreturn updatedEntries\n}\n\n//initial review of observer log to add annotations to what was found in the observer log.  Filters out things not processing \n// and pulls together interventions and prompt answers into one event and fields to each event that will fill in in later analysis,\n// fills in problem information for interventions found in observer log and\n// sets up the phases and phaseNames structures for events in the observation log and initiates\n// record of what have encountered so far in the observations in order to recognize what is missing in later stages of analysis\nconst annotateInputEvents = (events,problems) => {\n    let confirmedEvents = [];\n    //instead of a multi-dimensional array, am using an array of phase and subphase names e.g. \"BSI\", \"prinary\" and\n    let phaseNames = [];\n    let phases = []; //and another array with the actual content for each phase.  I can search phaseNames for the last item\n    let phaseObjects = [];\n    let trackForStatus = {};  //save correct interventions that were done that require status checks later\n\n    // phases entry of that name and then use that index to retrieve the appropriate phase entried to\n    //add on the missing items (assessment or intervention) for that phase\n    let priorPhase = \"\";\n    let parentPhase = \"\"\n    let parentIndex = 0\n    let phaseIndex = 0;\n\n    // created annotated object for each event\n    events.forEach((event, i) => {\n        // Each eventObj is one of the lines in the displayed base log\n        // Set up fields for extra annotations for this event after analyzing each event\n        let eventObj = {\n            \"comment\": \"\",\n            \"numericalID\": i,\n            \"status\": \"\",\n            \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n            \"contraindicatedWhy\": \"\",\n            \"minimalWhy\": \"\",\n            \"why\": \"\",\n            \"answerCorrect\": true,\n            \"answerDetails\": {},\n            \"expertPhase\": \"\",  //filled in only for interventions\n            \"workingPhase\": \"\",  //is subphase of phase if there is no subphase\n            \"suggestedPhase\": \"\", //mostly for interventions so don't override info on when was originally done\n            \"protocol\": \"\",\n            \"probLabel\": \"\",\n            \"assessments\": \"\",\n            \"required\": false,\n            \"actionDescription\": \"\",\n            \"assessmentFB\": \"\",\n            \"incorrectAnswersFB\": \"\",\n            \"orderingFB\": \"\",\n            \"processingState\": \"good\" // values of good/bad used to filter out events not needed for analysis or displaying\n        };\n\n        // copy over the event fields that exist in the input log from observer UI (which is type dependent)\n        const EVENT_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"vitalType\", \"vital\", \"value\", \"type\", \"prompt\", \"promptID\", \"intervention\", \"timestamp\"];\n        EVENT_FIELDS.forEach(fldName => {\n            if (!!event[fldName]) {\n                eventObj[fldName] = event[fldName];\n            }\n        });\n\n        //copy event fields if defined to initialize some of the above annotation fields\n        if (!!event.label) { eventObj.actionDescription = event.label; }\n        if (!!event.type) { eventObj.status = event.type; }\n        // prefer subPhase if available\n        if (!!event.subPhase) { eventObj.workingPhase = event.subPhase; }\n        else {\n            if (!!event.phase) { eventObj.workingPhase = event.phase; }}\n        eventObj.expertPhase = eventObj.workingPhase;\n\n        //if current phase same as prior then keep on with the current phase\n        // otherwise initialize for a new phase\n        if (priorPhase !== eventObj.workingPhase || parentPhase !== eventObj.phase) {\n            if (priorPhase !== \"\") {  //don't need to initialize\n                //save phaseObjects in phases and in parent phase if different index than current phase\n                phases[phaseIndex] = phaseObjects;\n                if (phaseIndex !== parentIndex){\n                    phases[parentIndex] = phases[parentIndex].concat(phaseObjects);  \n                }\n                phaseIndex++\n                \n                //if upcoming parent phase is different than current parent phase then set up\n                //for a new parent phase\n                if (eventObj.phase !== parentPhase){ \n                    parentPhase = eventObj.phase\n                    parentIndex = phaseIndex\n                    // if the upcoming is truly a parent with subphases \n                    // then add an extra entry for the new parent phase \n                    if (eventObj.phase !== eventObj.workingPhase) {\n                        //create the new parent phase\n                        phases[parentIndex] = []\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++\n                    }}}\n            else {\n                // first item in events so initialize\n                parentPhase = eventObj.phase\n                // if the event parent phase is not the same as the subPhase\n                // then we need to save that parent phase in phases and phaseNames\n                if (parentPhase !== eventObj.phase) {\n                    parentPhase = eventObj.phase\n                    phaseNames[parentIndex] = parentPhase\n                    phaseIndex++;\n                }}\n            //now setup for collecting for the current phase\n\n            priorPhase = eventObj.workingPhase;\n            phaseObjects = [];\n            phaseNames[phaseIndex] = priorPhase;\n            phases[phaseIndex] = []}  \n\n\n        let eventType = eventObj.type;\n        // List of types in log that are currently processed.  Rest are filtered out.\n        let processedTypes = [\"assessment\", \"required-action\", \"intervention\", \"answer\", \"obtain-vital-sign\", \"decision-option\", \"assessment-option\"];\n\n        //skip over adding anything not of these types to the debriefing display for now\n        if (!processedTypes.includes(eventType)) {\n            eventObj.processingState = \"bad\";\n        }\n\n        // when get an answer for an intervention prompt, grade the response.  The intervention itself is later in the event log, so\n        // accumulate the answers and grading and then when an intervention is later found we can use the intervention\n        // event itself and move all the answer results into it\n        let prioreventObj = [];\n        if (eventType === \"answer\") {\n            //make sure we have answer info for this promptID\n            let correctAnswerLabel = getCorrectAnswerLabel(event.promptID, true);\n            let givenAnswerLabel = getAnswerLabel(event.id, true);\n            //if we don't have answer info for this prompt ID then just ignore this entry\n            if (!correctAnswerLabel) {\n                eventObj.processingState = \"bad\"}\n            else {\n                //currently returns correct answer-id if has answered incorrectly or false if answered correctly\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, true);\n                //store details of this answer and its grading\n                let answerDetails = {\"correctAnswer\": correctAnswerLabel, \"givenAnswer\": givenAnswerLabel, \"correct\": !wrongAnswer}\n                \n                //have answer to prior question for this intervention\n                if (confirmedEvents.includes(eventObj.intervention)) {\n                    prioreventObj = phaseObjects.pop();\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    //add the answer student gave to the action description\n                    eventObj.actionDescription = prioreventObj.actionDescription + \", \" + givenAnswerLabel;\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        if (prioreventObj.incorrectAnswersFB === \"\") {\n                            eventObj.incorrectAnswersFB = \"should have responded \" + correctAnswerLabel;\n                            }\n                        else {eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB + \", and \" + correctAnswerLabel;\n                            }}\n                    else {\n                        eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                        eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    }}\n                //first answer for this intervention\n                else { \n                    //put the answer student gave in the action description\n                    //responding to first answer\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        eventObj.incorrectAnswersFB = \"should have responded \" + correctAnswerLabel;\n                    }\n                    else { eventObj.incorrectAnswersFB = \"\"; }\n                    confirmedEvents.push(eventObj.intervention);\n                }\n                eventObj.answerDetails[event.promptID] = answerDetails}}\n\n        if (eventType === \"intervention\") {\n            prioreventObj = phaseObjects.slice(-1)[0]; //slice returns an array rather than the last object in array\n            if (prioreventObj && prioreventObj.type === \"answer\" && prioreventObj.intervention === eventObj.id) {\n                prioreventObj = phaseObjects.pop();\n                eventObj.answerCorrect = prioreventObj.answerCorrect;\n                eventObj.answerDetails = prioreventObj.answerDetails;\n                eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                eventObj.actionDescription = eventObj.actionDescription + \".\\xa0\\xa0\" + prioreventObj.actionDescription\n                /* if (prioreventObj.incorrectAnswersFB === \"\") {\n                    eventObj.incorrectAnswersFB = eventObj.label;\n                }\n                else {\n                    eventObj.incorrectAnswersFB = eventObj.label + \", \" + prioreventObj.incorrectAnswersFB;\n                } */\n            }}\n\n        if (eventObj.processingState === \"good\") {\n\n            if (eventObj.type === \"obtain-vital-sign\"){\n                //if it is an intervention status check then the vital field contains\n                //the intervention id and otherwise the vital label\n                let vital = eventObj.vital\n                let type = \"\"\n                if (eventObj.vitalType === \"intervention-status\"){\n                    if (confirmedEvents.includes(vital)){\n                        type = \"intv\"}\n                    else {type = \"noIntv\"}\n                    }\n                else {type = \"vital\"}\n                \n                //update trackForStatus relative to this \"vital\"\n                let vitalEntry = trackForStatus[vital]  \n                //set the status for this particular vital (i.e. makes sense to ask for it or not)\n                switch (type){\n                    case \"intv\": \n                        eventObj.status = \"patientIntvCheck\"\n                        if (vitalEntry && (vitalEntry.timestamp < eventObj.timestamp)){\n                            vitalEntry[\"foundCk\"] = true\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    case \"noIntv\":\n                        eventObj.status = \"intvCheckWNoIntvFound\"\n                        break\n                    case \"vital\":\n                        eventObj.status = \"patientVitalCheck\" \n                        if (vitalEntry){\n                            vitalEntry = updateVital(vitalEntry,eventObj.timestamp)\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    default: eventObj.status = \"unexpectedPatientIntvCheck\"}\n\n\n                    \n            }\n            // add additional annotations per type\n            if (eventObj.type === \"intervention\") {\n                // iterate through all problem actions looking how to format the\n                // data structue for the current \"event\"\n                problems.forEach((prob, j) => {\n                    // We're going through things in the order standard, contraindicated since\n                    // it is possible but unlikely to have multiple matches and we want the last one to win.\n                    // Also, we are assuming minimal is always a subset of standard\n                    const PROBLEM_ACTION_FIELDS = [\"protocol\", \"why\", \"probLabel\"];\n                    \n\n                    // check for this action to be an intervention for a problem\n                    prob.actions?.forEach((action, k) => {\n                        if (action.id === eventObj.id) {\n                            //see if this is an event whose status should be checked by the student\n                            //and initialize its tracking.  Not yet limiting to event id when\n                            //defining what needs to be tracked in the structure intvChecks\n                            //so also checking event label\n                            let statusChecking  //the entry retrieve from intvChecks\n                            let intv = eventObj.id\n                            statusChecking = intvChecks[eventObj.label]\n                            if (!statusChecking){\n                                statusChecking = intvChecks[eventObj.id]}\n\n                            if (!!statusChecking){\n                                let initialEntry = {\"intervention\": intv, \"timestamp\": eventObj.timestamp, \"foundCk\": false}\n                                //put the intervention on the list if there is a direct status check possible for it\n                                if (statusChecking.intvStatusNeeded){\n                                    trackForStatus[intv] = Object.assign({}, initialEntry)}\n                                //if any vitals are listed for this intervention as a way of checking its status then\n                                //put those on the statusChecking list.  Anytime a vital is checked after the timestamp\n                                //it will count towards checking the status of the intervention\n                                statusChecking.vitalsNeeded.forEach(vital => {\n                                    if (!trackForStatus[vital]){trackForStatus[vital] = [Object.assign({}, initialEntry)]}\n                                    else {trackForStatus[vital].push(Object.assign({}, initialEntry))}})}\n                                \n                            // fill out problem related fields in the action event\n                            eventObj.assessmentsNeeded = action.assessments\n                            eventObj.when = action.phase;\n                            if (!action.optional) { eventObj.required = true; }\n                            if (eventObj.answerCorrect) {\n                                eventObj.status = \"standard\";}\n                            else { eventObj.status = \"standard-incorrect-answers\"; }\n                            eventObj.suggestedPhase = action.phase;\n                            eventObj.probLabel = prob.probLabel;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!action[fldName]) {\n                                    eventObj[fldName] = action[fldName];\n                                }});\n                            if (!!action[\"id-label\"]) { eventObj[\"label\"] = action[\"id-label\"]; }  //dealing with residual name changes\n                        }});\n\n                    // check for this action to be a contraindication for a problem solution\n                    prob.contraindications?.forEach((contra, j) => {\n                        if (contra.id === eventObj.id) {\n                            eventObj.status = \"contraindicated\";\n                            if (!!contra.why) { eventObj.contraindicatedWhy = contra.why; }\n                            if (!!contra[\"id-label\"]) { eventObj.label = contra[\"id-label\"]; }\n                            if (!!contra.protocol) { eventObj.protocol = contra.protocol; }\n                            if (!!prob.probLabel) { eventObj.probLabel = prob.probLabel; }\n                        }})})}\n\n            if (eventObj.type === \"decision-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"decision-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n\n            if (eventObj.type === \"assessment-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"assessment-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n            // add the formatted object to our list of formatted objects for the current phase and the id to our set of confirmed ids\n            confirmedEvents.push(eventObj.id);\n            phaseObjects.push(eventObj);\n\n        }});\n\n    // store the last phase processed\n    phases[phaseIndex] = phaseObjects;\n    phases[parentIndex] = (phases[parentIndex]).concat(phaseObjects);\n    return [phases,phaseNames,confirmedEvents,trackForStatus]\n}\n\nconst findNameNumID = (names, entries, item, occurrence) => {\n    let result = undefined\n    let index = undefined\n    for (let i = 0; i < names.length; i++) {\n        if (item.id === names[i]) {\n            result = entries[i]\n            if (occurrence === \"start\") {\n                break}}}\n    if (!!result) {\n        if (result.numericalID === -1) {\n            if (occurrence === \"start\") {\n                index = result.numericalIDStart}\n            else { index = result.numericalIDEnd }}\n        else { index = result.numericalID }}\n\n    return index\n}\n\n\nconst getItem = (val) => {\n    let item = itemByID[val]\n    if (!item){item = itemByLabel[val]}\n    if (item){return item[0]}\n}\n\nconst findObjByNumerialID = (numericalID,phases,phaseNames) => {\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            for (let entry of phaseObjects){\n                if (entry.numericalID === numericalID){\n                    return entry}\n            }}}}\n\n\nconst storeMisOrderedFB = (numericalID, FB, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {\n        console.log(\"\")}\n    else {\n        if (objToModify.orderingFB !== \"\") {\n            objToModify.orderingFB = objToModify.orderingFB + \".\\xa0\\xa0\" + FB}\n        else { objToModify.orderingFB = FB }\n        let status = \"misOrdered\"\n        switch (objToModify.status){\n            case \"assessment-option-incorrect\":\n                status = \"misOrdered-assessment-option-incorrect\"\n                break\n            case \"decision-option-incorrect\":\n                status = \"misOrdered-decision-option-incorrect\"\n                break\n            case \"standard-incorrect-answers\":\n                status = \"misOrdered-incorrect-answers\"\n                break\n            default:\n                break\n        }\n        objToModify.status = status\n    }\n}\n\n//flattens out the phases and phaseNames data structures so that all phase and subphase\n//names have their own entry and each item under a phase or subphase has its own entry.\n//Collect and return unique names because phase and subphase names can appear multiple times in the \n//phases and phaseNames ds.  Having a unique list of names means that a constraint will only be checked once.\n\nconst collectEntriesToCheckConstraints = (phases, phaseNames) => {\n    let listOfNames = []\n    let listOfEntries = []\n    let uniqueListOfNames = []\n    let counter = -1\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let startIndex = phaseObjects[0].numericalID\n        let endIndex = phaseObjects[phaseObjects.length-1].numericalID\n\n        //handle phases and subphases first\n    \n        if (requiredPhaseNames.includes(phaseName) || requiredSubphases.includes(phaseName)) {\n            listOfEntries.push({ id: phaseName, numericalID: counter, numericalIDStart: startIndex, numericalIDEnd: endIndex })\n            listOfNames.push(phaseName)\n            if (!uniqueListOfNames.includes(phaseName)){uniqueListOfNames.push(phaseName)}}\n\n        //can't be an else to above because a phase can have entries but a subphase cannot\n        \n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            let phaseObjectNames = phaseObjects.map(obj => obj.id)\n            listOfEntries = listOfEntries.concat(phaseObjects)\n            uniqueListOfNames = uniqueListOfNames.concat(phaseObjectNames)\n            listOfNames = listOfNames.concat(phaseObjectNames)\n        }\n    }\nreturn [listOfNames, uniqueListOfNames, listOfEntries]\n\n}\n\nconst checkAgainst2ndArgs = (arg1st,args2nd,op,direction,entryNames,entries,phases,phaseNames) => {\n    let endNum1st = findNameNumID(entryNames, entries, arg1st, \"end\")\n    let startNum1st = findNameNumID(entryNames, entries, arg1st, \"start\")\n    let label1st = arg1st.label\n    let parPhFB = \"\"\n    if (args2nd.length > 0) {\n        for (let arg of args2nd) {\n            let arg2nd = getItem(arg)\n            if (!!arg2nd) {\n                let label2nd = arg2nd[\"label\"]\n                let startNum2nd = findNameNumID(entryNames, entries, arg2nd, \"start\")\n                let endNum2nd = findNameNumID(entryNames, entries, arg2nd, \"end\")\n                switch (direction){\n                case \"before\":\n                    if (!!endNum1st && !!startNum2nd) {\n                        if (endNum1st > startNum2nd) {  //if failed constraint\n                            if (startNum1st === endNum1st) {\n                                    parPhFB = \"You should have done \" + label1st} //feedback for nonphase\n                            else { parPhFB = \"You should have completed \" + label1st }  //feedback for phase\n                            if (startNum2nd === endNum2nd) {\n                                    parPhFB = parPhFB + \" before you did \" + label2nd} //feedback for nonphase\n                            else { parPhFB = parPhFB + \" before starting \" + label2nd } //feedback for phase\n                            storeMisOrderedFB(startNum2nd, parPhFB, phases, phaseNames)}\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                case \"after\":\n                    if (!!startNum1st && !!endNum2nd) {\n                        if (startNum1st < endNum2nd) { //if failed constraint\n                            if (startNum1st === endNum1st){\n                                parPhFB = \"You should have done \" + label1st}  //feedback for nonphase\n                            else{parPhFB = \"You should have waited to start \" + label1st}  //feedback for phase\n                            if (startNum2nd === endNum2nd){\n                                parPhFB = parPhFB + \" after you did \" + label2nd}\n                            else {parPhFB = parPhFB + \" until after you finished \" + label2nd} //feedback for nonphase\n                            storeMisOrderedFB(startNum1st, parPhFB, phases, phaseNames)}   //feedback for phase\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                default: break}}}}\n\n\n}\n\nconst checkConstraintsForArg = (arg1st, constraint, phases, phaseNames, entryNames, entries) => {\n    \n    let args2nd = constraint.before\n    let op = constraint.beforeOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"before\",entryNames,entries,phases,phaseNames)\n\n    args2nd = constraint.after\n    op = constraint.afterOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"after\",entryNames,entries,phases,phaseNames)}\n    \n    \n                \n                        \n\nconst checkAgainstKB = (phases, phaseNames) => {\n\n    let result = collectEntriesToCheckConstraints(phases, phaseNames)\n    let entryNames = result[0]\n    let uniqueEntryNames = result[1]\n    let entries = result[2]\n    uniqueEntryNames.forEach(firstArg => {\n        let firstArgItem = getItem(firstArg)\n        if (!!firstArgItem) {        \n            let constraint = collectConstraints(firstArgItem)  //will find only one constraint per 1st arg\n            if (!!constraint) {\n                checkConstraintsForArg(firstArgItem, constraint, phases, phaseNames, entryNames, entries)}}})            \n    //only expect to change objects in phases\n    return [phases, phaseNames]\n}\n\n\nconst checkForMissingAssessments = (problems,events,confirmedEvents,phaseNames,phases) => {\n    let neededScenAssessments = collectScenAssessments(problems)\n    let indexCounter = events.length;\n    var checklistSteps = scenario.checkListMetaData.filter(md => [MDB_TYPES.ASSESS, MDB_TYPES.REQUIRED].includes(md.type));\n\n    // before evaluating assessment steps, deal with exceptional cases where one or more steps is not\n    // necessary for a given scenario.  Because GCS value is a string and not a formatted object\n    // we can't reliably parse out values and units to do more general checks so can only set what\n    // steps should not be assessed for a particular scenario.  Requires info on feedback to give as\n    // well.\n    // Get any exceptional steps associated with the current scenario\n    var exceptions = [];\n    for (let exceptionDef of exceptionDefs) {\n        if (exceptionDef.scenarioName === scenario.name) {\n            exceptions = exceptionDef.exceptions;\n            break;\n        }\n    }\n\n    exceptions.forEach((exception, j) => {\n        // remove the step from the checklist as it is not required\n        checklistSteps = checklistSteps.filter(entry => entry.id !== exception[0]);\n\n        // if the step was done during the observation then mark it as an issue\n        if (confirmedEvents.includes(exception[0])) {\n            // it could appear in any phase so check all phases and mark\n            // each instancs as unnecessary\n            phases.forEach((phaseObjects, j) => {\n                phaseObjects.forEach((action, i) => {\n                    if (action.id === exception[0]) {\n                        action.why = exception[1];\n                        action.status = \"notNecessary\";\n                    }\n                });\n            });\n        }\n\n    });\n\n    // iterate through all checklist steps for ones for which we don't have formated objects\n    checklistSteps.forEach((cls, i) => {\n        if (!confirmedEvents.includes(cls.id)) {\n            // add so we don't check for the missing checklist item again\n            confirmedEvents.push(cls.id);\n            let phaseObject = {\n                \"comment\": \"\",\n                \"numericalID\": indexCounter,\n                \"status\": \"missingAssessment\",\n                \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                \"expertPhase\": \"\",\n                \"workingPhase\": \"\",\n                \"contraindicatedWhy\": \"\",\n                \"minimalWhy\": \"\",\n                \"why\": \"\",\n                \"probLabel\": \"\",\n                \"protocol\": \"\",\n                \"actionDescription\": \"\",\n                \"assessmentFB\": \"\",\n                \"timestamp\": -1\n            };\n\n            //copy over the step fields that exist (type dependent)\n            const STEP_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"type\", \"prompt\"];\n            STEP_FIELDS.forEach(fldName => {\n                if (!!cls[fldName]) {\n                    phaseObject[fldName] = cls[fldName];\n                }\n            });\n            if (!!cls.subPhase) { phaseObject.workingPhase = cls.subPhase; }\n            else { if (!!cls.phase) { phaseObject.workingPhase = cls.phase; } }\n            phaseObject.when = phaseObject.workingPhase;\n            phaseObject.expertPhase = phaseObject.workingPhase;\n\n            if (!!phaseObject.label) { phaseObject.actionDescription = phaseObject.label; }\n            \n            //let findings = scenario.assessmentFindings[cls['id']]\n            //if (!!findings & findings !== \"Unremarkable\" & findings !== \"Stable\"){\n\n            if (neededScenAssessments.includes(cls['id'])){\n                phaseObject.assessmentFB = \"Thus you missed finding: \" + scenario.assessmentFindings[cls['id']]}\n            if (phaseObject.type === \"required-action\"){\n                phaseObject.status = \"missingRequiredAssessment\"\n            }\n            insertInPhaseInOrder(phaseNames, phases, phaseObject, i);\n            indexCounter++;\n        }\n    });\n    return[confirmedEvents, phaseNames, phases, indexCounter]\n}\n\nconst insertInPhaseInOrder = (phaseNames, phases, object, objIndex) => {\n    let phase\n    phase = object.when;  //what phase should it be added to\n    let phaseIndex = phaseNames.lastIndexOf(phase); //get the index for the last instance of the phase\n    let phaseObjects = phases[phaseIndex];  //get the objects associated with that phase\n    if (!phaseObjects) { phaseObjects = []; }\n    phaseObjects.splice(objIndex - 1, 0, object);  //insert it at the place indicated by input objIndex\n    phases[phaseIndex] = phaseObjects;\n};\n\nconst getEndSubPhase = (inPhaseId, phaseNames) => {\n    let subPhases = getSubPhases(inPhaseId);\n    let subPhaseName;\n    let reversedSubPhases = [...subPhases].reverse();\n    for (let subPhase of reversedSubPhases) {\n        subPhaseName = phaseNames.find(id => id === subPhase.id);\n        if (!!subPhaseName) { break; }\n    }\n    return subPhaseName;\n};\n\nconst getEndSubPhaseIndex = (inPhaseId, phaseNames) => {\n    let subPhaseName = getEndSubPhase(inPhaseId, phaseNames);\n    let index = phaseNames.lastIndexOf(subPhaseName);\n    //console.log(subPhaseName,index)\n    return index;\n};\n\n// sts 01/23/22\nconst getSubPhases = (phaseId) => {\n    return checklistHierarchy.find(phase => phase.id === phaseId).subPhases\n    // let mainPhases = findPhases();\n    // let phaseEntry = mainPhases.find(phase => phase.id === phaseId);\n    // return (phaseEntry.subPhases);\n};\n\nconst hasSubPhases = (phaseId) => {\n    let phase = checklistHierarchy.find(phase => phase.id === phaseId)\n    if (!!phase && !!phase.subPhases){\n        return true}\n    else {return false}\n}\n    \n//find the header under which the input numericalID appears\nconst findHeaderFor = (numericalID, log) => {\n    let candidateHeader = {};\n    let foundHeader = {};\n    for (let entry of log) {\n        if (entry.id === \"problemHeader\") {\n            candidateHeader = entry;\n        }\n        else {\n            if (entry.numericalID === numericalID) {\n                foundHeader = candidateHeader;\n                break;\n            }\n        }\n    }\n    return (foundHeader);\n};\n\nconst setupProblems = (problemDefs) => {\n    let problems = [];\n    for (let problemDef of problemDefs) {\n        let problem = {};\n        problem.assessments = problemDef.assessments;\n        problem.allProblemProtocols = problemDef.protocol;\n        problem.probLabel = problemDef.problem;\n        problem.lifeThreat = problemDef.lifeThreat\n       /*  problem.critical = false;\n        if (problemDef.type === \"critical\") { problem.critical = true; }; */\n        let solution = problemDef.solutions[0];\n        problem.actions = solution.actions;\n        problem.contraindications = solution.contraindications;\n        problem.minimalWhy = solution.minimalWhy;\n        problem.protocols = solution.protocols;\n        problems.push(problem);\n    }\n    return (problems);\n\n    //console.log(problems)\n};\n\n// this is a hack to approximate a good placement for a missing intervention based on ordering of interventions\n// in the problems definitions, what appears in the log that is just before and just after\n// the item to be inserted, and what is marked as required that is in the log just before and after.  An approach that\n// utilizes partial ordering constraints would be better.  Also it is not clear what to do for really badly ordered\n// actions on the part of the student.  Note that it only looks for two anchor points before and two anchor points after\n// rather than all potential anchor points.  Also it does not deal with a phase that is split into multiple time periods\n// within a log\n\n//input orderedArrayObjects is the interventions for a problem as ordered in the problem def\n// objIndex is the index in orderedArrayObjects for the intervention object that needs to be inserted in phases\nconst insertInPhaseRelativeToSuggestedOrder = (phaseNames, phases, object, orderedArrayObjects, objIndex) => {\n    // if expertPhase in object is a phase then find the last subphase and insert there instead of at the beginning\n    let phaseIndex = -1;\n    //console.log(object);\n    // if it is a subphase or a phase with no subphases then get the last entry for a proposed initial insertion point\n    // object.expertPhase is the phase recommended for this action to appear\n    if (object.expertPhase === \"\"){\n        /* let errorMsg = 'No phase specified in the problem defs for object: ' + object.actionDescription;\n        throw new Error(errorMsg) */\n        //just use the next to last phase if none is specified\n        object.expertPhase = requiredPhaseNames[requiredPhaseNames.length - 2]}\n        \n\n    if (requiredSubphases.includes(object.expertPhase) || !getSubPhases(object.expertPhase)) {\n        phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    }\n    // if it is a phase then get the last entry of the last suphase within it for a proposed intial insertion point\n    else {\n        phaseIndex = getEndSubPhaseIndex(object.expertPhase, phaseNames);}\n        \n    //update object when field which is mostly to see what gets computed for the insertion point\n    object.when = phaseNames[phaseIndex];\n        \n    \n\n    let objectsBefore = orderedArrayObjects.slice(0, objIndex - 1);\n    let objectBefore = orderedArrayObjects[objIndex - 1];\n    // console.log(\"Objects before in def\", {...objectsBefore})\n    let requiredObjectBefore = [...objectsBefore].reverse().find(entry => entry.required);\n    let objectAfter = orderedArrayObjects[objIndex + 1];\n    let objectsAfter = orderedArrayObjects.slice(objIndex + 1);\n    let requiredObjectAfter = objectsAfter.find(entry => entry.required);\n    //let phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    let phaseObjects = [...phases[phaseIndex]]; //trying for a deep copy of the array mainly for debug via console.log\n\n    //console.log(phaseObjects)\n    let indexBefore = -1;\n    let indexAfter = -1;\n    let indexRequiredBefore = -1;\n    let indexRequiredAfter = -1;\n    let insertionIndex = false;\n    if (objectBefore) { indexBefore = phaseObjects.findIndex(entry => entry.id === objectBefore.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    if (requiredObjectBefore) { indexRequiredBefore = phaseObjects.findIndex(entry => entry.id === requiredObjectBefore.id); }\n    if (requiredObjectAfter) { indexRequiredAfter = phaseObjects.findIndex(entry => entry.id === requiredObjectAfter.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    // There is a more compact way to do the below but this made\n    // it easier for me to get the logic right\n    // insert according to required before first as we want to follow something that was required\n    if (indexRequiredBefore !== -1) {\n        insertionIndex = indexRequiredBefore + 2;\n        // but if the just before object is greater then insert relative to it\n        if (indexBefore > indexRequiredBefore) { insertionIndex = indexBefore + 2; }\n    }\n    //if no required before and not required after then insert relative to\n    //required item after in actions definition\n    if (!insertionIndex && indexRequiredAfter !== -1) {\n        insertionIndex = indexRequiredAfter + 1;\n        // unless the just after is smaller then override and insert relative to it\n        if (indexAfter < indexRequiredAfter) { insertionIndex = indexAfter + 1; }\n    }\n    //otherwide if have a just before insert relative to it\n    if (!insertionIndex && indexBefore !== -1) {\n        insertionIndex = indexBefore + 2;\n    }\n    //otherwise if have a just after insert relative to it\n    if (!insertionIndex && indexAfter !== -1) {\n        insertionIndex = indexAfter + 1;\n    }\n    //otherwise put at end of phase\n    if (!insertionIndex) {\n        insertionIndex = phaseObjects.length + 2;\n    }\n    insertInPhaseInOrder(phaseNames, phases, object, insertionIndex);\n\n};\n\nconst determineHLcolor = (lowerColor, higherColor) => {\n    let newColor = higherColor\n    if (lowerColor === \"red\") {\n        newColor = \"red\"\n    }\n    if (lowerColor === \"yellow\" && newColor !== \"red\") {\n        newColor = \"yellow\"\n    }\n    return newColor\n}\n\n//to display the log using the phase structures accumulated\n// i.e. puts the phases data together in the order in which\n// should be displayed in debriefing log\nconst organizeLogDisplay = (phaseNames, phases) => {\n    let displayObjects = [];\n    let entryIndex = 1;\n    let headerIndex = 1;\n    let problemHeaderColor = \"green\"\n    let subPhaseColor = \"green\"\n    let newPhaseObjects = [];\n    let headerObj = {\n        \"id\": \"assessmentHeader\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"status\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"protocol\": \"\"\n    };\n    \n    let priorHLPhase = \"\"\n    let endEntry = false\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let iPhaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let process = true\n        //could simplify all code below by using just the parent phase entries\n        if (requiredPhaseNames.includes(phaseName) && hasSubPhases(phaseName)) {\n            /* phases[phaseIndex] = []\n            iPhaseObjects = [] */\n            process = false}\n\n        if (iPhaseObjects.length > 0 && process) {\n                //for this set of objects, find the worst scoring item\n            let phaseObjects = phases[phaseIndex];\n            subPhaseColor = \"green\"\n            for (let phaseObject of phaseObjects) {\n                if (problemStates.includes(phaseObject.status)) {\n                    subPhaseColor = \"red\";\n                }\n                // Red has a higher priority than yellow so will allow to override it\n                if (cautionStates.includes(phaseObject.status) && subPhaseColor !== \"red\") {\n                    subPhaseColor = \"yellow\";\n                }\n                phaseObject.numericalID = entryIndex++;\n                //entryIndex++;\n            };\n\n            //Note that the inserted headers will have their own numerical id and\n            //am dividing by 1000 for headers so their numerical id will be unique\n            //to headers.  Am assuming we would never have more than 1000 events\n            //observed.  Will use the numerical ids for testing before and after\n            //constraints.\n            let localPhaseName = phaseNames[phaseIndex]\n            let highLevelPhase = subPhases[localPhaseName]\n            if (priorHLPhase === \"\") {\n                priorHLPhase = highLevelPhase\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n            }\n\n            if (phaseIndex === phaseNames.length - 1) {\n                if (highLevelPhase !== priorHLPhase) {\n                    let header = Object.assign({}, headerObj)\n                    header.label = priorHLPhase\n                    header.status = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                }\n                newPhaseObjects = Object.assign([], phaseObjects);\n                priorHLPhase = highLevelPhase\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n                endEntry = true;\n            }\n\n            //save the high-level phase if changes or processed the last of the phase objects\n            //in array phases\n            if (highLevelPhase !== priorHLPhase || endEntry) {\n                let header = Object.assign({}, headerObj)\n                header.label = priorHLPhase\n                header.status = problemHeaderColor;\n                header.numericalID = headerIndex++ / 1000\n                displayObjects.push(header)\n                displayObjects.push(...newPhaseObjects)\n                //reinitialize for the new phase\n                newPhaseObjects = Object.assign([], phaseObjects);\n                priorHLPhase = highLevelPhase\n                problemHeaderColor = determineHLcolor(subPhaseColor, \"green\")\n            }\n            else {\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n                newPhaseObjects.push(...phaseObjects);\n\n            }\n        }\n    }\n    return displayObjects;\n}\n\n\n\n\nconst evalForIncorrectAnswer = (promptID, answerID, isIntervention) => {\n        //check each prompt and if is the appropriate one then\n        let answers = undefined\n        if (isIntervention) {\n            answers = scenario.associations[promptID];\n        }\n        else { answers = scenario.checkListCorrectness[promptID]; }\n\n        if (answers === undefined) { console.log(\"didn't find answers for \", promptID); return (false) }  //can't grade if answers not found in spec\n\n        if (Array.isArray(answers)) {\n            //returns bool regarding whether answerID NOT in answers\n            return !(answers.find(ansId => ansId === answerID));\n\n        }\n        else {\n            return !(answers === answerID);\n        }\n};\n\n\nconst getCorrectAnswerLabel = (promptID, isIntervention) => {\n    let answers\n    let metaData\n    if (isIntervention){\n        answers = scenario.associations[promptID];\n        metaData = scenario.intvMetaData}\n    else {answers = scenario.checkListCorrectness[promptID];\n        metaData = scenario.checkListMetaData}\n    let answerLabels = false;\n    if (Array.isArray(answers)) {\n        answers.forEach((answer, j) => {\n            metaData.forEach((entry, i) => {\n                if (entry.id === answer) {\n                    if (answerLabels === false) {\n                        answerLabels = entry.label;\n                    }\n                    else { answerLabels = answerLabels + \", \"; }\n                    return;\n                }\n            });\n        });\n    }\n\n    else {\n\n        metaData.forEach((entry, i) => {\n            /* //needed to find out what the types are for debugging\n            let answertypes = []\n            if (!answertypes.find(type => type === entry.type)){\n                answertypes.push(entry.type)} */\n\n            if (entry.id === answers) {\n                answerLabels = entry.label;\n            }\n        });\n    }\n    //answerLabels = answerLabels.charAt(0).toLowerCase() + answerLabels.slice(1);\n    /* if (answerLabels){\n        answerLabels = \"'\" + answerLabels + \"'\";} */\n    return answerLabels\n};\n\nconst getAnswerLabel = (answerID, isIntervention) => {\n    let metaData\n    if (isIntervention){\n        metaData = scenario.intvMetaData}\n    else {metaData = scenario.checkListMetaData}\n    let answerLabel = \"\";\n    metaData.forEach((entry, i) => {\n            if (entry.id === answerID) {\n                answerLabel = entry.label;\n            }\n        });\n    return (answerLabel || false) ;\n}\n\n// To be written\nconst insertMissingIntvChecks = (events, statusTracking) => {\n    let toUpdate\n    for (const [key, entry] of Object.entries(statusTracking)) {\n        if (Array.isArray(entry)){\n            for (let obj of entry) {\n                let newObj = {\"label\": key, \"foundCk\": obj[\"foundCk\"]}\n                toUpdate = getEventsByIdTime(events,obj[\"intervention\"],obj[\"timestamp\"])\n                for (let intv of toUpdate) {\n                    if (!intv[\"intvStatus\"].includes(newObj)){\n                       intv[\"intvStatus\"].push(newObj)}\n                }}}\n        else {\n            let newObj = {\"label\": \"intervention status\", \"foundCk\": entry[\"foundCk\"]}\n            toUpdate = getEventsByIdTime(events,key,entry[\"timestamp\"])\n            toUpdate.forEach(intv => {\n                if (!intv[\"intvStatus\"].includes(newObj)){\n                    intv[\"intvStatus\"].push(newObj)}})}\n    }\n    return events\n}\n\n\nfunction analyzeEvents(scen, log) {\n    let events = log.events;\n    console.log(\"in analyzeEvents\")\n    // sts 1/23/22 moved the setting of the following into initGlobals()\n    // setScenario(scenario)\n    // setupSubphasePhaseLookup()\n    // findSubphases();\n    initGlobals(scen)\n\n    //preprocess some of data from problems/solutions\n    //and for now just flatten it some to set it up to\n    //look more like the original problem actions in scenario\n    // assumes there is just one solution per problem for now.\n    let problemDefs = scenario.problems;\n    let problems = setupProblems(problemDefs);\n    \n    //In the remainder, just dealing with the first solution for each problem\n    //so if we ever have more than one solution for a problem this code needs to\n    //be updated.  Would need to consider the additional solutions to decide which\n    //solution is the best fit for the observer student\n\n\n    let formattedActions = [];\n    let annotatedResults = annotateInputEvents(events,problems)\n    //phaseNames and phases are two arrays synchronized be array indices\n    //phases contains just the steps under the phase (thus could be a phase or subphase in observer interface)\n    //phaseNames contains the label for each phase in phases.  Makes it a bit easier to search phaseNames to get the\n    //indice for last instance of a phase label and access its objects\n    let phases = annotatedResults[0];  \n    let phaseNames = annotatedResults[1]; \n    let confirmedEvents = annotatedResults[2]\n    let intvsTracking = annotatedResults[3]\n\n    /* //now create some similar structures for the parents of the above phases\n    //so have all the associated event objects in parents and parentNames\n    //for easy lookup\n    let parentResults = collectParentPh(phaseNames)\n    let parents = parentResults[0]  //events under this parent\n    let parentNames = parentResults[1] */\n\n    //update relative to constraints and comprises definitions\n    //for now it just compares two constraint args of the same type\n    //for what currently exists\n    let kbUpdates = checkAgainstKB(phases,phaseNames)\n    phases = kbUpdates[0]\n    phaseNames = kbUpdates[1]\n    \n    //add missing phase names to phaseNames\n    //as do insertions should consider the temporal ordering constraints\n    \n    let updatedPhases = insertMissingSubphases(phases, phaseNames)\n    phases = updatedPhases[0]\n    phaseNames = updatedPhases[1]\n\n\n    // check for missing checklist steps\n    //as do insertions should consider the temporal ordering constraints\n    let postAssessmentReview = checkForMissingAssessments(problems,events,confirmedEvents,phaseNames,phases)\n    confirmedEvents = postAssessmentReview[0]\n    phaseNames = postAssessmentReview[1]\n    phases = postAssessmentReview[2]\n    let indexCounter = postAssessmentReview[3]\n\n\n\n    // this section could be moved into a separate function so that\n    // the parts of the main analysis are clearer\n\n    // start insert missing interventions\n    \n    // search for missing interventions for each action\n    // Doing this separately from the earlier actions loop because\n    // we wanted to add in missing assessment steps first\n    problems.forEach(prob => {\n\n\n        const actions = prob.actions;\n\n\n        // now we just have to examine action ids to see what is missing\n        actions.forEach((action, k) => {\n            if (!confirmedEvents.includes(action.id)) {\n                confirmedEvents.push(action.id);\n                let phaseObject = {\n                    \"comment\": \"\",\n                    \"numericalID\": indexCounter,\n                    \"status\": \"\",\n                    \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                    \"required\": true,\n                    \"when\": \"\",\n                    \"suggestedPhase\": \"\",\n                    \"expertPhase\": \"\",\n                    \"probLabel\": prob.probLabel,\n                    \"minimalWhy\": prob.minimalWhy,\n                    \"assessmentsNeeded\": prob.assessments,\n                    \"protocol\": prob.protocols,\n                    \"actionDescription\": \"\",\n                    \"type\": \"intervention\",\n                    \"timestamp\": -1\n                };\n\n                //copy over the step fields that exist (type dependent)\n                const ACTION_FIELDS = [\"id\", \"phase\", \"protocol\", \"why\", \"optional\", \"minimal\"];\n                ACTION_FIELDS.forEach(fldName => {\n                    if (!!action[fldName]) {\n                        phaseObject[fldName] = action[fldName];\n                    }\n                });\n\n                //initialize some fields above that come from action if they are defined\n                if (!!action.optional) { phaseObject.required = !action.optional; }\n                if (!!action[\"id-label\"]) { phaseObject.label = action[\"id-label\"]; }\n                if (!!action[\"id-label\"]) { phaseObject.actionDescription = action[\"id-label\"]; }\n                if (!!action.phase) {\n                    phaseObject.when = action.phase;\n                    phaseObject.expertPhase = action.phase;\n                    phaseObject.suggestedPhase = action.phase;\n                }\n\n\n                if (phaseObject.required) {\n                    phaseObject.status = \"missingRequired\";\n                }\n                else {\n                    if (!phaseObject.optional) { phaseObject.status = \"missingRequired\"; }\n                    else { phaseObject.status = \"missingOptional\"; }\n                }\n                //assume actions are in the suggested order to solve a problem\n                if (phaseObject.status !== \"missingOptional\") {\n                    insertInPhaseRelativeToSuggestedOrder(phaseNames, phases, phaseObject, actions, k);\n                    indexCounter++;\n                }\n            }\n\n        });\n    });\n\n   // end insert missing interventions\n    \n    \n    // put together the phases into a single array ordered as directed by phases\n    \n    formattedActions = organizeLogDisplay(phaseNames, phases);\n    //console.log(\"formattedActions\", formattedActions)\n\n    // Now that it is all rejoined into a list, do some updating with additional\n    // analysis results\n\n    formattedActions = insertMissingIntvChecks(formattedActions, intvsTracking)\n    \n    \n    //if insertInterventionHeader is T, insert action headers for\n    // purpose of debugging and reviewing before deployment\n    \n    let priorProb = \"N/A\";\n\n    let finalActions = [];\n\n    formattedActions.forEach((eventObj, j) => {\n\n        if (insertInterventionHeader && eventObj.type === \"intervention\" && eventObj.probLabel && !(priorProb === eventObj.probLabel)) {\n            priorProb = eventObj.probLabel;\n            let headerObject = {\n                \"id\": \"interventionHeader\",\n                \"type\": \"header\",\n                \"numericalID\": 1,\n                \"status\": \"green\",\n                \"why\": \"\",\n                \"probLabel\": eventObj.probLabel,\n                \"protocol\": \"\"\n            };\n            finalActions.push(headerObject);\n        }\n        finalActions.push(eventObj);\n    });\n\n    // start overall analysis to determine if all actions to solve a problem are present\n\n    // now we analyze all that we've found in the log to see whether\n    // all the actions were done for each problem and reset\n    // the status if not all are there but should be counted\n    // as minimal for the feedback.\n    let pActions = []; //here we will store the actual problem actions\n    let pNames = []; //here we will store the problem names for the above with same order\n    let pIndex = 0;\n    let pActIndex = -1;\n\n    finalActions.forEach((action, j) => {\n        if (action.status.includes(\"standard\", \"standard-incorrect-answers\")) { //only interventions have status of standard\n            if (!pNames.includes(action.probLabel)) {\n                pActIndex = pIndex;\n                pNames[pActIndex] = action.probLabel;\n                pIndex++;\n            }\n            else { pActIndex = pNames.indexOf(action.probLabel); }\n            let actions = pActions[pActIndex];\n            if (!actions) { actions = []; }\n            actions.push(action);\n            pActions[pActIndex] = actions;\n        }\n    });\n\n    // If all the minimal were found but not all the action were, then we\n    // need to re-mark the action objects created for the minimal events\n    // to be minimal instead of standard.  It isn't\n    // appropriate to give this feedback if all actions are present.\n    // Waited until now so that all the events are in one list instead of\n    // a list per phase,\n    let processedIds = formattedActions.map(event => event.id);\n    let pIds = problems.map(a => a.probLabel);\n    pNames.forEach((pEntry, j) => {\n        //get the action definition for this problem\n        let pIndex = pIds.indexOf(pEntry);\n        let prob = problems[pIndex];\n        let actionNeeded = prob.actions.filter(obj => !obj.optional).map(obj => obj.id);\n        let minimalNeeded = prob.actions.filter(obj => obj.minimal).map(obj => obj.id);\n        if (minimalNeeded) { //no point in doing anything else if no minimals were defined\n            let foundActions = pActions[j];\n            let found = foundActions.map(a => a.id);\n            let allActionFound = true;\n            let allMinimalFound = true;\n            for (let item of actionNeeded) {\n                if (!found.includes(item)) {\n                    allActionFound = false;\n                    break;\n                }\n            }\n            for (let item of minimalNeeded) {\n                if (!found.includes(item)) {\n                    allMinimalFound = false;\n                    break;\n                }\n            }\n            let numericalIDsChanged = [];\n            if (!allActionFound && allMinimalFound) {\n                minimalNeeded.forEach((foundId, j) => {\n                    let pIndex = processedIds.indexOf(foundId);\n                    let object = formattedActions[pIndex];\n\n                    //find object to modify\n                    object.minimalWhy = prob.minimalWhy;\n                    if (object.status === \"standard-incorrect-answers\"){\n                        object.status = \"minimal-incorrect-answers\";      }\n                    else {object.status = \"minimal\"}\n\n                    numericalIDsChanged.push(object.numericalID);\n                    formattedActions[pIndex] = object;\n                });\n                //redo color for header if needed\n                let header = {};\n                numericalIDsChanged.forEach((numericalID, z) => {\n                    header = findHeaderFor(numericalID, formattedActions);\n                    if (header && header.status === \"green\") { header.status = \"yellow\"; }\n                });\n\n            }\n        }\n\n    });\n\n    // end of overall analysis\n\n\n\n    console.log(\"Final Analysis:\", finalActions);\n\n\n    // save final analysis in a file\n    saveAnalysisLog(log, finalActions);\n\n    //else {checkOnOverwriting(log, finalActions)}\n\n\n    return (finalActions);\n\n}\n\n\nexport {analyzeEvents}","// the following constants are deprecated (need to figure out how to handle this)\n// use MDB_TYPES, SELECTION_TYPES, PREFIXES, and SYSTEMS instead\nexport const ANSWER = \"answer\"\nexport const ASSESS = \"assessment\"\nexport const ASSESSO = \"assessment-option\"\nexport const ASSESS_OPTION = \"assessment-option\"\nexport const AWO = \"assessment-with-options\"\nexport const CB = \"checkbox\"\nexport const CL_HEADING = \"checklist-heading\"\nexport const CL_PROMPT = \"checklist-prompt\"\nexport const CRIT_FAIL = \"critical-criteria\"\nexport const DECISION = \"decision\"\nexport const DECISION_OPTION = \"decision-option\"\nexport const DIST_PROMPT = \"distinguishing-prompt\"\nexport const HEADING = \"heading\" //not a leaf node, simply a step which has child steps\nexport const INTERV = \"intervention\" // an action performed on the patient\nexport const INTV_FORM = \"intervention-form\"\nexport const NESTED_CHECKLIST = \"nested-checklist\"\nexport const NONE = \"none\"\nexport const ONE = \"one\"\nexport const OOM = \"one-or-more\"\nexport const OPTION = \"option\"\nexport const PHASE = \"phase\"\nexport const PROMPT = \"prompt\"\nexport const PROMPT_SET = \"prompt-set\"\nexport const REQUIRED = \"required-action\"   // an action the EMT performs, but not on the patient\n// keeping as I had a typo. need to deprecate somehow\nexport const REQURED = REQUIRED\nexport const SUB_PHASE = \"sub-phase\"\n\nexport const MDB_TYPES = Object.freeze({\n    PHASE: PHASE,\n    SUB_PHASE: SUB_PHASE,\n    ASSESS: ASSESS,\n    AWO: AWO,\n    ASSESS_OPTION: ASSESS_OPTION,\n    ASSESSO: ASSESS_OPTION,\n    CL_HEADING: CL_HEADING,\n    CL_PROMPT: CL_PROMPT,\n    DECISION: DECISION,\n    DECISION_OPTION: DECISION_OPTION,\n    DIST_PROMPT: DIST_PROMPT,\n    NESTED_CHECKLIST: NESTED_CHECKLIST,\n    REQUIRED: REQUIRED,\n    REQURED: REQUIRED,\n    INTERV: INTERV,\n    PROMPT_SET: PROMPT_SET,\n    PROMPT: PROMPT,\n    ANSWER: ANSWER,\n})\nexport const SELECTION_TYPES = Object.freeze({\n    ONE: ONE,\n    OOM: OOM,\n    NONE: NONE\n})\nexport const SELECTION_TYPE_LABELS = Object.freeze({\n    ONE: \"One\",\n    OOM: \"One or more\",\n    NONE: \"None\"\n})\nexport const PREFIXES = Object.freeze({\n    PHASE: \"\",\n    SUB_PHASE: \"\",\n    ANSWER: \"answer-\",\n    ASSESS: \"assess-\",\n    AWO: \"assessment-with-options-\",\n    ASSESS_OPTION: \"assess-option-\",\n    CL_PROMPT: \"cl-prompt-\",\n    DECISION: \"decision-\",\n    DECISION_OPTION: \"decision-option-\",\n    INTERV: \"intv-\",\n    PROMPT_SET: \"prompt-set-\",\n    PROMPT: \"prompt-\",\n    REQUIRED: \"required-action-\",\n})\n\nexport const SYSTEMS = Object.freeze({\n    AW: \"airway\",\n    BR: \"breathing\",\n    BL: \"bleeding\",\n    SH: \"shock\",\n})\nexport const SYSTEM_LABELS = Object.freeze({\n    AW: \"Airway\",\n    BR: \"Breathing\",\n    BL: \"Bleeding\",\n    SH: \"Shock\"\n})\n\nexport const CHECKLIST_STEP_TYPES = [ASSESS, AWO, DECISION, REQUIRED]\nexport const OPTION_TYPES = [ASSESS_OPTION, DECISION_OPTION]\nexport const ANALYSIS_TYPES = [ASSESS, AWO, DECISION, REQUIRED, INTERV, PHASE, SUB_PHASE]\n\nexport const PROTOCOL_RELATIONSHIPS = Object.freeze({\n    NONE: \"\",\n    MIN: \"mimimal\",\n    OPT: \"optional\",\n    CONTRA: \"contraindicated\"\n})","\n\nimport { MDB_TYPES } from \"./constants.js\"\nimport { ScenarioType, PublishedScenario } from \"./types.js\"\n\n// the rest of these imports can go away soon. simply allows me to delete objects form the db\n// and reload with files. not used if records exist in db\nimport INTVS from \"./intvs.js\"\nimport INTV_PROMPTS from \"./intvPrompts.js\"\nimport INTV_PROMPT_ANSWERS from \"./intvPromptAnswers.js\"\nimport INTV_MENU_CATS from \"./intvMenusCats.js\"\nimport INTV_MENU_ITEMS from \"./intvMenuItems.js\"\n\nexport const loadIntvs = () => {\n    const tmp = INTVS.map(e => {\n        const rec = {...e}\n        if (!e.abbrLabel) {\n            rec.abbrLabel = e.label\n        }\n        if (!e.distPrompts) {\n            rec.distPrompts = []\n        }\n        if (!e.prompts) {\n            rec.prompts = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPrompts = () => {\n    const tmp = INTV_PROMPTS.map(e => {\n        const rec = {...e}\n        if (!!e.interventionID) {\n            const found = INTVS.find(i => i.id === e.interventionID)\n            if (!found) {\n                console.log(`loadIntvPrompts(${e.id}) ${e.interventionID} not found`)\n            }\n        }\n        if (!e.abbrLabel) {\n            rec.abbrLabel = \"\"\n        }\n        if (!e.feedback) {\n            rec.feedback = rec.label\n        }\n        if (!e.answers) {\n            rec.answers = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPromptAnswers = () => {\n    const tmp = INTV_PROMPT_ANSWERS.map(e => {\n        if (!e.abbrLabel) {\n            e.abbrLabel = \"\"\n        }\n        const found = INTV_PROMPTS.find(p => p.id === e.promptID)\n        if (!found) {\n            console.log(`loadIntvPromptAnswers(${e.id}) ${e.promptID} not found`)\n        }\n        return e\n    })\n    return tmp\n}\n\nexport const getScenarios = (db, scenarioType, schemaVersion) => {\n    const query = db.collection(\"scenarios\")\n             .where(\"scenarioType\", \"==\", scenarioType)\n             .where(\"schemaVersion\", \"==\", schemaVersion)\n    return query.get()\n        .then(snapShot => {\n            const scenarios = []\n            if (snapShot.size > 0) {\n                snapShot.docs.forEach(doc => {\n                    const data = doc.data()\n                    scenarios.push({\n                        id: data.id,\n                        name: data.name,\n                        scenarioType: data.scenarioType,\n                        schemaVersion: data.schemaVersion\n                    })\n                })\n            }\n            return scenarios\n        })\n}\n\nexport const getPublishedScenarioObjectByID = async (db, scenarioID) => {\n    const data = await getPublishedScenarioByID(db, scenarioID)\n    return new  PublishedScenario(data)\n}\n\nexport const getPublishedScenarioByID = (db, scenarioID) => {\n    return db.collection(\"published-scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByID = (db, scenarioID) => {\n    return db.collection(\"scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByName = (db, scenarioName, schemaVersion) => {\n    return db.collection(\"scenarios\")\n    .where(\"name\", \"==\", scenarioName)\n    .where(\"schemaVersion\", \"==\", schemaVersion)\n    .limit(1)\n    .get()\n    .then(snapShot => {\n        if (snapShot.size === 1) {\n            return snapShot.docs[0].data()\n        } else {\n            throw new Error(\"document not found\")\n        }\n    })\n}\n\nconst addMissingScenarioTypeFields = (scenTypeData) => {\n    const msgs = []\n    if (!scenTypeData.interventions) {\n        msgs.push(\"loading intvs from file\")\n        scenTypeData.interventions = loadIntvs()\n    }\n    if (!scenTypeData.interventionPrompts) {\n        const errs = []\n        const tmpPrompts = loadIntvPrompts()\n        tmpPrompts.forEach(e => {\n            if (e.type === MDB_TYPES.PROMPT) {\n                // ignore this check if distinguishing prompt (not associated with a single intv)\n                if (undefined === scenTypeData.interventions.find(rec => rec.id === e.interventionID)) {\n                    errs.push(`bad interventionID ${e.interventionID}`)\n                }\n            }\n        })\n        let msg = \"loading intv prompts from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPrompts = tmpPrompts\n    }\n    if (!scenTypeData.interventionPromptAnswers) {\n        const errs = []\n        const tmpPromptAnswers = loadIntvPromptAnswers()\n        tmpPromptAnswers.forEach(e => {\n            if (undefined === scenTypeData.interventionPrompts.find(rec => rec.id === e.promptID)) {\n                errs.push(`bad promptID ${e.promptID}`)\n            }\n        })\n        let msg = \"loading intv prompt answers from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPromptAnswers = tmpPromptAnswers\n    }\n    if (!scenTypeData.interventionMenuCategories) {\n        msgs.push(\"loading intv menu categories from file\")\n        scenTypeData.interventionMenuCategories = INTV_MENU_CATS\n    }\n    if (!scenTypeData.interventionMenuItems) {\n        const errs = []\n        const tmpIntvMenuItems = INTV_MENU_ITEMS.map(e => {\n            const found = scenTypeData.interventionMenuCategories.find(cat => cat.id === e.intvCategoryID)\n            if (!found) {\n                errs.push(`bad intvCategoryID ${e.intvCategoryID}`)\n            } else {\n                if (e.type === MDB_TYPES.INTERV) {\n                    const intv = scenTypeData.interventions.find(i => i.id === e.interventionID)\n                    if (!intv) {\n                        errs.push(`bad interventionID ${e.interventionID}`)\n                    } else {\n                        e.label = intv.label\n                    }\n                }\n                return e\n            }\n        })\n        let msg = \"loading intv menu items from file...\"\n\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionMenuItems = tmpIntvMenuItems\n    }\n    if (msgs.length > 0) {\n        msgs.forEach(m => console.log(m))\n    } else {\n        console.log(\"all data loaded from db. files not needed\")\n    }\n    return scenTypeData\n}\n\nexport const getScenarioTypeObjectByID = async (db, scenarioTypeID) => {\n    const data = await getScenarioTypeByID(db, scenarioTypeID)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeObject = async (db, scenarioType, schemaVersion) => {\n    const data = await getScenarioType(db, scenarioType, schemaVersion)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeByID = (db, scenarioTypeID) => {\n    return db.collection(\"scenario-types\")\n        .doc(scenarioTypeID)\n        .get()\n        .then(doc => {\n        const data = doc.data()\n        data.id = doc.id\n        return addMissingScenarioTypeFields(data)\n        })\n        .catch(error => {\n            console.log(error)\n            return error\n        })\n}\n\nexport const getScenarioType = (db, scenarioType, schemaVersion) => {\n    return db.collection(\"scenario-types\")\n            .where(\"name\", \"==\", scenarioType)\n            .where(\"schemaVersion\", \"==\", schemaVersion)\n            .limit(1)\n            .get()\n            .then(snapShot => {\n                if (snapShot.size === 1) {\n                    return addMissingScenarioTypeFields(snapShot.docs[0].data())\n                } else {\n                    throw new Error(\"document not found\")\n                }\n            })\n}\n\n\n\n// FIXME: this needs to go away, although I need to figure out if it's in use anywhere first\nexport const getPromptAndOptions = (scenarioTypeOrPubScenario, promptID) => {\n    const scenType = scenarioTypeOrPubScenario\n    const prompt = scenType.interventionPrompts.find(e => e.id === promptID)\n    if (!!prompt) {\n        const options = prompt.answers.map(ansID => scenType.interventionPromptAnswers.find(a => a.id === ansID))\n        prompt.options = options.map(opt => {\n            return {...opt, prompt: prompt.label}\n        })\n    }\n    return prompt\n}\n\n// moved over from apps/data-entry/src/scripts/connect-firebase\n// added 'db' as first param so that these functions can be used either from web or server firebase APIs\n/**\n * Verify document doesn't already exist in database.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns True if document with given ID doesn't exist yet.\n */\nexport const verifyDocument = async (db, collectionId, documentId) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    return set.empty;\n};\n\n// returns true if combo of name and schemaVersion fields is unique\nexport const verifyDocNameUniqueness = async (db, collectionID, candidateName, dbNameField, schemaVersion) => {\n    const snapshot = await db.collection(collectionID)\n        .where(dbNameField, \"==\", candidateName)\n        .where(\"schemaVersion\", \"==\", schemaVersion)\n        .get()\n    return snapshot.empty\n}\n\n// Upload document object to database\nexport const publishDocument = async (db, collectionId, documentObject, documentId) => {\n    documentId\n        ?\n        await db.collection(collectionId).doc(documentId).set(documentObject) :\n        await db.collection(collectionId).doc().set(documentObject);\n};\n\n// Update document with given id\nexport const updateDocument = async (db, collectionId, documentId, documentObject) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    set.empty ?\n        publishDocument(collectionId, documentObject) :\n        await db.collection(collectionId).doc(set.docs[0].id).set(documentObject);\n};\n\n/**\n * Will save document, using auto-generated IDs if documentObject doesn't have\n * an 'id' attribute.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {object} documentObject\n */\nexport const saveDocument = async (db, collectionId, documentObject) => {\n    const doc = (!documentObject.id) ?\n        db.collection(collectionId).doc() :\n        db.collection(collectionId).doc(documentObject.id);\n    documentObject.id = doc.id;\n    await doc.set(documentObject);\n    return documentObject.id\n}\n\n/**\n * Query collection for document with id\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns {object} Object containing document data.\n */\nexport const getDocument = async (db, collectionId, documentId) => {\n    const doc = await db.collection(collectionId).doc(documentId).get();\n    return doc.data();\n};\n\n/**\n * Query collection for document with name\n * @param {string} collectionId\n * @param {string} documentName\n * @returns {object} Object containing document data.\n */\nexport const getDocumentWithName = async (db, collectionId, documentName) => {\n    const set = await db.collection(collectionId).where(\"name\", \"==\", `${documentName}`).get();\n    return set.docs[0]?.data();\n};\n\n/**\n * Delete document from collection\n * @param {string} collectionId\n * @param {string} documentId\n */\nexport const deleteDocument = async (db, collectionId, documentId) => {\n    await db.collection(collectionId).doc(documentId).delete();\n};\n\n/**\n * Pull collection from database as array of document objects\n * @param {string} collectionId\n * @returns {object[]} An array containing all of the document in the collection.\n */\nexport const getCollection = async (db, collectionId) => {\n    const collection = await db.collection(collectionId).get();\n    return collection.docs?.map(item => item.data());\n};\n\n// copied over from /apps/debriefer/src/scripts/connect-firebase and 'db' param added as first param\n\n// Get a list of document names and a copy of each document\nexport const listDocumentNames = async (db, collectionId) => {\n    let documentList = db.collectionGroup(collectionId);\n    let documentDictionary = {};\n    documentList.get().then((querySnapshot) => {\n        querySnapshot.forEach((doc) => {\n            documentDictionary[doc.id] = doc.data();\n        });\n    });\n    return documentDictionary;\n}\n\nexport const getLogs = (db) => {\n    return db.collection(\"logs\").get()\n        .then(querySnapshot => {\n            return querySnapshot.docs.map(doc => {\n                const data = doc.data()\n                return {\n                    id: doc.id,\n                    label: data.label,\n                    scenario: data.scenarioName,\n                    userName: data.userName,\n                    timestamp: data.timestamp\n                }\n            })\n        })\n}\n\n\nexport const getLog = (db, logID) => {\n    return db.collection(\"logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const getDebriefLog = (db, logID) => {\n    return db.collection(\"debriefing-feedback-logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n","import { MDB_TYPES, SELECTION_TYPES as ST } from \"@meddbriefer/scenario-data/constants.js\"\n\nconst INTV_PROMPTS = [\n    {\n        \"id\": \"prompt-wound-location\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.ONE,\n        label: \"Where is the wound located?\",\n        abbrLabel: \"Wound location?\",\n        answers: [\n            \"answer-wound-location-head\",\n            \"answer-wound-location-neck\",\n            \"answer-wound-location-chest\",\n            \"answer-wound-location-abdomen-pelvis\",\n            \"answer-wound-location-posterior\",\n            \"answer-wound-location-genitalia\",\n            \"answer-wound-location-left-lower-extremity\",\n            \"answer-wound-location-right-lower-extremity\",\n            \"answer-wound-location-left-upper-extremity\",\n            \"answer-wound-location-right-upper-extremity\",\n            \"answer-wound-location-other\"\n        ]\n    },\n    {\n        \"id\": \"prompt-wound-locations\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.OOM,\n        label: \"Where are the wound(s) located?\",\n        abbrLabel: \"Wound location(s)?\",\n        answers: [\n            \"answer-wound-locations-head\",\n            \"answer-wound-locations-neck\",\n            \"answer-wound-locations-chest\",\n            \"answer-wound-locations-abdomen-pelvis\",\n            \"answer-wound-locations-posterior\",\n            \"answer-wound-locations-genitalia\",\n            \"answer-wound-locations-left-lower-extremity\",\n            \"answer-wound-locations-right-lower-extremity\",\n            \"answer-wound-locations-left-upper-extremity\",\n            \"answer-wound-locations-right-upper-extremity\",\n            \"answer-wound-locations-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-airway-patency-suction-device\",\n        \"interventionID\": \"intv-airway-patency-technique-suction-airway\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What kind of suction catheter will you use?\",\n        \"abbrLabel\": \"Suction catheter type?\",\n        \"answers\": [\n            \"answer-airway-patency-suction-yankauer\",\n            \"answer-airway-patency-suction-long-multiuse\",\n            \"answer-airway-patency-suction-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-advanced-airway-adjunct-type\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of advanced airway adjunct would you use?\",\n        \"abbrLabel\": \"Which advanced airway?\",\n        \"answers\": [\n            \"answer-alternative-rescue-airway-type-ett\",\n            \"answer-alternative-rescue-airway-type-combitube\",\n            \"answer-alternative-rescue-airway-type-lta\",\n            \"answer-alternative-rescue-airway-type-lma\",\n            \"answer-alternative-rescue-airway-type-igel\",\n            \"answer-alternative-rescue-airway-type-other\"\n        ]\n    }, {\n        \"id\": \"prompt-advanced-airway-tube-size\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\":\"one\",\n        \"label\": \"What tube size for advanced airway?\",\n        \"abbrLabel\": \"What size?\",\n        \"answers\": [\n            \"answer-alternative-airway-tube-size-7\",\n            \"answer-alternative-airway-tube-size-8\",\n            \"answer-alternative-airway-tube-size-age-div-4-plus-4\",\n            \"answer-alternative-airway-tube-size--age-div-4-plus-4-minus-5\",\n            \"answer-alternative-airway-tube-size-37f\",\n            \"answer-alternative-airway-tube-size-41f\",\n            \"answer-alternative-airway-tube-size-0\",\n            \"answer-alternative-airway-tube-size-1\",\n            \"answer-alternative-airway-tube-size-1-5\",\n            \"answer-alternative-airway-tube-size-2\",\n            \"answer-alternative-airway-tube-size-2-5\",\n            \"answer-alternative-airway-tube-size-3\",\n            \"answer-alternative-airway-tube-size-4\",\n            \"answer-alternative-airway-tube-size-5\",\n            \"answer-alternative-airway-tube-size-6\",\n            \"answer-alternative-airway-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-orotracheal-intubation-tube-insertion-depth\",\n        \"interventionID\": \"intv-orotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what depth would you insert the tube?\",\n        \"abbrLabel\": \"Tube insertion depth?\",\n        \"answers\": [\n            \"answer-orotracheal-intubation-tube-insertion-depth-21cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-23cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-3-times-tube-size\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasotracheal-intubation-tube-size\",\n        \"interventionID\": \"intv-nasotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What tube size would you use?\",\n        \"abbrLabel\": \"Tube size?\",\n        \"answers\": [\n            \"answer-nasotracheal-intubation-tube-size-6-to-6-5\",\n            \"answer-nasotracheal-intubation-tube-size-7-to-7-5\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus1\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus0-5\",\n            \"answer-nasotracheal-intubation-tube-size-0-5-1cm-less-than-oro-size\",\n            \"answer-nasotracheal-intubation-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasal-cannula-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-nasal-cannula-flow-rate-1-6-lpm\",\n            \"answer-nasal-cannula-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-nasal-cannula-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-nasal-cannula-target-saturation-gt-90-pct\",\n            \"answer-nasal-cannula-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-non-rebreather-mask-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-flow-rate-10-15-liters-min\",\n            \"answer-non-rebreather-mask-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-non-rebreather-mask-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-target-saturation-gt-90-pct\",\n            \"answer-non-rebreather-mask-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-bvm-ventilation-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what rate will you ventilate the patient?\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n            \"answer-bvm-ventilation-rate-10-12-bpm\",\n            \"answer-bvm-ventilation-rate-other\",\n        ]\n    }, {\n        \"id\": \"prompt-bvm-flow-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What flow rate would you administer?\",\n        \"abbrLabel\": \"Flow rate?\",\n        \"answers\": [\n            \"answer-bvm-flow-rate-15-ltm-or-gt\",\n            \"answer-bvm-flow-rate-other\",\n        ]\n    },{\n        \"id\": \"prompt-bvm-target-saturation\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-bvm-target-saturation-rate-gt-90-pct\",\n            \"answer-bvm-target-saturation-rate-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-tourniquet-placement-close-to-core-far-from-wound\",\n            \"answer-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-2nd-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the second tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-2nd-tourniquet-placement-adjacent-to-initial-tourniquet\",\n            \"answer-2nd-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-occlusive-dressing-injury-type\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-occulsivive-dressing-injury-type-open-pneumothorax\",\n            \"answer-occulsivive-dressing-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-occlusive-dressing-method\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How would you create a release valve on an occlusive dressing?\",\n        \"abbrLabel\": \"How would you create a release valve?\",\n        \"answers\": [\n            \"answer-occulsive-dressing-method-leave-one-side-untaped\",\n            \"answer-occulsive-dressing-method-leave-dressing-with-one-way-valve\",\n            \"answer-occulsive-dressing-method-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-pleural-decompression-injury-type\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-pleural-decompression-injury-type-tension-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-open-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-side-of-the-body\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"On which side of the body would you place the needle?\",\n        \"abbrLabel\": \"Which side would you place the needle?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-right\",\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-left\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-anatomical-landmark\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what anatomical landmark?\",\n        \"abbrLabel\": \"At what anatomical landmark?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-2nd-or-3rd-intercostal-space-mid-clavicular\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-4th-or-5th-intercostal-space-mid-axillary\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-size\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What size needle do you want to use?\",\n        \"abbrLabel\": \"Needle size?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-size-large-bore\",\n            \"answer-pleural-decompression-needle-size-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-length\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How long a needle would you use?\",\n        \"abbrLabel\": \"Needle length?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-length-2-inches-or-longer\",\n            \"answer-pleural-decompression-needle-length-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-transport-facility-choice\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of care facility will you transport the patient to?\",\n        \"abbrLabel\": \"Type of receiving facility\",\n        \"answers\": [\n            \"answer-transport-facility-choice-level-1-or-2-trauma-center\",\n            \"answer-transport-facility-choice-level-3-or-4-trauma-center\",\n            \"answer-transport-facility-choice-closest\",\n            \"answer-transport-facility-choice-other\"\n        ]\n    },{\n        \"id\": \"prompt-transport-method\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you transport this patient by air or ground ambulance?\",\n        \"abbrLabel\": \"Air or ground ambulance?\",\n        \"answers\": [\n            \"answer-transport-method-ambulance\",\n            \"answer-transport-method-helicopter\"\n        ]\n    },{\n        \"id\": \"prompt-transport-lights-siren-decision\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you use lights and sirens with this patient?\",\n        \"abbrLabel\": \"Lights and sirens?\",\n        \"answers\": [\n            \"answer-transport-lights-sirens-yes\",\n            \"answer-transport-lights-sirens-no\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-splint-type\",\n        \"interventionID\": \"intv-splint-fractures\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of splint would you use?\",\n        \"abbrLabel\": \"Type of splint?\",\n        \"answers\": [\n            \"answer-splint-type-board\",\n            \"answer-splint-type-moldable\",\n            \"answer-splint-type-traction\",\n            \"answer-splint-type-pelvic-binder\",\n            \"answer-splint-type-other\"\n        ]\n    },\n\n]\n/*\n    {\n        \"id\": \"\",\n        \"interventionID\": \"\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n        ]\n    },\n*/\nexport default INTV_PROMPTS","const INTV_MENU_ITEMS = [\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-als\",\n        \"label\": \"ALS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-amputation\",\n        \"label\": \"Manage amputation\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-bls\",\n        \"label\": \"BLS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-crico\",\n        \"label\": \"Cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-establish-patency\",\n        \"label\": \"Establish patency\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-insert-adjunct\",\n        \"label\": \"Insert adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-intubation\",\n        \"label\": \"Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-internal-bleeding\",\n        \"label\": \"Manage suspected internal bleeding\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-shock\",\n        \"label\": \"Manage hemorrhagic shock\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-medication-facilitated-intubation\",\n        \"label\": \"Medication Facilitated Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-open-airway\",\n        \"label\": \"Open airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-remove-foreign-body-obstructions\",\n        \"label\": \"Remove foreign body obstructions\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n         \"depth\": 1,\n         \"type\": \"heading\",\n         \"id\": \"heading-severe-external-bleeding\",\n         \"label\": \"Manage severe external bleeding\",\n         intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transfer\",\n        \"label\": \"Transfer patient to EMS vehicle\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transport\",\n        \"label\": \"Transport to care facility\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-advanced-airway-adjunct\",\n        interventionID: \"intv-advanced-airway-adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-airway-patency-technique-suction-airway\",\n        interventionID: \"intv-airway-patency-technique-suction-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-apply-sterile-dressings\",\n        interventionID: \"intv-apply-sterile-dressings\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-back-blows-and-chest-thrusts\",\n        interventionID: \"intv-back-blows-and-chest-thrusts\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-direct-pressure\",\n        interventionID: \"intv-control-severe-bleeding-technique-direct-pressure\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-2nd-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        interventionID: \"intv-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pressure-bandage\",\n        interventionID: \"intv-control-severe-bleeding-technique-pressure-bandage\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-load-and-go\",\n        interventionID: \"intv-control-severe-bleeding-technique-load-and-go\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-keep-patient-warm\",\n        interventionID: \"intv-control-shock-technique-keep-patient-warm\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-high-concentration-o2\",\n        interventionID: \"intv-control-shock-technique-administer-high-concentration-o2\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-place-patient-supine-position\",\n        interventionID: \"intv-control-shock-technique-place-patient-supine-position\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-iv-boluses\",\n        interventionID: \"intv-control-shock-technique-administer-iv-boluses\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-heimlich-maneuver\",\n        interventionID: \"intv-heimlich-maneuver\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-keep-body-part-cool\",\n        interventionID: \"intv-keep-body-part-cool\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-magill-forceps-assisted\",\n        interventionID: \"intv-magill-forceps-assisted\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-manual-finger-sweep\",\n        interventionID: \"intv-manual-finger-sweep\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasopharyngeal-airway\",\n        interventionID: \"intv-nasopharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-needle-cricothyrotomy\",\n        interventionID: \"intv-needle-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-occlusive-dressing\",\n        interventionID: \"intv-occlusive-dressing\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-head-tilt\",\n        interventionID: \"intv-open-airway-method-head-tilt\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-modified-jaw-thrust\",\n        interventionID: \"intv-open-airway-method-modified-jaw-thrust\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-oropharyngeal-airway\",\n        interventionID: \"intv-oropharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-orotracheal-intubation\",\n        interventionID: \"intv-orotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-body-part-in-bag\",\n        interventionID: \"intv-place-body-part-in-bag\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-immobilized-patient-on-stretcher\",\n        interventionID: \"intv-place-immobilized-patient-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-pleural-decompression\",\n        interventionID: \"intv-pleural-decompression\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-pain-nausea-vomiting-medications\",\n        interventionID: \"intv-prepare-and-administer-pain-nausea-vomiting-medications\",\n        intvCategoryID: \"intv-cat-manage-pain-nausea-vomiting\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-sedative\",\n        interventionID: \"intv-prepare-and-administer-sedative\",\n        intvCategoryID: \"intv-cat-sedate-agitated-or-combatitive-patient\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-retrieve-amputated-body-part\",\n        interventionID: \"intv-retrieve-amputated-body-part\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sedation-assisted-intubation\",\n        interventionID: \"intv-sedation-assisted-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-slat\",\n        interventionID: \"intv-slat\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-attach-cid\",\n        interventionID: \"intv-spinal-immobilization-technique-attach-cid\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-cervical-collar\",\n        interventionID: \"intv-spinal-immobilization-technique-cervical-collar\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-manual-c-spine-stabilization\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine2\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-transfer-to-device\",\n        interventionID: \"intv-spinal-immobilization-technique-transfer-to-device\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures2\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sterile-dressing-soft-tissue\",\n        interventionID: \"intv-sterile-dressing-soft-tissue\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-nasal-cannula\",\n        interventionID: \"intv-supplemental-oxygen-device-nasal-cannula\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-non-rebreather-mask\",\n        interventionID: \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-surgical-cricothyrotomy\",\n        interventionID: \"intv-surgical-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-walk-patient\",\n        interventionID: \"intv-transfers-patient-method-walk-patient\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-place-directly-on-stretcher\",\n        interventionID: \"intv-transfers-patient-method-place-directly-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport\",\n        interventionID: \"intv-transport\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport-body-part-to-receiving-facility\",\n        interventionID: \"intv-transport-body-part-to-receiving-facility\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-ventilation-technique-bag-valve-mask\",\n        interventionID: \"intv-ventilation-technique-bag-valve-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-wrap-body-part-in-saline-soaked-gauze\",\n        interventionID: \"intv-wrap-body-part-in-saline-soaked-gauze\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    }\n]\n\nexport default INTV_MENU_ITEMS","import { useEffect, useState } from \"react\"\n\nimport { Link } from \"react-router-dom\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLogs } from \"@meddbriefer/scenario-data/index\"\n\nimport { Table } from \"reactstrap\"\nconst LogList = () => {\n    const [logs, setLogs] = useState([])\n    const [logsLoaded, setLogsLoaded] = useState(false)\n\n    useEffect(\n        () => {\n            getLogs(db)\n            .then(result => {\n                setLogs(result)\n                // console.log(result)\n                setLogsLoaded(true)\n            })\n            .catch(error => console.log('error fetching logs', error))\n        },\n        []\n    )\n\n    if (!logsLoaded) {\n        return (<h4>fetching log data</h4>)\n    }\n    return (\n        <Table striped={true} borderless size=\"sm\" hover>\n            <thead>\n                <tr>\n                    <th>Label</th>\n                    <th>Scenario</th>\n                    <th>Username</th>\n                    <th>Timestamp</th>\n                </tr>\n            </thead>\n            <tbody>\n                {logs.map(log => (\n                    <tr key={log.id}>\n                        <td>{log.label}</td>\n                        <td>{log.scenario}</td>\n                        <td>{log.userName}</td>\n                        <td>{log.timestamp}</td>\n                        <td>\n                            <Link to={`/logs/${log.id}`}>Analyze</Link>&nbsp;&nbsp;&nbsp;&nbsp;\n                            <Link to={`/debriefing-feedback-logs/${log.id}`}>Review</Link>\n                        </td>\n                    </tr>\n                ))}\n            </tbody>\n        </Table>\n    )\n\n}\n\nexport default LogList","import { formatAsMinSecs } from \"../utils\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\n//import { itemByID, itemByLabel } from \".analyzeEvents\"\n\n\n\n// defines which assessment steps are not required per scenario.  Provides feedback on\n// why the step is not required.\nexport const exceptionDefs = \n[{scenarioName: \"M2CA\", exceptions: [\n    [\"required-action-obtain-OPQRST\", \"This cannot be assessed when GCS < 15\"],\n    [\"assess-opqrst-info\", \"This cannot be assessed when GCS < 15\"]\n    ]}\n  ]\n\nconst colorTypes = {\n    \"Good\": \"text-success\",\n    \"Caution\": \"text-warning\",\n    \"Problem\": \"text-danger\",\n    \"Not implemented\": \"text-muted\"\n}\n\nconst iconTypes = {\n    \"Good\": \"sentiment_satisfied\",\n    \"Caution\": \"report_problem\",\n    \"Problem\": \"highlight_off\",\n    \"Not implemented\": \"sentiment_neutral\"\n}\n\n//Feedback substitute commands for feedback template\n//@ means substitute this entry field into the feedback template and if no value in field say this in feedback, \n//? means substitute this entry field into the feedback template if the value exists,\n//+bos adds period to end sentence, two spaces and capitalizes first letter of what follows\n//+eos adds a period with no preceding spaces\n\n\nconst assessmentEntries = {\n    // state: [categorization for feedback, feedback template for condition 1]\n    \"contraindicated\": [\"Problem\", \"You should not have done this action because it is contraindicated in this case +bos ?contraindicatedWhy +eos\"],\n    \"misOrdered\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos ?intvStatusFB +eos\"],\n    \"missingMinimal\": [\"Problem\", \"You did not do this action, which is recommended by protocol ?protocol +bos @why +eos\"],\n    \"missingOptional\": [\"Caution\", \"You did not do this action +bos but it was optional in this case according to protocol ?protocol @bos @why +eos\"],\n    \"missingRequired\": [\"Problem\", \"You did not do this action, which is recommended by protocol ?protocol +bos @why +eos\"],\n    \"missingRequiredAssessment\": [\"Problem\", \"You did not do this action. +bos ?assessmentFB +eos\"],\n    //not yet implemented\n   // \"missedProblem\": [\"Problem\", \"The following should alert you to @problem: +items @problemAssessments\"],  //need to add status and fields to analysis code still and +item formatting below\n    \"notNecessary\": [\"Caution\", \"You should not have done this action because it was unnecessary +bos @why +eos\"],\n    \"assessment\": [\"Good\", \"\"],\n    \"assessment-option\": [\"Good\", \"\"],\n    \"decision-option\": [\"Good\", \"\"],\n    \"required-action\": [\"Good\", \"\"],\n    \"assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"standard\": [\"Good\", \"?intvStatusFB +eos \"],\n    \"intvCheckWNoIntvFound\": [\"Caution\", \"You didn't do this intervention so it doesn't make sense to check the status of it at this point.\"],\n    \"unexpectedPatientIntvCheck\": [\"Caution\", \"This status check is not likely to reveal any useful information.\"],  //nothing indicates a need to check that this intv worked\n    \"patientIntvCheck\": [\"Good\", \"\"], //as long as the intervention was done it is fine to request it\n    \"patientVitalCheck\": [\"Good\", \"\"],  //currently any patient vital check that is done is fine\n    \"standard-incorrect-answers\": [\"Problem\", \"Doing this action is correct but there is a problem with how you planned to do it +bos @incorrectAnswersFB +eos\"],\n    \"minimal-incorrect-answers\": [\"Problem\", \"Doing this action was correct and would solve the problem but you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do this intervention +bos @incorrectAnswersFB +eos\"],\n    \"misOrdered-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +eos\"],\n    \"misOrdered-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol @protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +eos\"],\n    \"minimal\": [\"Caution\", \"Doing this action is correct and solves the problem but you did not follow protocol @protocol +bos @minimalWhy +bos ?intvStatusFB +eos \"],\n    \"green\": [\"Good\", \"\"],  //just for headers\n    \"red\": [\"Problem\", \"\"], //just for headers\n    \"yellow\": [\"Caution\", \"\"], //just for headers\n    //\"notFound\": [\"Not implemented\", \"Assessment knowledge is not yet specified\", []],\n    \"default\": [\"Not implemented\", \"This action was not expected.  There could be an issue with how this scenario is represented within the system.\"]\n}\n\n// functions that extract info from above or create the feedback from the above \n\n//returns a list of all the state values associated with the input status (e.g. status is one of \"Problem\", \"Good\", \"Caution\")\nexport const getStatesForStatus = (status) => {\n    let stateList = []\n    for (const [state, entry] of Object.entries(assessmentEntries)) {\n        let stateStatus = entry[0]\n        if (stateStatus === status){\n            stateList.push(state)}\n        }\n    //console.log(\"In getStatesForStatus\", stateList)\n    return (stateList)}\n        \n\n//returns the entry under that state\nconst getAssessmentEntry = (currentEntry,aIndex) => {\n    let assessmentEntry = \"\"\n    if (!assessmentEntries[currentEntry.status]){\n        assessmentEntry = assessmentEntries[\"default\"]}\n    else{assessmentEntry = assessmentEntries[currentEntry.status]}\n    return assessmentEntry[aIndex];\n}\n\n//returns the html icon to use in condition 1 for the state\nexport const getAssessmentIcon = (currentEntry) => {  \n    let val = iconTypes[getAssessmentEntry(currentEntry,0)]\n    return val;\n}\n\n//returns the html color to use in condition 1 for the state\nexport const getColor = (currentEntry) => {\n    return colorTypes[getAssessmentEntry(currentEntry,0)];\n}\n\n//add protexted spaces after a . except for the very last .  \n//Otherwise html reduces continguous regular spaces to a single space.\n//Need this for text strings that will appear in one array entry because\n//of substitution\nconst fixStrSp = (textString) => {\n    let textArray = textString.split(\" \");\n    let lenTextArray = textArray.length;\n    textArray.forEach((item, i) => {\n        let newItem = item.trim()\n        if (newItem[item.length-1] === \".\" && i < lenTextArray-1){\n            //add protected space to the string\n            newItem = newItem + \"\\xa0\\xa0\"}\n        textArray[i] = newItem \n    })\n    let newString\n    for (let item of textArray){\n        if (!!newString){\n          newString = newString + \" \" + item;}\n        else{newString = item}\n\n    }\n    //console.log(newString, textArray)\n    return newString\n}\n\nconst generateIntvStatusFB = (currentEntry) => {\n    let checked = []\n    let notChecked = []\n    let fb\n    for (let entry of currentEntry.intvStatus){\n        if (entry.foundCk){\n            checked.push(entry.label)}\n        else {notChecked.push(entry.label)}\n    }\n    if (notChecked.length > 0){\n        fb = \"Remember to check the effect of this action by asking for: \" + notChecked + \".\"\n        if (checked.length > 0){\n            fb = fb + \" That is in addition to what you did ask for: \" + checked + \".\"\n        }\n    }\n    return fb\n}\n\n\n\n\nexport const getFeedback = (currentEntry) => {\n    if (!!currentEntry.intvStatus && currentEntry.intvStatus.length > 0){\n        //add our generated feedback string to the currentEntry\n        currentEntry.intvStatusFB = generateIntvStatusFB(currentEntry)\n    }\n    let feedbackTemplate = fixStrSp(getAssessmentEntry(currentEntry,1)).trim()\n    //Find any @ actions in the template and substitute with the indicated entry field\n    let feedbackArray = feedbackTemplate.split(\" \");\n    //Process all @ substitutions first since +eos does one forward action\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let newString = item.substring(1)\n        //trim off excess blanks before and after each word\n        feedbackArray[i] = feedbackArray[i].trim()\n        switch(firstChar){\n            case \"@\":\n                if (!!currentEntry[newString])\n                    //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"[value for \" + newString + \" is missing]\" }\n                break\n            case \"?\":\n                if (!!currentEntry[newString])\n                //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fixStrSp(currentEntry[newString]) }\n                else {\n                    feedbackArray[i] = \"\"  \n                    if (feedbackArray[i-1]  === \"+bos\"){feedbackArray[i-1] = \"\"}\n                    if (feedbackArray[i+1]  === \"+eos\"){feedbackArray[i+1] = \"\"}\n                }\n                break  \n            default:\n        }\n    })\n    //Now address the + actions in the template\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let previousString = \"\"\n        switch(firstChar){\n        case \"+\":\n            let afterPlusChar = item.substring(1)\n            switch(afterPlusChar){\n            case \"eos\":\n                //removes existing/redundant . if present so can be certain putting in single . \n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence and a protected space.  When stiched back into\n                //a single string a protected space will be added between each substring\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\"  //get rid of the command since was applied\n                break\n            case \"bos\":\n                //removes existing/redundant . if present so can put in single .\n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence .\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\" //get rid of the command since was applied\n                //Captitalize the beginning of the sentence\n                let nextString = feedbackArray[i+1].trim()\n                feedbackArray[i+1] = nextString.charAt(0).toUpperCase() + nextString.slice(1);\n                break\n            default:\n            }\n            break\n        default:\n    }}\n    )\n    //stitch back into a single string\n    let feedbackString\n    for (let item of feedbackArray){\n        if (!!feedbackString) {\n            if (item !== \"\"){\n                feedbackString = feedbackString + \"\\xa0\" + item;}} \n        else {if (item !== \"\"){feedbackString = item}}\n    }\n    //console.log(feedbackString)\n    return feedbackString\n}\n\n\n/* This starts section on defining temporal constraints and implications.*/\n\n/*temporal constraints are an\nindex of event labels with two lists as values.\nThe first value is a list of event labels that the indexed event\nshould precede (if any) and the second value is a list of event\nlabels that the indexed event should follow after (if any)\n*/\n\nexport const temporalConstraints = {\n    // event < list of other events, > list of other events\n    // lookup by event id to see the list of event ids that it should go before\n    // and after, and the type of constraint. \n    // included constraints type with values of policy, commonSense and both.  These may be used in future to\n    // decide any lead in to feedback about a constraint violation\n    // type policy operators are usually \"ands\", type commonsense operators are ususally \"ors\" because\n    // the ordering is looser than with policy ordering.  An operator can be blank if only one item is listed for the\n    // before or for the after.  No software should be written to expect\n    // this tendency between type and operators to hold.\n\n    //Note that: \n    //- for now the software will use either the label or id to lookup constraints but id\n    // is preferred.\n    //- a key (first item on each line) is the first arg in the constraints and is\n    //  assumed to have just one constraint applicable to\n    //  it but may appear as the second arg in a constraint multiple times (2nd args are\n    //  lists under before or after fields)\n    //- when something is a phase or subphase with multiple actions then we look for the begining\n    //  and ending actions for constraint checking.  If overlap in phases is to be allowed the constraint should\n    //  be amongst lower level items and no higher level constraint should be included\n    //= there is no check to make sure the constraints expressed do not conflict.  For example,\n    //  saying a whole phase should be before another phase and that a particular item in the second\n    //  phase can go before some other item in the first phase are in conflict with one another\n    \n    //states that primary survey in its entirety should come before the secondary assessment\n    \"primary-survey\": {id: \"c1\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    //state that ongoing management plan should go after the entirety of everything listed in after\n    \"ongoing-mgmt-plan\": {id: \"c2\", before: [ ], beforeOp: \"\", after: [\"bsi\", \"scene-size-up\", \"primary-survey\", \"history-taking\",\"secondary-assessment\"], afterOp: \"and\", type: \"commonSense\"},\n    // bsi should be completed before scene-size-up is begun\n    \"bsi\": {id: \"c3\", before: [\"scene-size-up\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // scene size up should be completed before primary survey is begun\n    \"scene-size-up\": {id: \"c4\", before: [\"primary-survey\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // assess major bleeding firt before doing any of airway and breathing (note that there is no\n    // ordering specified between circulation and airway or breathing as that would be a conflict with this\n    // constraint)\n    \"assess-major-bleeding\": {id: \"c5\", before: [\"airway\",\"breathing\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    //subphase airway should be completed before subphase breathing is started\n    \"airway\": {id: \"c6\", before: [\"breathing\"], beforeOp: \"\",  after: [], afterOp: \"\", type: \"policy\"},\n    //not yet implemented constraint filtering\n    //\"breathing\": {id: \"c6.5\", before: [\"circulation\"], beforeOp: \"\",  after: [], afterOp: \"\", type: \"policy\"},\n    // have two second args here because some of Observer logs have one of these ids and some have the other\n    \"assess-injury-mechanism\": {id: \"c7\", before: [\"required-action-consider-stabilization-of-spine\", \"required-action-considers-stabilize-spine\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"commonSense\"},\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"c8\", before: [\"intv-control-severe-bleeding-technique-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {id: \"c9\", before: [\"intv-control-severe-bleeding-technique-2nd-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n    \"Administer IV fluid resuscitation\": {id: \"c10\", before: [], beforeOp: \"\", after: [\"Establish IVs\"], afterOp: \"\", type: \"commonSense\"},  //this may need to go under implications instead\n    //have no way to implement this constraint because have no collective reference for iv-medication.  Can do once have a KR\n    //iv-medication: {before: [\"\"], after:[\"iv\"], type: \"commonSense\"  not sure how to refer to iv-medication as a group.  Would have to list each individually\n    //\"\": {before: [\"\"], after: []},\n    //Note that the rest are labels just because I haven't looked up and replaced with their ids\n    \"Nasal cannula\": {id: \"c11\", before: [\"Administer high concentation of oxygen\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"commonSense\"},\n    \"Non-rebreather mask\": {id: \"c12\", before: [\"Administer high concentation of oxygen\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"commonSense\"},\n    \"Sedation-assisted intubation\": {id: \"c13\", before: [], beforeOp: \"\", after: [\"Nasopharyngeal adjunct\",\"Oropharyngeal adjunct\"], afterOp: \"or\", type: \"policy\"},\n    // don't yet have a label for contact medical command\n    //medical-command: [sedated-intubation][]\n    //\"\": {before: [\"\"], after: []},\n    \"Checks for major bleeding\": {id: \"c14\", before: [\"intv-control-severe-bleeding-technique-tourniquet\"], beforeOp:\"\", after: [],afterOp: \"\", type: \"commonSense\"},\n    \"Manual c-spine stabilization\": {id: \"c15\", before: [\"Cervical collar\",\"Place on long back board(LBB)\", \"Place on short board(e.g., KED)\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"both\"},\n    \"Cervical collar\": {id: \"c16\", before: [\"Attach cervical immoblization device (CID)\"], beforeOp: \"\", after: [], afterOp: \"or\", type: \"commonSense\"},\n    \"Administer high concentration of oxygen\": {id: \"c17\", before: [], beforeOp: \"\", after: [\"Bag-valve mask\",\"Nasal cannula\",\"Non-rebreather mask\"], afterOp: \"or\", type: \"commonSense\"} \n\n  \n}\n\nexport const conditionalConstraintFilters = [\n    {\"conditions\": {\"moi\": \"major-bleeding\", \"loc\": \"GCS < 8\", op: \"or\"},\n     \"outConstraints\": [\"c6.5\"],\n     \"inConstraints\": [\"c5\"]\n    }\n]\n\n\nexport const collectConstraints = (item) => {\n    let id = item.id\n    let label = item.label\n    let constraints = temporalConstraints[id] \n    if (!constraints){constraints = temporalConstraints[label]}\n    return constraints \n}\n\n\n\n    //what we should assume will be completed during a particular intervention.  Mainly we have a high-level intervention\n    //that includes within it several other supporting interventions.  Doing so made the observation work a bit easier\n    //in that they don't have to go to multiple places in the interventions menu for related interventions\n    //below is just an example\n    export const comprises = {\n    \"Sedation-assisted intubation\": [\"Establish IVs\"],\n    }\n\n    //below are examples of interventions in which status should be checked.  The key intvStatusNeeded\n    //is true or false.  If true it means should have requested status of this intervention.  If vitals key is\n    //not empty then should have checked all of these vitals as well.  Will only check entries after an intervention\n    //up until something other than an intervention check is done\n    export const intvChecks = {\n     \"Apply direct pressure\": {intvStatusNeeded: true, vitalsNeeded: []},\n     \"Nasopharyngeal adjunct\": {intvStatusNeeded: true, vitalsNeeded: []},\n     \"Apply tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []}, \n     \"Administer IV fluid resuscitation\": {intvStatusNeeded: false, vitalsNeeded: [\"BP\"]},\n     \"Sedation-assisted intubation\": {intvStatusNeeded: true, vitalsNeeded: []},\n     \"Administer high concentration of oxygen\": {intvStatusNeeded: true, vitalsNeeded: [\"R\", \"Spo2\", \"P\"]},  //just put in ones to check\n     \"Bag-valve mask\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"P\"]},  //just put in ones to check\n     \n    }\n\n    \n\n    //at top level [] read as on or\n    //at next level [] read as an and\n\n    export const vitalsReportedBySteps = {\n    \"GCS\": [[\"assess-loc\"], [\"required-action-obtains-vitals\"], [\"request-vitals-GCS\"]],\n    \"Pain\": [[\"assess-loc\"], [\"required-action-obtains-vitals\"], [\"request-vitals-Pain\"]],\n    \"R\": [[\"breathing-checks-rate\", \"breathing-checks-rhythm\", \"breathing-checks-quality\"], [\"required-action-obtains-vitals\"], [\"request-vitals-R\"]],\n    \"P\": [[\"checked-carotid-pulse\", \"checks-pulse-rate\", \"checks-pulse-rhythm\", \"checks-pulse-quality\"], [\"checked-radial-pulse\", \"checks-pulse-rate\", \"checks-pulse-rhythm\", \"checks-pulse-quality\"],[\"required-action-obtains-vitals\"], [\"request-vitals-P\"]],\n    \"Skin\": [[\"checks-skin-color\", \"checks-skin-temperature\", \"checks-skin-condition\"], [\"required-action-obtains-vitals\"], [\"request-vitals-Skin\"]],\n    \"BP\": [[\"required-action-obtains-vitals\"], [\"request-vitals-BP\"]],\n    \"Glucose\": [[\"required-action-obtains-vitals\"], [\"request-vitals-Glucose\"]],\n    \"ETCO2\": [[\"required-action-obtains-vitals\"], [\"request-vitals-ETCO2\"]],\n    \"Spo2\": [[\"required-action-obtains-vitals\"], [\"request-vitals-Spo2\"]],\n    \"Temp\": [[\"required-action-obtains-vitals\"], [\"request-vitals-Temp\"]],\n}\n\n\n//This ends section on defining constraints & implications\n\n\n// This section is for looking up items in the analysis log\n\nexport const getEvents = (events,field,val) => {\n    return events.filter(entry => entry[field] === val)\n}\n\nexport const getEventsByIdTime = (events,id,timestamp) => {\n    return getEvents(getEvents(events,\"timestamp\",timestamp),\"id\",id)\n}\n\n// This ends the section for looking up items in the analysis log\n\n\n\n//This starts section for saving/loading the debriefing log\n    \nconst _ = require(\"lodash\"); \n\nexport const saveAnalysisLog = (log, actions) => {\n    console.log(\"In savingDebriefingLog\")\n    const docRef = db.collection(\"debriefing-feedback-logs\").doc(log.id)\n    let data = {\n        userName: log.userName,\n        ObserverFileCreater: log.userName,\n        label: log.label,\n        ObserverFileName: log.label,\n        commenter: \"\",\n        scenarioID: log.scenarioID,\n        scenarioName: log.scenarioName,\n        schemaVersion: log.schemaVersion,\n        timestamp: Date().toLocaleString()\n    }\n\n    let newActionsList = [];\n    let newObj = {};\n    let filterUnknown = false;\n\n    //included for debugging puposes only\n    actions.forEach(function (logObj, index){\n        for (let [key, val] of Object.entries(logObj)) {\n            if (undefined === val) {\n                console.log(\"filtered out from events; index: \", index, \" key: \", key, \" value: \", val)\n                filterUnknown = true;}\n             }\n        }\n    )\n        \n    if (filterUnknown) {\n        actions.forEach(function (logObj, index) {\n            newObj = _.pickBy(logObj, function (value, key) {\n                return !(value === undefined);\n            });\n            newActionsList.push(newObj)\n        })\n        data[\"events\"] = newActionsList\n    }\n    else (data[\"events\"] = actions);\n\n\n    //data[\"events\"] = formattedActions;\n    //console.log(JSON.stringify(data, null, 4))\n    docRef.set(data) \n}\n\n//not in use\n\nexport const retrieveDebriefing = (log) => { \n    //console.log(log.events) \n    return (log.events)  \n}  \n\n//This starts section for saving/loading the debriefing log\n\n\n\nexport const getTimestamp = (currentEntry) => {\n    if (currentEntry.status === \"criticalActionHeader\") {\n        return \"\";\n    }\n    if (currentEntry.timestamp === -1) {\n        return \"\\xa0\\xa0\";  // formatAsMinSecs would convert this to 59:59\n    }\n    return formatAsMinSecs(currentEntry.timestamp);\n}\n\n\n","export const formatAsMinSecs = (seconds) => {\n    return new Date(seconds * 1000).toISOString().substr(14, 5)\n}","import { MDB_TYPES, CHECKLIST_STEP_TYPES, OPTION_TYPES } from \"@meddbriefer/scenario-data/constants\";\n\n// input: list of objects and a fieldName\n// returns: an object who's attributes are the distinct values for that fieldName mapped to the subset\n// of list items which share that field value\nexport const groupByKey = (listOfObjs, fldName) => listOfObjs.reduce(\n    (hash, obj) => ({ ...hash, [obj[fldName]]: (hash[obj[fldName]] || []).concat(obj) }),\n    {}\n)\n\nexport const getChecklistItemsByType = (scenario, itemType) => {\n    return scenario.checkListMetaData.filter(e => e.type === itemType)\n}\n\nexport const getChecklistItems = (scenario) => {\n  return scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(MDB_TYPES.PHASE, MDB_TYPES.SUB_PHASE))  \n}\n\nexport const getChecklistHierarchy = (scenario) => {\n    const phases = getChecklistItemsByType(scenario, MDB_TYPES.PHASE)\n    const subPhases = getChecklistItemsByType(scenario, MDB_TYPES.SUB_PHASE)\n    // filters out items which are display only\n    const clSteps = scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(e.type))\n    // get the options which are associated with some certain types of steps (decisions, assess w/options)\n    const options = scenario.checkListMetaData.filter(e => OPTION_TYPES.includes(e.type))\n    // map the options to their stepId\n    const stepOptions = groupByKey(options, \"parentID\")\n    // if a step has options, add them to that step\n    clSteps.forEach(step => {\n        if (step.id in stepOptions) {\n            step.options = stepOptions[step.id]\n        }\n    })\n    // figure out which checklist items belong to phases or subphases and group them by\n    // the their corresponding phase/subphase ids\n    const phChecklistSteps = groupByKey(clSteps.filter(e => undefined === e.subPhase), \"phase\")\n    const spChecklistSteps = groupByKey(clSteps.filter(e => !!e.subPhase), \"subPhase\")\n    // assign subphase steps to the appropriate subphase\n    subPhases.forEach(sp => {\n        sp.items = spChecklistSteps[sp.id]\n    })\n    // map subphases to their phase\n    const phSubphases = groupByKey(subPhases, \"phase\")\n    // phases have either items or subphases -not both. assign the appropriate stuff\n    // to each phase\n    phases.forEach(ph => {\n        if (ph.id in phChecklistSteps) {\n            ph.items = phChecklistSteps[ph.id]\n        } else {\n            ph.subPhases = phSubphases[ph.id]\n        }\n    })\n    return phases\n}","import React, { useContext } from 'react';\n\nimport {\n    Button,\n    Nav,\n    Navbar,\n    NavbarBrand,\n    NavbarText,\n} from \"reactstrap\";\n\nimport { AuthContext } from \"@meddbriefer/mdb-auth\"\n\n// {/* <Button color=\"primary\" onClick={prefsToggler}>\n//     Preferences\n// </Button> */}\n\n\nconst MDBNavBar = ({title, leftNav = null, rightNav = null }) => {\n\n    const { isAuthenticated, userName, signOutUser } = useContext(AuthContext)\n\n    return (\n        <Navbar color=\"dark\" dark>\n\n            <NavbarBrand href=\"#\">\n                MedDBriefer\n            </NavbarBrand>\n\n            {!!leftNav &&\n                <Nav>\n                {leftNav}\n                </Nav>\n            }\n\n            {!!title &&\n                <NavbarText tag=\"h3\">{title}</NavbarText>\n            }\n\n            <Nav>\n                {isAuthenticated &&\n                <>\n                    <NavbarText>\n                        Welcome, {userName} &nbsp;\n                    </NavbarText>\n                    <Button\n                        color=\"danger\"\n                        onClick={signOutUser}\n                    >\n                        Sign Out\n                    </Button>\n                </>\n                }\n                {!!rightNav &&\n                    rightNav\n                }\n            </Nav>\n\n        </Navbar>\n    )\n}\n\nexport default MDBNavBar;\n","import React, { useState, useEffect } from 'react';\nimport { Button, Table } from 'reactstrap';\nimport MDBNavBar from \"./MDBNavBar\"\nimport { getAssessmentIcon, getColor, getFeedback, getTimestamp, saveAnalysisLog} from \"./debriefingUtils\"\n\n\n\nconst DisplayBaseDebriefing = ({log, actions, scenario, context}) => {\n    const [showCommentColumn, setShowCommentColumn] = useState(false);\n    // eslint-disable-next-line\n    //const [events, setEvents] = useState(log.events);\n    const [formattedActions, setFormattedActions] = useState(undefined);\n\n// const Debriefing = ({ log, metaData, criticalActions, associations }) => {\n    /* const toggleCommentColumn = () => {\n        setShowCommentColumn(!showCommentColumn);\n    } */\n    \n\n    const saveAnalysisLogLocally = () => {\n        saveAnalysisLog(log,formattedActions)\n    }\n\n    const toggleComments = () => {\n        setShowCommentColumn(!showCommentColumn)\n    }\n\n    const dispHeaderRow = (entry) => {\n        return (\n            <>\n                {entry.id ===  \"assessmentHeader\"\n                    ? <td colSpan=\"4\" className={getColor(entry)}>\n                        <b>{entry.label}</b>\n                    </td>\n                    : <td colSpan=\"10\" className={\"black\"} >\n                        <div><em>\n                        &nbsp;&nbsp;&nbsp;Intervention Group: {entry.probLabel}</em></div>\n                    </td>}\n            </>\n        )\n    }\n    \n    function getLabel(entry) {\n        return(\n            <>\n            {entry.type === \"obtain-vital-sign\"\n                ? vitalLabel(entry)\n                : regularLabel(entry)\n            }\n            </>\n    \n        )\n    }\n    \n    function getStatusLabel(entry){\n        let metaData = scenario.intvMetaData\n        let metaEntry = metaData.find(me => (entry.vital === me.id))\n        return(<>{metaEntry.label}</>)\n    }\n    \n    function vitalLabel(entry){\n        return(\n            <>\n            {entry.vitalType === \"intervention-status\"\n                ? <>Requested intervention status for: {getStatusLabel(entry)}, <p>Found: <i>{entry.value}</i></p></>\n                : <>Requested vital: {entry.vital}, <p>Found: <i>{entry.value}</i></p></>\n            }\n            </>\n        )\n    }\n    \n    function regularLabel(entry) {\n        return(\n            <>\n            {entry.subPhase && entry.type !== \"intervention\"\n                ? <><b>{entry.subPhase}:</b> {entry.actionDescription}.  {findingsData(entry)}</>\n                : <>{phaseLabel(entry)}</>\n        }\n            </>\n        )\n    }\n    \n    function phaseLabel(entry){\n        return(\n            <>\n            {entry.type === \"intervention\"\n                ? <><b>Intervention:</b> {entry.actionDescription}. {findingsData(entry)} </>\n                : <>{entry.actionDescription}.  {findingsData(entry)}</>\n                }\n            </>\n        )\n    }\n        \n    function findingsData(entry){\n        return(\n            <>\n            {entry.finding\n            ?<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Findings: <i>{entry.finding}</i></p>\n            :<></>\n        }\n            </>\n        )\n    \n    }\n    \n    \n     function saveComment(val) {\n        let orig = val.target.defaultValue;\n        let comment = val.target.value;\n        let entryID = val.target.id;\n        if (orig !== comment){\n            let entry = formattedActions.find(entry => (entry.id === entryID))\n            // if (entry) { entry.comment = comment }}\n            const newEntry = Object.assign({}, entry, {comment: comment})\n            updateFormattedAction(newEntry)\n        }\n    }\n    \n    const dispDataRow = (entry) => {\n        return (\n            <>\n                <td>{entry.numericalID}</td>\n                <td>{getTimestamp(entry)}</td>\n                <td className={getColor(entry)}>\n                    <span className=\"material-icons-outlined\">{getAssessmentIcon(entry)}</span>\n                    {getLabel(entry)}\n                </td>\n                <td>{getFeedback(entry)}</td>\n\n                {showCommentColumn && <td><textarea rows=\"2\" cols=\"50\" defaultValue={entry.comment} onBlur={saveComment} id={`${entry.id}`}/></td>}\n            </>\n        )\n    }\n\n    \n    const updateFormattedAction = (record) => {\n        const index = formattedActions.findIndex(rec => rec.id === record.id)\n        setFormattedActions([\n            ...formattedActions.slice(0, index),\n            record,\n            ...formattedActions.slice(index+1)\n        ])\n    }    \n\n\n    async function displayIt () {\n        \n        \n        if (context === \"review\"){\n            //console.log(\"displaying for review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(true)        \n        }\n        else {\n            //console.log(\"displaying for non-review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(false)\n              }\n\n        setFormattedActions(actions)\n    \n        \n    }\n\n    \n   \n\n\n// eslint-disable-next-line\nuseEffect(\n    () => {\n        displayIt()\n        // eslint-disable-next-line\n    }, [] // empty list means this code will only be run on initial render\n)\n\n\n\nif (undefined === formattedActions) {\n    return (<h3>processing</h3>)\n}\n\nreturn (\n        <>\n            {context === \"review\"\n                ? <><MDBNavBar\n                    title={`Review of: ${log.label}`}\n                    leftNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={saveAnalysisLogLocally}>Save Debriefing Log\n                        </Button>}\n                    rightNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={toggleComments}>Toggle Comments\n                        </Button>}\n                     /></>\n                : <><MDBNavBar\n                    title={`Analysis for: ${log.label}`}\n                    /></>\n            }\n            <form>\n            <div style={{ overflowY: \"auto\", maxHeight: \"700px\" }}>\n                <Table borderless size=\"sm\">\n                    <thead>\n                        <tr>\n                            <th className=\"table-header\"> ID </th>\n                            <th className=\"table-header\"> Timestamp </th>\n                            <th className=\"table-header\"> Action Description </th>\n                            <th className=\"table-header\"> Feedback </th>\n                            {showCommentColumn && <th className=\"table-header\"> Comments </th>}\n                        </tr>\n                    </thead>\n                    <tbody className=\"scrolling\">\n                        {formattedActions.map((currentEntry, index) => (\n                            <tr key={index}>\n                                {currentEntry.type === \"header\"\n                                    ? dispHeaderRow(currentEntry)\n                                    : dispDataRow(currentEntry)\n                                }\n                            </tr>\n                        ))}\n                    </tbody>\n                </Table>\n            </div>\n        </form>\n        </>\n\n    )\n}\n\nexport {saveAnalysisLog}  \nexport default DisplayBaseDebriefing\n","import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID } from '@meddbriefer/scenario-data/index'\nimport {analyzeEvents} from './analyzeEvents'\nimport DisplayBaseDebriefing from './DisplayBaseDebriefing';\n\n\n\nfunction AnalyzeDebriefing ()  {\n    const { logID } = useParams()\n    const [observerLog, setObserverLog] = useState (undefined)\n    const [log, setLog] = useState(undefined)\n    const [scenario, setScenario] = useState(undefined)\n    const [analyzed, setAnalyzed] = useState(false)\n    const [loaded, setLoaded] = useState(false)\n\n    // eslint-disable-next-line\n    \n    // Set to true once all performed actions have been displayed in the log\n    // const [finishedPerformedActions, setFinishedPerformedActions] = useState(false);\n\n    //console.log (\"logID:\", logID)\n\n    function checkOnOverwriting() {\n        if (window.confirm (\"Are you sure you want to overwrite the existing analysis?  Any prior comments previously added will be lost.\")){\n            analyzeEventsHook(scenario, observerLog) \n            \n        }\n\n    }\n\n    async function analyzeEventsHook(scenario, log) {\n      analyzeEvents(scenario, log)}\n\n    \n    async function processEvents ()  {\n        //console.log(\"in processEvents to process a new observer file\")\n        if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n            {analyzeEventsHook(scenario, observerLog)\n            setAnalyzed(true)} \n        else {checkOnOverwriting()} \n        setAnalyzed(true)\n        return (true)    \n    }\n\n    useEffect(\n        () => {\n          getLog(db,logID)\n            .then(observerLogData => {  \n              //console.log(\"retrieve observerLogData\", observerLogData) \n              setObserverLog(observerLogData)    \n            })\n            .catch(error => alert('error fetching observer log', error))   \n        // eslint-disable-next-line\n    }, []\n      )\n    \n      useEffect(\n        () => {\n          !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n            .then(scenData => {\n              console.log(\"retrieve scenario:\", scenData)\n              setScenario(scenData)\n            })\n    \n        }, [observerLog]\n      )\n    \n      useEffect(\n        () => {\n          !!scenario && processEvents()\n          //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n    \n      useEffect(\n        () => {\n          !!analyzed && getDebriefLog(db, logID)\n            .then(logData => {\n              //console.log(\"retrieve Debriefing result:\", logData)\n              setLog(logData)  \n            })\n            .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n    \n      useEffect(\n        () => {\n          !!log && setLoaded(true) \n        }, [log]\n      )\n    \n      if (!loaded) {\n        return (<h3>Loading</h3>)\n      }\n    \n\n\n    return (\n        <DisplayBaseDebriefing\n        log={log}\n        actions={log.events}\n        scenario={scenario}\n        context={\"initial-analysis\"}\n        />\n    )\n}\n\nexport default AnalyzeDebriefing","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLog , getPublishedScenarioByID } from \"@meddbriefer/scenario-data/index\"\nimport AnalyzeDebriefing from '../components/AnalyzeDebriefing'\n\nconst Log = () => {\n\n  const { logID } = useParams()\n  const [ log, setLog ] = useState(null)\n  const [ scenario, setScenario] = useState(null)\n  const [loaded, setLoaded] = useState(false)\n\n  useEffect(\n    () => {\n      getLog(db,logID)\n        .then(logData => {\n          setLog(logData)\n        })\n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      //!!log && getScenarioByName(db, log.scenarioName, \"V2\")\n      !!log && getPublishedScenarioByID(db, log.scenarioID)\n        .then(scenData => {\n          setScenario(scenData)\n          console.log(\"scenario\", scenData)\n        })\n\n    }, [log]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && setLoaded(true)\n    }, [scenario]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n  return ( \n      <AnalyzeDebriefing \n        log={logID} \n      /> \n    )\n\n\n}\n\nexport default Log;\n","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { analyzeEvents } from '../components/analyzeEvents'\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID} from \"@meddbriefer/scenario-data/index\"\nimport DisplayBaseDebriefing from '../components/DisplayBaseDebriefing'\n\n\n\nfunction DisplayDebriefing () {\n\n  const { logID } = useParams()\n  const [observerLog, setObserverLog] = useState(undefined)\n  const [log, setLog] = useState(undefined)\n  const [scenario, setScenario] = useState(undefined)\n  const [analyzed, setAnalyzed] = useState(false)\n  const [loaded, setLoaded] = useState(false)\n\n  \n  \n  async function processLog () {\n    //console.log(\"in processLog to display existing analysis\")\n    if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n          {analyzeEvents(scenario, observerLog) \n          }\n    setAnalyzed(true)\n    return (true)\n  }\n  \n\n  //get observer log first\n\n  useEffect(\n    () => {\n      getLog(db, logID)\n        .then(observerLogData => {  \n          //console.log(\"retrieve observerLogData\", observerLogData) \n          setObserverLog(observerLogData)    \n        })\n        .catch(error => alert('error fetching observer log', error))   \n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n        .then(scenData => {\n          console.log(\"scenario:\", scenData)\n          setScenario(scenData)\n        })\n\n    }, [observerLog]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && processLog()\n      //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n      \n  useEffect(\n      () => {\n        !!analyzed && getDebriefLog(db,logID)\n          .then(logData => {\n            //console.log(\"retrieve Debriefing result:\", logData)\n            setLog(logData)  \n          })\n          .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n\n  useEffect(\n    () => {\n      !!log && setLoaded(true) \n    }, [log]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n\n\n  return (\n    <DisplayBaseDebriefing\n      log={log}\n      actions={log.events}\n      scenario={scenario}\n      context={\"review\"} />\n  )\n\n\n}\n\nexport default DisplayDebriefing;\n","import React from \"react\"\n\nimport MDBNavBar from \"./MDBNavBar\"\n\nconst UnauthedLayout = (props) => {\n\n    return (\n        <>\n            <MDBNavBar\n                title=\"MedDBriefer Authentication\"\n            />\n            { props.children }\n        </>\n    )\n}\n\nexport default UnauthedLayout","import React from \"react\"\n\nimport {\n    HashRouter as Router,\n    Switch,\n} from \"react-router-dom\"\n\nimport { AuthProvider, PrivateRoute } from \"@meddbriefer/mdb-auth\"\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport \"./styles.css\";\n\nimport LogList from \"./routes/LogList\"\nimport Log from \"./routes/Log\"\nimport DisplayDebriefing from \"./routes/DisplayDebriefing\"\n\n\nimport UnauthedLayout from \"./components/UnauthedLayout\"\n\nconst App = (props) => {\n\n    return (\n        <AuthProvider>\n            <Router>\n\n                <Switch>\n                    <PrivateRoute\n                        exact path=\"/logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={Log}\n                    />\n                    <PrivateRoute\n                        exact path=\"/debriefing-feedback-logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={DisplayDebriefing}\n                    />\n                    {/*default (catchall) route*/}\n                    <PrivateRoute\n                        exact match=\"/\"\n                        authFlowLayout={UnauthedLayout}\n                        component={LogList}\n                    />\n                </Switch>\n            </Router>\n        </AuthProvider>\n    )\n}\n\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
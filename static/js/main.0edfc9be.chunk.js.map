{"version":3,"sources":["../../../libs/mdb-firebase/index.js","../../../libs/scenario-data/constants.js","../../../libs/scenario-data/index.js","../../../libs/scenario-data/intvPrompts.js","../../../libs/scenario-data/intvMenuItems.js","routes/LogList.js","../../../libs/feedback-data/c1Data.js","../../../libs/feedback-data/c2Data.js","../../../libs/feedback-data/analysisData.js","../../../libs/feedback-data/Bogus data for testingA.js","components/debriefingUtils.js","utils.js","components/scenarioDataAccesors.js","components/summarizeAnalysis.js","components/analyzeEvents.js","components/MDBNavBar.js","components/DisplayBaseDebriefing.js","components/AnalyzeDebriefing.js","routes/Log.js","routes/DisplayDebriefing.js","components/UnauthedLayout.js","App.js","reportWebVitals.js","index.js"],"names":["userApp","getOrInitializeApp","appCfg","name","app","appID","matches","firebase","apps","filter","options","appId","length","getApp","initializeApp","process","REACT_APP_APP_ENV","console","log","apiKey","authDomain","projectId","storageBucket","messagingSenderId","measurementId","prodApp","db","auth","firestore","ASSESS","ASSESS_OPTION","AWO","DECISION","DECISION_OPTION","INTERV","PHASE","REQUIRED","SUB_PHASE","MDB_TYPES","Object","freeze","ASSESSO","CL_HEADING","CL_PROMPT","DIST_PROMPT","NESTED_CHECKLIST","REQURED","PROMPT_SET","PROMPT","ANSWER","SELECTION_TYPES","ONE","OOM","NONE","CHECKLIST_STEP_TYPES","AW","BR","BL","SH","OPTION_TYPES","ANALYSIS_TYPES","MIN","OPT","REQ","CONTRA","UNN","IR","getPublishedScenarioByID","ST","interventionID","scenarioID","collection","doc","get","then","data","verifyDocument","collectionId","documentId","a","where","set","empty","getLog","logID","id","getDebriefLog","LogList","useState","logs","setLogs","logsLoaded","setLogsLoaded","useEffect","querySnapshot","docs","map","label","scenario","scenarioName","userName","timestamp","result","catch","error","Table","striped","borderless","size","hover","to","colorTypes","iconTypes","assessmentEntries","phaseStatusList","absent","errors","good","leafStatusList","misordered","misorderedErrors","exceptionDefs","exceptions","globalConstraints","before","beforeOp","after","afterOp","type","conditionalConstraints","scenarioConstraintIDs","intvChecks","intvStatusNeeded","vitalsNeeded","M2CA_PhaseIE","Action","feedbackAbsent","feedbackOutOfOrder","feedbackError","subActions","feedbackErrors","examine","prompts","pushNew","elt","array","includes","push","getPhaseStatus","statuses","itemStatuses","phaseStatuses","forEach","status","entries","key","value","getStatesForStatus","stateList","state","getAssessmentEntry","currentEntry","aIndex","assessmentEntry","displayColor","getColor","fixStrSp","textString","newString","textArray","split","lenTextArray","item","i","newItem","trim","getFBField","field","getFeedback","intvStatus","intvStatusFB","fb","checked","notChecked","entry","foundCk","generateIntvStatusFB","feedbackString","feedbackArray","firstChar","charAt","substring","previousString","slice","nextString","toUpperCase","scenarioConstraints","getEvents","events","val","getEventsByIdTime","_","require","saveAnalysisLog","actions","hierAssessResults","hierProblemResults","constraintsViolated","docRef","ObserverFileCreater","ObserverFileName","commenter","schemaVersion","Date","toLocaleString","newActionsList","newObj","filterUnknown","logObj","index","undefined","pickBy","getTimestamp","seconds","toISOString","substr","groupByKey","listOfObjs","fldName","reduce","hash","obj","concat","getChecklistItemsByType","itemType","checkListMetaData","e","allAssessResults","allProblemResults","getEntriesUnderHeader","headerID","level","populate","header","mergeHeaderStatuses","results","itemIDs","filtered","eventItems","inPhase","phaseID","subtype","overallStatus","headerStatuses","headerItems","translateEvent","event","newEvent","labelID","expertPhase","fld","topHier","level2Hier","summarizeAnalysis","finalActions","problems","requiredPhaseAndSubPhases","requiredPhaseNames","prob","probLabel","headerObject","entryToModify","origAction","section","subLevel","topLevel","constraint","arg1","workingPhase","phaseOrderStatus","arg2","summary","newStatus","updateTopHeaders","assess","probs","c2Input","top","table","summarize_topLevel","scenarios","requiredSubphases","itemByID","itemByLabel","checklistHierarchy","problemStates","cautionStates","subPhases","initGlobals","scen","constraintIDs","initializeConstraints","action","subaction","get2HierLevelIDs","initializeItemLookupByID","initializeItemLookupByLabel","phases","clSteps","stepOptions","step","phChecklistSteps","subPhase","spChecklistSteps","sp","items","phSubphases","ph","getChecklistHierarchy","findPhaseSubphasesOrdered","intvLookupByID","checklistLookupByID","interventions","intvMetaData","assign","intvLookupByLabel","checklistLookupByLabel","subPhIds","findNameNumID","names","occurrence","numericalID","numericalIDStart","numericalIDEnd","unknownItem","getItem","findObjByNumerialID","phaseNames","phaseIndex","phaseObjects","phaseName","hasSubPhases","storeMisOrderedArgs","objToModify","saveFailedConstraint","lateArg","otherArg","constraintID","op","addToListOfFeedback","parPhFB","last","repeating","toLowerCase","checkAgainst2ndArgs","arg1st","args2nd","direction","entryNames","constraintType","endNum1st","startNum1st","label1st","phFB","par1PhFB","par2PhFB","counter","violations","arg","arg2nd","label2nd","startNum2nd","endNum2nd","FB","orderingFB","appendString","storeMisOrderedFB","checkAgainstKB","listOfNames","listOfEntries","uniqueListOfNames","startIndex","endIndex","phaseObjectNames","collectEntriesToCheckConstraints","uniqueEntryNames","firstArg","firstArgItem","constraints","getConstraint","checkConstraintsForArg","insertInPhaseInOrder","object","objIndex","phase","when","lastIndexOf","splice","getEndSubPhaseIndex","inPhaseId","subPhaseName","getSubPhases","reversedSubPhases","reverse","find","getEndSubPhase","phaseId","determineHLcolor","lowerColor","higherColor","newColor","evalForIncorrectAnswer","promptID","answerID","isIntervention","answers","associations","checkListCorrectness","Array","isArray","ansId","getCorrectAnswerLabel","metaData","answerLabels","answer","j","getAnswerLabel","answerLabel","insertMissingInterventions","confirmedEvents","indexCounter","sol","solutions","k","phaseObject","phaseVal","assessments","assessmentsNeeded","protocols","protocol","actionDescription","suggestedPhase","string","protocolRelationship","orderedArrayObjects","objectsBefore","objectBefore","requiredObjectBefore","required","objectAfter","requiredObjectAfter","indexBefore","indexAfter","indexRequiredBefore","indexRequiredAfter","insertionIndex","findIndex","insertInPhaseRelativeToSuggestedOrder","analyzeEvents","problemDefs","problemActions","defs","sols","problemDef","problem","solutionIDs","probSols","problemID","lifeThreat","vitals","allActions","allContras","assessmentID","solID","solution","otherActions","actEntries","actIDs","act","solutionID","minimalWhy","contraindications","minimal","optional","allProblemProtocols","setupProblems","formattedActions","annotatedResults","interventionsConfirmed","trackForStatus","priorPhase","parentPhase","parentIndex","newPhaseStart","assessmentTypes","eventObj","eventType","processingState","prioreventObj","correctAnswerLabel","givenAnswerLabel","wrongAnswer","answerDetails","intervention","pop","answerCorrect","incorrectAnswersFB","vital","vitalType","vitalEntry","vitalEntries","updatedEntries","updateVital","PROBLEM_ACTION_FIELDS","statusChecking","intv","initialEntry","contra","incorrectAnswerFB","annotateInputEvents","intvsTracking","kbUpdates","updatedPhases","priorPh","insertMissingSubphases","postAssessmentReview","neededScenAssessments","collectScenAssessments","checklistSteps","md","exceptionDef","exception","why","cls","assessmentFB","assessmentFindings","checkForMissingAssessments","postInterventionReview","statusTracking","toUpdate","insertMissingIntvChecks","displayObjects","entryIndex","headerIndex","problemHeaderColor","subPhaseColor","subPhaseStatuses","newPhaseObjects","headerObj","subHeaderObj","priorHLPhaseItem","endEntry","iPhaseObjects","subheader","localPhaseName","localPhaseItem","highLevelPhase","highLevelPhaseItem","organizeLogDisplay","pActions","pNames","pIndex","pActIndex","indexOf","processedIds","pIds","pEntry","actionNeeded","minimalNeeded","found","allActionFound","allMinimalFound","numericalIDsChanged","foundId","z","candidateHeader","foundHeader","findHeaderFor","summaryResults","MDBNavBar","title","leftNav","rightNav","useContext","AuthContext","isAuthenticated","signOutUser","Navbar","color","dark","NavbarBrand","href","Nav","NavbarText","tag","Button","onClick","DisplayBaseDebriefing","context","showCommentColumn","setShowCommentColumn","setFormattedActions","getLabel","vitalLabel","regularLabel","getStatusLabel","metaEntry","me","findingsData","phaseLabel","finding","saveComment","orig","target","defaultValue","comment","entryID","newEntry","updateFormattedAction","dispDataRow","className","rows","cols","onBlur","record","rec","displayIt","style","overflowY","maxHeight","colSpan","AnalyzeDebriefing","useParams","observerLog","setObserverLog","setLog","setScenario","analyzed","setAnalyzed","loaded","setLoaded","checkOnOverwriting","window","confirm","analyzeEventsHook","observerLogData","alert","scenData","processEvents","logData","Log","DisplayDebriefing","processLog","UnauthedLayout","props","children","App","exact","path","authFlowLayout","component","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0edfc9be.chunk.js","sourcesContent":["import firebase from 'firebase/app'\nimport \"firebase/auth\";\nimport \"firebase/firestore\"\n\nconst prodFirebaseCfg = {\n    apiKey: \"AIzaSyBOgWAbXUGckpad2sk0IUo00hZsV4WxG0E\",\n    authDomain: \"meddbriefer-68cd4.firebaseapp.com\",\n    projectId: \"meddbriefer-68cd4\",\n    storageBucket: \"meddbriefer-68cd4.appspot.com\",\n    messagingSenderId: \"1087114796018\",\n    appId: \"1:1087114796018:web:679fbab38dbf78af0ce96b\",\n    measurementId: \"G-Q7QZKC9KHW\"\n}\n\nconst devFirebaseCfg = {\n    apiKey: \"AIzaSyBqnEMwEstp4D7Mvtbw9OTAiNJ7qza0Ses\",\n    authDomain: \"meddbriefer-dev.firebaseapp.com\",\n    projectId: \"meddbriefer-dev\",\n    storageBucket: \"meddbriefer-dev.appspot.com\",\n    messagingSenderId: \"144940722070\",\n    appId: \"1:144940722070:web:4de179ebb58d84a7679fb7\"\n};\n\n\nconst pamFirebaseCfg = {\n    apiKey: \"AIzaSyB9eVT-fu4TOjxHoPAXqsnz9tCcbTJkTOw\",\n    authDomain: \"pamdev-ea800.firebaseapp.com\",\n    projectId: \"pamdev-ea800\",\n    storageBucket: \"pamdev-ea800.appspot.com\",\n    messagingSenderId: \"366450927885\",\n    appId: \"1:366450927885:web:caa5f022ef1de182a0e844\",\n    measurementId: \"G-JC5XZEPYT1\"\n  };\n\n  const scottFirebaseConfig = {\n  apiKey: \"AIzaSyBEhbIdVW2F2vvvfvpNb2SsCDP9Yoc__z8\",\n  authDomain: \"scottdev-f6528.firebaseapp.com\",\n  projectId: \"scottdev-f6528\",\n  storageBucket: \"scottdev-f6528.appspot.com\",\n  messagingSenderId: \"447730403122\",\n  appId: \"1:447730403122:web:1727020dbac4ad4cf6f92b\"\n\n};\n\n// console.log(`NODE_ENV: ${process.env.NODE_ENV}`)\n\nlet userApp\n\nconst getApp = (appID) => {\n    const matches = firebase.apps.filter(app => app.options.appId === appID)\n    // console.log(\"matches\", matches)\n    return (matches.length === 1) ? matches[0] : null\n}\n\nconst getOrInitializeApp = (appCfg, name) => {\n    const app = getApp(appCfg.appId)\n    // console.log(`${appCfg.appId} already exists: ${!!app}`)\n    return (!!app) ? app : firebase.initializeApp(appCfg, name)\n}\n\n// don't reinitialize app if it already exists\n// const prodApp = !firebase.apps.length ? firebase.initializeApp(prodFirebaseCfg) : firebase.app()\n//const prodApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\nif (\"pam\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using pjordan config\")\n    userApp = getOrInitializeApp(pamFirebaseCfg, \"pam\")\n} else if (\"scott\" === process.env.REACT_APP_APP_ENV) {\n    console.log(\"using scott config\")\n    userApp = getOrInitializeApp(scottFirebaseConfig)\n}\nelse {\n    console.log(\"using production config\")\n    userApp = getOrInitializeApp(prodFirebaseCfg, \"production\")\n}\n\nconst prodApp = userApp;\n// const devApp = function() {\n//     if (process.env.NODE_ENV !== \"production\") {\n//         return getOrInitializeApp(devFirebaseCfg, \"development\")\n//      }\n//      return null\n// }()\n\n// console.log(firebase.apps)\n\n\n\n\nexport const auth = prodApp.auth()\nexport const db = prodApp.firestore()\n\n// export const db = function() {\n//     return process.env.NODE_ENV !== \"production\" ? devApp.firestore() : prodApp.firestore()\n// }()\n","// the following constants are deprecated (need to figure out how to handle this)\n// use MDB_TYPES, SELECTION_TYPES, PREFIXES, and SYSTEMS instead\nexport const ANSWER = \"answer\"\nexport const ASSESS = \"assessment\"\nexport const ASSESSO = \"assessment-option\"\nexport const ASSESS_OPTION = \"assessment-option\"\nexport const AWO = \"assessment-with-options\"\nexport const CB = \"checkbox\"\nexport const CL_HEADING = \"checklist-heading\"\nexport const CL_PROMPT = \"checklist-prompt\"\nexport const CRIT_FAIL = \"critical-criteria\"\nexport const DECISION = \"decision\"\nexport const DECISION_OPTION = \"decision-option\"\nexport const DIST_PROMPT = \"distinguishing-prompt\"\nexport const HEADING = \"heading\" //not a leaf node, simply a step which has child steps\nexport const INTERV = \"intervention\" // an action performed on the patient\nexport const INTV_FORM = \"intervention-form\"\nexport const NESTED_CHECKLIST = \"nested-checklist\"\nexport const NONE = \"none\"\nexport const ONE = \"one\"\nexport const OOM = \"one-or-more\"\nexport const OPTION = \"option\"\nexport const PHASE = \"phase\"\nexport const PROMPT = \"prompt\"\nexport const PROMPT_SET = \"prompt-set\"\nexport const REQUIRED = \"required-action\"   // an action the EMT performs, but not on the patient\n// keeping as I had a typo. need to deprecate somehow\nexport const REQURED = REQUIRED\nexport const SUB_PHASE = \"sub-phase\"\n\nexport const MDB_TYPES = Object.freeze({\n    PHASE: PHASE,\n    SUB_PHASE: SUB_PHASE,\n    ASSESS: ASSESS,\n    AWO: AWO,\n    ASSESS_OPTION: ASSESS_OPTION,\n    ASSESSO: ASSESS_OPTION,\n    CL_HEADING: CL_HEADING,\n    CL_PROMPT: CL_PROMPT,\n    DECISION: DECISION,\n    DECISION_OPTION: DECISION_OPTION,\n    DIST_PROMPT: DIST_PROMPT,\n    NESTED_CHECKLIST: NESTED_CHECKLIST,\n    REQUIRED: REQUIRED,\n    REQURED: REQUIRED,\n    INTERV: INTERV,\n    PROMPT_SET: PROMPT_SET,\n    PROMPT: PROMPT,\n    ANSWER: ANSWER,\n})\nexport const SELECTION_TYPES = Object.freeze({\n    ONE: ONE,\n    OOM: OOM,\n    NONE: NONE\n})\nexport const SELECTION_TYPE_LABELS = Object.freeze({\n    ONE: \"One\",\n    OOM: \"One or more\",\n    NONE: \"None\"\n})\nexport const PREFIXES = Object.freeze({\n    PHASE: \"\",\n    SUB_PHASE: \"\",\n    ANSWER: \"answer-\",\n    ASSESS: \"assess-\",\n    AWO: \"assessment-with-options-\",\n    ASSESS_OPTION: \"assess-option-\",\n    CL_PROMPT: \"cl-prompt-\",\n    DECISION: \"decision-\",\n    DECISION_OPTION: \"decision-option-\",\n    INTERV: \"intv-\",\n    PROMPT_SET: \"prompt-set-\",\n    PROMPT: \"prompt-\",\n    REQUIRED: \"required-action-\",\n})\n\nexport const SYSTEMS = Object.freeze({\n    AW: \"airway\",\n    BR: \"breathing\",\n    BL: \"bleeding\",\n    SH: \"shock\",\n})\nexport const SYSTEM_LABELS = Object.freeze({\n    AW: \"Airway\",\n    BR: \"Breathing\",\n    BL: \"Bleeding\",\n    SH: \"Shock\"\n})\n\nexport const CHECKLIST_STEP_TYPES = [ASSESS, AWO, DECISION, REQUIRED]\nexport const OPTION_TYPES = [ASSESS_OPTION, DECISION_OPTION]\nexport const ANALYSIS_TYPES = [ASSESS, AWO, DECISION, REQUIRED, INTERV, PHASE, SUB_PHASE]\n\nexport const PROTOCOL_RELATIONSHIPS = Object.freeze({\n    NONE: \"\",\n    MIN: \"minimal\",\n    OPT: \"optional\",\n    REQ: \"required\",\n    CONTRA: \"contraindicated\",\n    UNN: \"unnecessary\",\n    IR: \"irrelevant\"\n})","\nimport _ from \"lodash\"\n\nimport { MDB_TYPES } from \"./constants.js\"\nimport { ScenarioType, PublishedScenario } from \"./types.js\"\n\n// the rest of these imports can go away soon. simply allows me to delete objects form the db\n// and reload with files. not used if records exist in db\nimport INTVS from \"./intvs.js\"\nimport INTV_PROMPTS from \"./intvPrompts.js\"\nimport INTV_PROMPT_ANSWERS from \"./intvPromptAnswers.js\"\nimport INTV_MENU_CATS from \"./intvMenusCats.js\"\nimport INTV_MENU_ITEMS from \"./intvMenuItems.js\"\n\nexport const loadIntvs = () => {\n    const tmp = INTVS.map(e => {\n        const rec = {...e}\n        if (!e.abbrLabel) {\n            rec.abbrLabel = e.label\n        }\n        if (!e.distPrompts) {\n            rec.distPrompts = []\n        }\n        if (!e.prompts) {\n            rec.prompts = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPrompts = () => {\n    const tmp = INTV_PROMPTS.map(e => {\n        const rec = {...e}\n        if (!!e.interventionID) {\n            const found = INTVS.find(i => i.id === e.interventionID)\n            if (!found) {\n                console.log(`loadIntvPrompts(${e.id}) ${e.interventionID} not found`)\n            }\n        }\n        if (!e.abbrLabel) {\n            rec.abbrLabel = \"\"\n        }\n        if (!e.feedback) {\n            rec.feedback = rec.label\n        }\n        if (!e.answers) {\n            rec.answers = []\n        }\n        return rec\n    })\n    return tmp\n}\n\nexport const loadIntvPromptAnswers = () => {\n    const tmp = INTV_PROMPT_ANSWERS.map(e => {\n        if (!e.abbrLabel) {\n            e.abbrLabel = \"\"\n        }\n        const found = INTV_PROMPTS.find(p => p.id === e.promptID)\n        if (!found) {\n            console.log(`loadIntvPromptAnswers(${e.id}) ${e.promptID} not found`)\n        }\n        return e\n    })\n    return tmp\n}\n\nexport const getScenarios = (db, scenarioType, schemaVersion) => {\n    const query = db.collection(\"scenarios\")\n             .where(\"scenarioType\", \"==\", scenarioType)\n             .where(\"schemaVersion\", \"==\", schemaVersion)\n    return query.get()\n        .then(snapShot => {\n            const scenarios = []\n            if (snapShot.size > 0) {\n                snapShot.docs.forEach(doc => {\n                    const data = doc.data()\n                    scenarios.push({\n                        id: data.id,\n                        name: data.name,\n                        scenarioType: data.scenarioType,\n                        schemaVersion: data.schemaVersion\n                    })\n                })\n            }\n            return scenarios\n        })\n}\n\nexport const getPublishedScenarioObjectByID = async (db, scenarioID) => {\n    const data = await getPublishedScenarioByID(db, scenarioID)\n    return new  PublishedScenario(data)\n}\n\nexport const getPublishedScenarioByID = (db, scenarioID) => {\n    return db.collection(\"published-scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByID = (db, scenarioID) => {\n    return db.collection(\"scenarios\").doc(scenarioID).get().then(doc => doc.data())\n}\n\nexport const getScenarioByName = (db, scenarioName, schemaVersion) => {\n    return db.collection(\"scenarios\")\n    .where(\"name\", \"==\", scenarioName)\n    .where(\"schemaVersion\", \"==\", schemaVersion)\n    .limit(1)\n    .get()\n    .then(snapShot => {\n        if (snapShot.size === 1) {\n            return snapShot.docs[0].data()\n        } else {\n            throw new Error(\"document not found\")\n        }\n    })\n}\n\nconst addMissingScenarioTypeFields = (scenTypeData) => {\n    const msgs = []\n    if (!scenTypeData.interventions) {\n        msgs.push(\"loading intvs from file\")\n        scenTypeData.interventions = loadIntvs()\n    }\n    if (!scenTypeData.interventionPrompts) {\n        const errs = []\n        const tmpPrompts = loadIntvPrompts()\n        tmpPrompts.forEach(e => {\n            if (e.type === MDB_TYPES.PROMPT) {\n                // ignore this check if distinguishing prompt (not associated with a single intv)\n                if (undefined === scenTypeData.interventions.find(rec => rec.id === e.interventionID)) {\n                    errs.push(`bad interventionID ${e.interventionID}`)\n                }\n            }\n        })\n        let msg = \"loading intv prompts from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPrompts = tmpPrompts\n    }\n    if (!scenTypeData.interventionPromptAnswers) {\n        const errs = []\n        const tmpPromptAnswers = loadIntvPromptAnswers()\n        tmpPromptAnswers.forEach(e => {\n            if (undefined === scenTypeData.interventionPrompts.find(rec => rec.id === e.promptID)) {\n                errs.push(`bad promptID ${e.promptID}`)\n            }\n        })\n        let msg = \"loading intv prompt answers from file...\"\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionPromptAnswers = tmpPromptAnswers\n    }\n    if (!scenTypeData.interventionMenuCategories) {\n        msgs.push(\"loading intv menu categories from file\")\n        scenTypeData.interventionMenuCategories = INTV_MENU_CATS\n    }\n    if (!scenTypeData.interventionMenuItems) {\n        const errs = []\n        const tmpIntvMenuItems = INTV_MENU_ITEMS.map(e => {\n            const found = scenTypeData.interventionMenuCategories.find(cat => cat.id === e.intvCategoryID)\n            if (!found) {\n                errs.push(`bad intvCategoryID ${e.intvCategoryID}`)\n            } else {\n                if (e.type === MDB_TYPES.INTERV) {\n                    const intv = scenTypeData.interventions.find(i => i.id === e.interventionID)\n                    if (!intv) {\n                        errs.push(`bad interventionID ${e.interventionID}`)\n                    } else {\n                        e.label = intv.label\n                    }\n                }\n                return e\n            }\n        })\n        let msg = \"loading intv menu items from file...\"\n\n        if (errs.length > 0) {\n            msgs.push(msg)\n            errs.forEach(e => msgs.push(e))\n        } else {\n            msg += \"no errors found\"\n            msgs.push(msg)\n        }\n        scenTypeData.interventionMenuItems = tmpIntvMenuItems\n    }\n    if (msgs.length > 0) {\n        msgs.forEach(m => console.log(m))\n    } else {\n        console.log(\"all data loaded from db. files not needed\")\n    }\n    return scenTypeData\n}\n\nexport const getScenarioTypeObjectByID = async (db, scenarioTypeID) => {\n    const data = await getScenarioTypeByID(db, scenarioTypeID)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeObject = async (db, scenarioType, schemaVersion) => {\n    const data = await getScenarioType(db, scenarioType, schemaVersion)\n    return new ScenarioType(data)\n}\n\nexport const getScenarioTypeByID = (db, scenarioTypeID) => {\n    return db.collection(\"scenario-types\")\n        .doc(scenarioTypeID)\n        .get()\n        .then(doc => {\n        const data = doc.data()\n        data.id = doc.id\n        return addMissingScenarioTypeFields(data)\n        })\n        .catch(error => {\n            console.log(error)\n            return error\n        })\n}\n\nexport const getScenarioType = (db, scenarioType, schemaVersion) => {\n    return db.collection(\"scenario-types\")\n            .where(\"name\", \"==\", scenarioType)\n            .where(\"schemaVersion\", \"==\", schemaVersion)\n            .limit(1)\n            .get()\n            .then(snapShot => {\n                if (snapShot.size === 1) {\n                    return addMissingScenarioTypeFields(snapShot.docs[0].data())\n                } else {\n                    throw new Error(\"document not found\")\n                }\n            })\n}\n\n\n\n// FIXME: this needs to go away, although I need to figure out if it's in use anywhere first\nexport const getPromptAndOptions = (scenarioTypeOrPubScenario, promptID) => {\n    const scenType = scenarioTypeOrPubScenario\n    const prompt = scenType.interventionPrompts.find(e => e.id === promptID)\n    if (!!prompt) {\n        const options = prompt.answers.map(ansID => scenType.interventionPromptAnswers.find(a => a.id === ansID))\n        prompt.options = options.map(opt => {\n            return {...opt, prompt: prompt.label}\n        })\n    }\n    return prompt\n}\n\n// moved over from apps/data-entry/src/scripts/connect-firebase\n// added 'db' as first param so that these functions can be used either from web or server firebase APIs\n/**\n * Verify document doesn't already exist in database.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns True if document with given ID doesn't exist yet.\n */\nexport const verifyDocument = async (db, collectionId, documentId) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    return set.empty;\n};\n\n// returns true if combo of name and schemaVersion fields is unique\nexport const verifyDocNameUniqueness = async (db, collectionID, candidateName, dbNameField, schemaVersion) => {\n    const snapshot = await db.collection(collectionID)\n        .where(dbNameField, \"==\", candidateName)\n        .where(\"schemaVersion\", \"==\", schemaVersion)\n        .get()\n    return snapshot.empty\n}\n\n// Upload document object to database\nexport const publishDocument = async (db, collectionId, documentObject, documentId) => {\n    documentId\n        ?\n        await db.collection(collectionId).doc(documentId).set(documentObject) :\n        await db.collection(collectionId).doc().set(documentObject);\n};\n\n// Update document with given id\nexport const updateDocument = async (db, collectionId, documentId, documentObject) => {\n    const set = await db.collection(collectionId).where(\"id\", \"==\", `${documentId}`).get();\n    set.empty ?\n        publishDocument(collectionId, documentObject) :\n        await db.collection(collectionId).doc(set.docs[0].id).set(documentObject);\n};\n\n/**\n * Will save document, using auto-generated IDs if documentObject doesn't have\n * an 'id' attribute.\n * @param {object} db instance\n * @param {string} collectionId\n * @param {object} documentObject\n */\nexport const saveDocument = async (db, collectionId, documentObject) => {\n    const doc = (!documentObject.id) ?\n        db.collection(collectionId).doc() :\n        db.collection(collectionId).doc(documentObject.id);\n    documentObject.id = doc.id;\n    await doc.set(documentObject);\n    return documentObject.id\n}\n\n/**\n * Query collection for document with id\n * @param {object} db instance\n * @param {string} collectionId\n * @param {string} documentId\n * @returns {object} Object containing document data.\n */\nexport const getDocument = async (db, collectionId, documentId) => {\n    const doc = await db.collection(collectionId).doc(documentId).get();\n    return doc.data();\n};\n\n/**\n * Query collection for document with name\n * @param {string} collectionId\n * @param {string} documentName\n * @returns {object} Object containing document data.\n */\nexport const getDocumentWithName = async (db, collectionId, documentName) => {\n    const set = await db.collection(collectionId).where(\"name\", \"==\", `${documentName}`).get();\n    return set.docs[0]?.data();\n};\n\n/**\n * Delete document from collection\n * @param {string} collectionId\n * @param {string} documentId\n */\nexport const deleteDocument = async (db, collectionId, documentId) => {\n    await db.collection(collectionId).doc(documentId).delete();\n};\n\n/**\n * Pull collection from database as array of document objects\n * @param {string} collectionId\n * @returns {object[]} An array containing all of the document in the collection.\n */\nexport const getCollection = async (db, collectionId) => {\n    const collection = await db.collection(collectionId).get();\n    return collection.docs?.map(item => item.data());\n};\n\n// copied over from /apps/debriefer/src/scripts/connect-firebase and 'db' param added as first param\n\n// Get a list of document names and a copy of each document\nexport const listDocumentNames = async (db, collectionId) => {\n    let documentList = db.collectionGroup(collectionId);\n    let documentDictionary = {};\n    documentList.get().then((querySnapshot) => {\n        querySnapshot.forEach((doc) => {\n            documentDictionary[doc.id] = doc.data();\n        });\n    });\n    return documentDictionary;\n}\n\nexport const getLogs = (db) => {\n    return db.collection(\"logs\").get()\n        .then(querySnapshot => {\n            return querySnapshot.docs.map(doc => {\n                const data = doc.data()\n                return {\n                    id: doc.id,\n                    label: data.label,\n                    scenario: data.scenarioName,\n                    userName: data.userName,\n                    timestamp: data.timestamp\n                }\n            })\n        })\n}\n\n\nexport const getLog = (db, logID) => {\n    return db.collection(\"logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const getDebriefLog = (db, logID) => {\n    return db.collection(\"debriefing-feedback-logs\").doc(logID).get()\n        .then((doc) => {\n            const data = doc.data()\n            data.id = doc.id\n            //let scenario = data.scenario;   //temporary until DB scenario name is fixed but won't hurt anything\n            //scenario = scenario.replace(\"PHTC \",\"\");  //temporary until DB scenario name is fixed but won't hurt anything\n            //data.scenario = scenario;\n            return data\n        })\n}\n\nexport const createInterventionVariant = (distPromptIds2OptIds) => {\n    // the list of opt IDs mapped to each distPromptID needs to be sorted in order\n    // to make them comparable\n    const retVal = {}\n    Object.entries(distPromptIds2OptIds).forEach(([distPromptID, optionsArray]) => {\n        retVal[distPromptID] = optionsArray.sort()\n    })\n    return retVal\n}\n\nexport const interventionVariantsAreEqual = (intvVariant1, intvVariant2) => {\n    return _.isEqual(intvVariant1, intvVariant2)\n}\n\n","import { MDB_TYPES, SELECTION_TYPES as ST } from \"@meddbriefer/scenario-data/constants.js\"\n\nconst INTV_PROMPTS = [\n    {\n        \"id\": \"prompt-wound-location\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.ONE,\n        label: \"Where is the wound located?\",\n        abbrLabel: \"Wound location?\",\n        answers: [\n            \"answer-wound-location-head\",\n            \"answer-wound-location-neck\",\n            \"answer-wound-location-chest\",\n            \"answer-wound-location-abdomen-pelvis\",\n            \"answer-wound-location-posterior\",\n            \"answer-wound-location-genitalia\",\n            \"answer-wound-location-left-lower-extremity\",\n            \"answer-wound-location-right-lower-extremity\",\n            \"answer-wound-location-left-upper-extremity\",\n            \"answer-wound-location-right-upper-extremity\",\n            \"answer-wound-location-other\"\n        ]\n    },\n    {\n        \"id\": \"prompt-wound-locations\",\n        type: MDB_TYPES.DIST_PROMPT,\n        selectionType: ST.OOM,\n        label: \"Where are the wound(s) located?\",\n        abbrLabel: \"Wound location(s)?\",\n        answers: [\n            \"answer-wound-locations-head\",\n            \"answer-wound-locations-neck\",\n            \"answer-wound-locations-chest\",\n            \"answer-wound-locations-abdomen-pelvis\",\n            \"answer-wound-locations-posterior\",\n            \"answer-wound-locations-genitalia\",\n            \"answer-wound-locations-left-lower-extremity\",\n            \"answer-wound-locations-right-lower-extremity\",\n            \"answer-wound-locations-left-upper-extremity\",\n            \"answer-wound-locations-right-upper-extremity\",\n            \"answer-wound-locations-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-airway-patency-suction-device\",\n        \"interventionID\": \"intv-airway-patency-technique-suction-airway\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What kind of suction catheter will you use?\",\n        \"abbrLabel\": \"Suction catheter type?\",\n        \"answers\": [\n            \"answer-airway-patency-suction-yankauer\",\n            \"answer-airway-patency-suction-long-multiuse\",\n            \"answer-airway-patency-suction-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-advanced-airway-adjunct-type\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of advanced airway adjunct would you use?\",\n        \"abbrLabel\": \"Which advanced airway?\",\n        \"answers\": [\n            \"answer-alternative-rescue-airway-type-ett\",\n            \"answer-alternative-rescue-airway-type-combitube\",\n            \"answer-alternative-rescue-airway-type-lta\",\n            \"answer-alternative-rescue-airway-type-lma\",\n            \"answer-alternative-rescue-airway-type-igel\",\n            \"answer-alternative-rescue-airway-type-other\"\n        ]\n    }, {\n        \"id\": \"prompt-advanced-airway-tube-size\",\n        \"interventionID\": \"intv-advanced-airway-adjunct\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\":\"one\",\n        \"label\": \"What tube size for advanced airway?\",\n        \"abbrLabel\": \"What size?\",\n        \"answers\": [\n            \"answer-alternative-airway-tube-size-7\",\n            \"answer-alternative-airway-tube-size-8\",\n            \"answer-alternative-airway-tube-size-age-div-4-plus-4\",\n            \"answer-alternative-airway-tube-size--age-div-4-plus-4-minus-5\",\n            \"answer-alternative-airway-tube-size-37f\",\n            \"answer-alternative-airway-tube-size-41f\",\n            \"answer-alternative-airway-tube-size-0\",\n            \"answer-alternative-airway-tube-size-1\",\n            \"answer-alternative-airway-tube-size-1-5\",\n            \"answer-alternative-airway-tube-size-2\",\n            \"answer-alternative-airway-tube-size-2-5\",\n            \"answer-alternative-airway-tube-size-3\",\n            \"answer-alternative-airway-tube-size-4\",\n            \"answer-alternative-airway-tube-size-5\",\n            \"answer-alternative-airway-tube-size-6\",\n            \"answer-alternative-airway-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-orotracheal-intubation-tube-insertion-depth\",\n        \"interventionID\": \"intv-orotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what depth would you insert the tube?\",\n        \"abbrLabel\": \"Tube insertion depth?\",\n        \"answers\": [\n            \"answer-orotracheal-intubation-tube-insertion-depth-21cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-23cm\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-3-times-tube-size\",\n            \"answer-orotracheal-intubation-tube-insertion-depth-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasotracheal-intubation-tube-size\",\n        \"interventionID\": \"intv-nasotracheal-intubation\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What tube size would you use?\",\n        \"abbrLabel\": \"Tube size?\",\n        \"answers\": [\n            \"answer-nasotracheal-intubation-tube-size-6-to-6-5\",\n            \"answer-nasotracheal-intubation-tube-size-7-to-7-5\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus1\",\n            \"answer-nasotracheal-intubation-tube-size-age-div-4+4-minus0-5\",\n            \"answer-nasotracheal-intubation-tube-size-0-5-1cm-less-than-oro-size\",\n            \"answer-nasotracheal-intubation-tube-size-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-nasal-cannula-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-nasal-cannula-flow-rate-1-6-lpm\",\n            \"answer-nasal-cannula-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-nasal-cannula-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-nasal-cannula\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-nasal-cannula-target-saturation-gt-90-pct\",\n            \"answer-nasal-cannula-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-non-rebreather-mask-flow-rate\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What oxygen flow rate would you administer?\",\n        \"abbrLabel\": \"Oxygen flow rate?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-flow-rate-10-15-liters-min\",\n            \"answer-non-rebreather-mask-flow-rate-other\"\n        ]\n    },{\n        \"id\": \"prompt-non-rebreather-mask-target-saturation\",\n        \"interventionID\": \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-non-rebreather-mask-target-saturation-gt-90-pct\",\n            \"answer-non-rebreather-mask-target-saturation-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-bvm-ventilation-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what rate will you ventilate the patient?\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n            \"answer-bvm-ventilation-rate-10-12-bpm\",\n            \"answer-bvm-ventilation-rate-other\",\n        ]\n    }, {\n        \"id\": \"prompt-bvm-flow-rate\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What flow rate would you administer?\",\n        \"abbrLabel\": \"Flow rate?\",\n        \"answers\": [\n            \"answer-bvm-flow-rate-15-ltm-or-gt\",\n            \"answer-bvm-flow-rate-other\",\n        ]\n    },{\n        \"id\": \"prompt-bvm-target-saturation\",\n        \"interventionID\": \"intv-ventilation-technique-bag-valve-mask\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What is your target oxygen saturation range?\",\n        \"abbrLabel\": \"Target O2 saturation?\",\n        \"answers\": [\n            \"answer-bvm-target-saturation-rate-gt-90-pct\",\n            \"answer-bvm-target-saturation-rate-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-tourniquet-placement-close-to-core-far-from-wound\",\n            \"answer-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-2nd-tourniquet-placement\",\n        \"interventionID\": \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Where would you place the second tourniquet?\",\n        \"abbrLabel\": \"Tourniquet location?\",\n        \"answers\": [\n            \"answer-2nd-tourniquet-placement-adjacent-to-initial-tourniquet\",\n            \"answer-2nd-tourniquet-placement-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-occlusive-dressing-injury-type\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-occulsivive-dressing-injury-type-open-pneumothorax\",\n            \"answer-occulsivive-dressing-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-occlusive-dressing-method\",\n        \"interventionID\": \"intv-occlusive-dressing\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How would you create a release valve on an occlusive dressing?\",\n        \"abbrLabel\": \"How would you create a release valve?\",\n        \"answers\": [\n            \"answer-occulsive-dressing-method-leave-one-side-untaped\",\n            \"answer-occulsive-dressing-method-leave-dressing-with-one-way-valve\",\n            \"answer-occulsive-dressing-method-other\"\n        ]\n    },\n\n\n    {\n        \"id\": \"prompt-pleural-decompression-injury-type\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of injury are you trying to manage?\",\n        \"abbrLabel\": \"For what type of injury?\",\n        \"answers\": [\n            \"answer-pleural-decompression-injury-type-tension-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-open-pneumothorax\",\n            \"answer-pleural-decompression-injury-type-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-side-of-the-body\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"On which side of the body would you place the needle?\",\n        \"abbrLabel\": \"Which side would you place the needle?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-right\",\n            \"answer-pleural-decompression-needle-placement-side-of-the-body-left\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-placement-anatomical-landmark\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"At what anatomical landmark?\",\n        \"abbrLabel\": \"At what anatomical landmark?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-2nd-or-3rd-intercostal-space-mid-clavicular\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-4th-or-5th-intercostal-space-mid-axillary\",\n            \"answer-pleural-decompression-needle-placement-anatomical-landmark-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-size\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What size needle do you want to use?\",\n        \"abbrLabel\": \"Needle size?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-size-large-bore\",\n            \"answer-pleural-decompression-needle-size-other\"\n        ]\n    },{\n        \"id\": \"prompt-pleural-decompression-needle-length\",\n        \"interventionID\": \"intv-pleural-decompression\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"How long a needle would you use?\",\n        \"abbrLabel\": \"Needle length?\",\n        \"answers\": [\n            \"answer-pleural-decompression-needle-length-2-inches-or-longer\",\n            \"answer-pleural-decompression-needle-length-other\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-transport-facility-choice\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of care facility will you transport the patient to?\",\n        \"abbrLabel\": \"Type of receiving facility\",\n        \"answers\": [\n            \"answer-transport-facility-choice-level-1-or-2-trauma-center\",\n            \"answer-transport-facility-choice-level-3-or-4-trauma-center\",\n            \"answer-transport-facility-choice-closest\",\n            \"answer-transport-facility-choice-other\"\n        ]\n    },{\n        \"id\": \"prompt-transport-method\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you transport this patient by air or ground ambulance?\",\n        \"abbrLabel\": \"Air or ground ambulance?\",\n        \"answers\": [\n            \"answer-transport-method-ambulance\",\n            \"answer-transport-method-helicopter\"\n        ]\n    },{\n        \"id\": \"prompt-transport-lights-siren-decision\",\n        \"interventionID\": \"intv-transport\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"Would you use lights and sirens with this patient?\",\n        \"abbrLabel\": \"Lights and sirens?\",\n        \"answers\": [\n            \"answer-transport-lights-sirens-yes\",\n            \"answer-transport-lights-sirens-no\"\n        ]\n    },\n\n    {\n        \"id\": \"prompt-splint-type\",\n        \"interventionID\": \"intv-splint-fractures\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"What type of splint would you use?\",\n        \"abbrLabel\": \"Type of splint?\",\n        \"answers\": [\n            \"answer-splint-type-board\",\n            \"answer-splint-type-moldable\",\n            \"answer-splint-type-traction\",\n            \"answer-splint-type-pelvic-binder\",\n            \"answer-splint-type-other\"\n        ]\n    },\n\n]\n/*\n    {\n        \"id\": \"\",\n        \"interventionID\": \"\",\n        \"type\": MDB_TYPES.PROMPT,\n        \"selectionType\": ST.ONE,\n        \"label\": \"\",\n        \"abbrLabel\": \"\",\n        \"answers\": [\n        ]\n    },\n*/\nexport default INTV_PROMPTS","const INTV_MENU_ITEMS = [\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-als\",\n        \"label\": \"ALS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-amputation\",\n        \"label\": \"Manage amputation\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-bls\",\n        \"label\": \"BLS\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-crico\",\n        \"label\": \"Cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-establish-patency\",\n        \"label\": \"Establish patency\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-insert-adjunct\",\n        \"label\": \"Insert adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-intubation\",\n        \"label\": \"Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-internal-bleeding\",\n        \"label\": \"Manage suspected internal bleeding\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-manage-shock\",\n        \"label\": \"Manage hemorrhagic shock\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-medication-facilitated-intubation\",\n        \"label\": \"Medication Facilitated Intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"heading\",\n        \"id\": \"heading-open-airway\",\n        \"label\": \"Open airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"heading\",\n        \"id\": \"heading-remove-foreign-body-obstructions\",\n        \"label\": \"Remove foreign body obstructions\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n         \"depth\": 1,\n         \"type\": \"heading\",\n         \"id\": \"heading-severe-external-bleeding\",\n         \"label\": \"Manage severe external bleeding\",\n         intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transfer\",\n        \"label\": \"Transfer patient to EMS vehicle\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"heading\",\n        \"id\": \"heading-transport\",\n        \"label\": \"Transport to care facility\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-advanced-airway-adjunct\",\n        interventionID: \"intv-advanced-airway-adjunct\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-airway-patency-technique-suction-airway\",\n        interventionID: \"intv-airway-patency-technique-suction-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-apply-sterile-dressings\",\n        interventionID: \"intv-apply-sterile-dressings\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-back-blows-and-chest-thrusts\",\n        interventionID: \"intv-back-blows-and-chest-thrusts\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-direct-pressure\",\n        interventionID: \"intv-control-severe-bleeding-technique-direct-pressure\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-2nd-tourniquet\",\n        interventionID: \"intv-control-severe-bleeding-technique-2nd-tourniquet\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        interventionID: \"intv-control-severe-bleeding-technique-pack-wound-with-gauze\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-pressure-bandage\",\n        interventionID: \"intv-control-severe-bleeding-technique-pressure-bandage\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-severe-bleeding-technique-load-and-go\",\n        interventionID: \"intv-control-severe-bleeding-technique-load-and-go\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-keep-patient-warm\",\n        interventionID: \"intv-control-shock-technique-keep-patient-warm\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-high-concentration-o2\",\n        interventionID: \"intv-control-shock-technique-administer-high-concentration-o2\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-place-patient-supine-position\",\n        interventionID: \"intv-control-shock-technique-place-patient-supine-position\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-control-shock-technique-administer-iv-boluses\",\n        interventionID: \"intv-control-shock-technique-administer-iv-boluses\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-heimlich-maneuver\",\n        interventionID: \"intv-heimlich-maneuver\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-keep-body-part-cool\",\n        interventionID: \"intv-keep-body-part-cool\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-magill-forceps-assisted\",\n        interventionID: \"intv-magill-forceps-assisted\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-manual-finger-sweep\",\n        interventionID: \"intv-manual-finger-sweep\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasopharyngeal-airway\",\n        interventionID: \"intv-nasopharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        interventionID: \"intv-nasotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-needle-cricothyrotomy\",\n        interventionID: \"intv-needle-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-occlusive-dressing\",\n        interventionID: \"intv-occlusive-dressing\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-head-tilt\",\n        interventionID: \"intv-open-airway-method-head-tilt\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-open-airway-method-modified-jaw-thrust\",\n        interventionID: \"intv-open-airway-method-modified-jaw-thrust\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-oropharyngeal-airway\",\n        interventionID: \"intv-oropharyngeal-airway\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-orotracheal-intubation\",\n        interventionID: \"intv-orotracheal-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-body-part-in-bag\",\n        interventionID: \"intv-place-body-part-in-bag\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-place-immobilized-patient-on-stretcher\",\n        interventionID: \"intv-place-immobilized-patient-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-pleural-decompression\",\n        interventionID: \"intv-pleural-decompression\",\n        intvCategoryID: \"intv-cat-manage-thoracic-trauma\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-pain-nausea-vomiting-medications\",\n        interventionID: \"intv-prepare-and-administer-pain-nausea-vomiting-medications\",\n        intvCategoryID: \"intv-cat-manage-pain-nausea-vomiting\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-prepare-and-administer-sedative\",\n        interventionID: \"intv-prepare-and-administer-sedative\",\n        intvCategoryID: \"intv-cat-sedate-agitated-or-combatitive-patient\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        interventionID: \"intv-rapid-sequence-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-retrieve-amputated-body-part\",\n        interventionID: \"intv-retrieve-amputated-body-part\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sedation-assisted-intubation\",\n        interventionID: \"intv-sedation-assisted-intubation\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 4,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-slat\",\n        interventionID: \"intv-slat\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-attach-cid\",\n        interventionID: \"intv-spinal-immobilization-technique-attach-cid\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-cervical-collar\",\n        interventionID: \"intv-spinal-immobilization-technique-cervical-collar\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-manual-c-spine-stabilization\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-manual-c-spine2\",\n        interventionID: \"intv-spinal-immobilization-technique-manual-c-spine\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-spinal-immobilization-technique-transfer-to-device\",\n        interventionID: \"intv-spinal-immobilization-technique-transfer-to-device\",\n        intvCategoryID: \"intv-cat-spinal-motion-restriction\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-circulation-management\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-splint-fractures2\",\n        interventionID: \"intv-splint-fractures\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-sterile-dressing-soft-tissue\",\n        interventionID: \"intv-sterile-dressing-soft-tissue\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-nasal-cannula\",\n        interventionID: \"intv-supplemental-oxygen-device-nasal-cannula\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-supplemental-oxygen-device-non-rebreather-mask\",\n        interventionID: \"intv-supplemental-oxygen-device-non-rebreather-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 3,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-surgical-cricothyrotomy\",\n        interventionID: \"intv-surgical-cricothyrotomy\",\n        intvCategoryID: \"intv-cat-airway\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-walk-patient\",\n        interventionID: \"intv-transfers-patient-method-walk-patient\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transfers-patient-method-place-directly-on-stretcher\",\n        interventionID: \"intv-transfers-patient-method-place-directly-on-stretcher\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport\",\n        interventionID: \"intv-transport\",\n        intvCategoryID: \"intv-cat-extrication-and-transport\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-transport-body-part-to-receiving-facility\",\n        interventionID: \"intv-transport-body-part-to-receiving-facility\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    },\n    {\n        \"depth\": 1,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-ventilation-technique-bag-valve-mask\",\n        interventionID: \"intv-ventilation-technique-bag-valve-mask\",\n        intvCategoryID: \"intv-cat-manage-oxygenation-and-ventilation\"\n    },\n    {\n        \"depth\": 2,\n        \"type\": \"intervention\",\n        \"id\": \"menu-item-wrap-body-part-in-saline-soaked-gauze\",\n        interventionID: \"intv-wrap-body-part-in-saline-soaked-gauze\",\n        intvCategoryID: \"intv-cat-manage-wounds-and-specific-injuries\"\n    }\n]\n\nexport default INTV_MENU_ITEMS","import { useEffect, useState } from \"react\"\n\nimport { Link } from \"react-router-dom\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLogs } from \"@meddbriefer/scenario-data/index\"\n\nimport { Table } from \"reactstrap\"\nconst LogList = () => {\n    const [logs, setLogs] = useState([])\n    const [logsLoaded, setLogsLoaded] = useState(false)\n\n    useEffect(\n        () => {\n            getLogs(db)\n            .then(result => {\n                setLogs(result)\n                // console.log(result)\n                setLogsLoaded(true)\n            })\n            .catch(error => console.log('error fetching logs', error))\n        },\n        []\n    )\n\n    if (!logsLoaded) {\n        return (<h4>fetching log data</h4>)\n    }\n    return (\n        <Table striped={true} borderless size=\"sm\" hover>\n            <thead>\n                <tr>\n                    <th>Label</th>\n                    <th>Scenario</th>\n                    <th>Username</th>\n                    <th>Timestamp</th>\n                </tr>\n            </thead>\n            <tbody>\n                {logs.map(log => (\n                    <tr key={log.id}>\n                        <td>{log.label}</td>\n                        <td>{log.scenario}</td>\n                        <td>{log.userName}</td>\n                        <td>{log.timestamp}</td>\n                        <td>\n                            <Link to={`/logs/${log.id}`}>Analyze</Link>&nbsp;&nbsp;&nbsp;&nbsp;\n                            <Link to={`/debriefing-feedback-logs/${log.id}`}>Review</Link>\n                        </td>\n                    </tr>\n                ))}\n            </tbody>\n        </Table>\n    )\n\n}\n\nexport default LogList","\n\n  export const colorTypes = {\n    \"Good\": \"text-success\",\n    \"Caution\": \"text-warning\",\n    \"Problem\": \"text-danger\",\n    \"Not implemented\": \"text-muted\"\n}\n\nexport const iconTypes = {\n    \"Good\": \"sentiment_satisfied\",\n    \"Caution\": \"report_problem\",\n    \"Problem\": \"highlight_off\",\n    \"Not implemented\": \"sentiment_neutral\"\n}\n\n//Feedback substitute commands for feedback template\n//@ means substitute this entry field into the feedback template and if no value in field say this in feedback, \n//? means substitute this entry field into the feedback template if the value exists,\n//+bos adds period to end sentence, two spaces and capitalizes first letter of what follows\n//+eos adds a period with no preceding spaces\n\n//assessmentEntries states are used by analyzeEvents, condition1 and condition2, but the rest is used only by condition 1\nexport const assessmentEntries = {\n    // state: [categorization for feedback, feedback template for condition 1]\n    \"contraindicated\": [\"Problem\", \"You should not have done this action because it is contraindicated in this case +bos ?contraindicatedWhy +bos ?why +eos\"],\n    \"irrelevant\": [\"Problem\", \"You should not have done this action because it is irrelevant in this case +bos ?why +eos\"],\n    \"unnecessary\": [\"Problem\", \"You should not have done this action because it is unnecessary in this case +bos ?why +eos\"],\n    \"missingMinimal\": [\"Problem\", \"You did not do this action +bos ?why +eos\"],\n    \"missingOptional\": [\"Caution\", \"You did not do this action +bos but it was optional in this case +bos ?why +eos\"],\n    \"missingRequired\": [\"Problem\", \"You did not do this action +bos ?why +eos\"],\n    \"missingRequiredAssessment\": [\"Problem\", \"You did not do this action +bos ?assessmentFB +eos\"],\n    \"notNecessary\": [\"Caution\", \"You should not have done this action because it was unnecessary +bos ?why +eos\"],  //applies only to assessment items\n\n    //note that missing/wrong items cannot be an argument in a misordering of events so there states will not get combined with misOrdered states\n\n    //not yet implemented\n   // \"missedProblem\": [\"Problem\", \"The following should alert you to @problem: +items @problemAssessments\"],  //need to add status and fields to analysis code still and +item formatting below\n \n    \"assessment\": [\"Good\", \"\"],\n    \"assessment-option\": [\"Good\", \"\"],\n    \"decision-option\": [\"Good\", \"\"],\n    \"required-action\": [\"Good\", \"\"],\n    \"goodIntv\": [\"Good\", \"?intvStatusFB +eos \"],\n    \n\n    \"misOrdered-assessment\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-assessment-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-decision-option\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-required-action\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n    \"misOrdered-goodIntv\": [\"Problem\", \"Doing this action was correct but it was done out of the recommeded order +bos @orderingFB\"],\n\n    \"misOrdered-phase-assessment\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-assessment-option\": [\"Good\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +eos\"],\n    \"misOrdered-phase-decision-option\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n    \"misOrdered-phase-required-action\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n    \"misOrdered-phase-goodintv\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB\"],\n\n    //doubt that status checks can be misordered\n    \"intvCheckWNoIntvFound\": [\"Caution\", \"You didn't do this intervention so it doesn't make sense to check the status of it at this point.\"],\n    \"unexpectedPatientIntvCheck\": [\"Caution\", \"This status check is not likely to reveal any useful information.\"],  //nothing indicates a need to check that this intv worked\n    \"patientIntvCheck\": [\"Good\", \"\"], //as long as the intervention was done it is fine to request it\n    \"patientVitalCheck\": [\"Good\", \"\"],  //currently any patient vital check that is done is fine\n\n\n    \"assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],  \n    \"incorrect-answers\": [\"Problem\", \"Doing this action is correct but there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal-incorrect-answers\": [\"Problem\", \"Doing this action was correct and would solve the problem but you did not follow protocol +bos ?minimalWhy +bos also there is a problem with how you planned to do this intervention +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"minimal\": [\"Caution\", \"Doing this action is correct and solves the problem but you did not follow protocol +bos @minimalWhy +bos ?intvStatusFB +eos \"],\n\n   \n    \"misOrdered-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but it was done out of the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos @minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-minimal\": [\"Problem\", \"Doing this action is correct but it was done out of the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos @minimalWhy +bos ?intvStatusFB +eos\"],\n        \n    \n    \"misOrdered-phase-assessment-option-incorrect\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-decision-option-incorrect\": [\"Problem\", \"Doing this action was correct but this section was not completed in the recommended order +bos @orderingFB +bos Also there is a problem with how you planned to do it +bos @incorrectAnswerFB +eos \"],\n    \"misOrdered-phase-incorrect-answers\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal-incorrect-answers\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos ?minimalWhy +bos also there is a problem with how you planned to do it +bos @incorrectAnswersFB +bos ?intvStatusFB +eos\"],\n    \"misOrdered-phase-minimal\": [\"Problem\", \"Doing this action is correct but this section was not completed in the recommended order +bos @orderingFB +bos And while this would solve the problem, you did not follow protocol +bos ?minimalWhy +bos ?intvStatusFB +eos\"],\n    \n    \"green\": [\"Good\", \"\"],  //just for headers\n    \"red\": [\"Problem\", \"\"], //just for headers\n    \"yellow\": [\"Caution\", \"\"], //just for headers\n    //\"notFound\": [\"Not implemented\", \"Assessment knowledge is not yet specified\", []],\n    \"default\": [\"Not implemented\", \"This action was not expected.  There could be an issue with how this scenario is represented within the system.\"]\n}\n","export const phaseStatusList = {\n    absent: [\"absent\", \"missingMinimal\", \"missingRequired\", \"missingRequiredAssessment\"],\n    errors: [\"misOrdered-assessment\", \"misOrdered-assessment-option\", \"misOrdered-decision-option\", \"misOrdered-required-action\", \"misOrdered-goodIntv\",\n    \"assessment-option-incorrect\", \"decision-option-incorrect\", \"incorrect-answers\", \"minimal-incorrect-answers\", //\"minimal\", \n    \"misOrdered-assessment-option-incorrect\", \"misOrdered-decision-option-incorrect\", \"misOrdered-incorrect-answers\", \"misOrdered-minimal-incorrect-answers\",\n    \"misOrdered-minimal\", \n    \"misOrdered-phase-assessment-option-incorrect\", \"misOrdered-phase-decision-option-incorrect\", \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\",\n        ],\n    good: [\"good\", \"assessment\", \"assessment-option\", \"decision-option\", \"required-action\", \"goodIntv\", \n        //condition 2 does not address these so put them in the good category\n        \"patientIntvCheck\", \"patientVitalCheck\", \"irrelevant\", \"unnecessary\", \"contraindicated\", \"notNecessary\",\n        \"intvCheckWNoIntvFound\", \"unexpectedPatientIntvCheck\",  \"default\",\n        //condition 2 does not need to address minimal as an error nor misordered-phase as that error appears as misordered at the phase or subphase level\n        //condition 1 uses misOrdered-Phase as that error feedback goes on the first line in the phase/subphase\n        //so without misOrdered-phase and/or minimal, these are good status values\n        \"minimal\", \"misOrdered-phase-minimal\",\n        \"misOrdered-phase-assessment\", \"misOrdered-phase-assessment-option\", \"misOrdered-phase-decision-option\", \"misOrdered-phase-required-action\", \"misOrdered-phase-goodIntv\",\n        ]  \n}\n\nexport const leafStatusList = {\n    absent: [\"missingMinimal\", \"missingRequired\", \"missingRequiredAssessment\"],\n    misordered: [\"misOrdered-assessment\", \"misOrdered-assessment-option\", \"misOrdered-decision-option\", \"misOrdered-required-action\", \"misOrdered-goodIntv\", \"misOrdered-minimal\"],\n    misorderedErrors: [\"misOrdered-assessment-option-incorrect\", \"misOrdered-decision-option-incorrect\", \"misOrdered-incorrect-answers\", \"misOrdered-minimal-incorrect-answers\",\n    \"misOrdered-phase-assessment-option-incorrect\", \"misOrdered-phase-decision-option-incorrect\", \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\"],\n    errors: [\"assessment-option-incorrect\", \"decision-option-incorrect\", \"incorrect-answers\", \"minimal-incorrect-answers\"],\n    good: [\"assessment\", \"assessment-option\", \"decision-option\", \"required-action\", \"goodIntv\", \n        //condition 2 does not address these so put them in the good category\n        \"patientIntvCheck\", \"patientVitalCheck\", \"irrelevant\", \"unnecessary\", \"contraindicated\", \"notNecessary\",\n        \"intvCheckWNoIntvFound\", \"unexpectedPatientIntvCheck\",  \"default\",\n        //condition 2 does not need to address minimal as an error nor misordered-phase as that error appears as misordered at the phase or subphase level\n        //condition 1 uses misOrdered-Phase as that error feedback goes on the first line in the phase/subphase\n        //so without misOrdered-phase and/or minimal, these are good status values\n        \"minimal\", \"misOrdered-phase-minimal\",\n        \"misOrdered-phase-assessment\", \"misOrdered-phase-assessment-option\", \"misOrdered-phase-decision-option\", \"misOrdered-phase-required-action\", \"misOrdered-phase-goodIntv\",\n        ]  \n}\n","// defines which assessment steps are not required per scenario.  Provides feedback on\n// why the step is not required.\nexport const exceptionDefs = \n[{scenarioName: \"M2CA\", exceptions: [\n    [\"required-action-obtain-OPQRST\", \"This cannot be assessed when GCS < 15\"],\n    [\"assess-opqrst-info\", \"This cannot be assessed when GCS < 15\"]\n    ]}\n  ]\n  \n/* This starts section on defining temporal constraints, conditional constraints and implications.*/\n\n/*temporal constraints are an\nindex of event labels with two lists as values.\nThe first value is a list of event labels that the indexed event\nshould precede (if any) and the second value is a list of event\nlabels that the indexed event should follow after (if any)\n*/\n\nexport const globalConstraints = {\n    // event < list of other events, > list of other events\n    // lookup by event id to see the list of event ids that it should go before\n    // and after, and the type of constraint. \n    // included constraints type with values of policy, commonSense and both.  These may be used in future to\n    // decide any lead in to feedback about a constraint violation\n    // type policy operators are usually \"ands\", type commonsense operators are ususally \"ors\" because\n    // the ordering is looser than with policy ordering.  An operator can be blank if only one item is listed for the\n    // before or for the after.  No software should be written to expect\n    // this tendency between type and operators to hold.\n\n    //Note that: \n    //- for now the software will use either the label or id to lookup constraints but id\n    // is preferred.\n    //- a key (first item on each line) is the first arg in the constraints and is\n    //  assumed to have just one constraint applicable to\n    //  it but may appear as the second arg in a constraint multiple times (2nd args are\n    //  lists under before or after fields)\n    //- when something is a phase or subphase with multiple actions then we look for the begining\n    //  and ending actions for constraint checking.  If overlap in phases is to be allowed the constraint should\n    //  be amongst lower level items and no higher level constraint should be included\n    //= there is no check to make sure the constraints expressed do not conflict.  For example,\n    //  saying a whole phase should be before another phase and that a particular item in the second\n    //  phase can go before some other item in the first phase are in conflict with one another\n\n\n    // Note: looks like I may need to allow multiple constraints to be listed under an arg1 key.  Shouldn't be\n    // difficult to do but waiting to see if it is truly necessary first.  While most constraints for arg1 could\n    // be combined in the list below, there is an issue with adding in scenario specific conditional constraints\n    // that are expressed in a different structure.\n\n    //\"\": {id: \"T\", before: [\"\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \n    // T1\n    \"scene-size-up\": {id: \"T1\", before: [\"primary-survey\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T2\n    \"primary-survey\": {id: \"T2a\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    //listing the below any intervention that I think are always going to address a life threat\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"T2b\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {id: \"T2c\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {id: \"T2d\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T3\n    \"ints-call-for-helicopter\": {id: \"T3\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T4\n    \"required-action-obtains-vitals\": {id: \"T4\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T5\n    \"required-action-attempt-obtain-sample\": {id: \"T5a\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"required-action-obtain-OPQRST\": {id: \"T5b\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T6 is in scenario specific constraints\n    // T7\n    \"intv-transfer\": {id: \"T7\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\", \"breathing\", \"circulation\"], afterOp: \"\", type: \"policy\"},\n    // T8\n    \"trauma-expose\": {id: \"T8\", before: [\"chest\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T9\n    \"general-impression\": {id: \"T9\", before: [\"airway\", \"breathing\", \"circulation\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"},\n    // T10\n    \"intv-spinal-immobilization-technique-manual-c-spine\": {id: \"T10a\", before: [\"airway\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-spinal-immobilization-technique-cervical-collar\": {id: \"T10b\", before: [\"airway\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T11 was deleted per discussion with Sandy\n    // T12 is in scenario specific constraints\n    // T13\n    \"intv-airway-patency-technique-suction-airway\": {id: \"T13\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [\"airway\"], afterOp: \"\", type: \"policy\"},\n    // T14\n    \"intv-airway-patency-technique-suction-airway\": {id: \"T14\", before: [\"intv-oropharyngeal-airway\", \"intv-nasopharyngeal-airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T15\n    \"intv-oropharyngeal-airway\": {id: \"T15a\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \n                                  \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-nasopharyngeal-airway\": {id: \"T15b\", before: [\"intv-nasotracheal-intubation\", \"intv-orotracheal-intubation\", \"intv-sedation-assisted-intubation\", \n                                  \"intv-rapid-sequence-intubation\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"},\n    // T16 awaiting observer interface implementation decisions on how contacting medical command will be recorded\n    // T17\n    \"intv-ventilation-technique-bag-valve-mask\": {id: \"T17\", before: [\"secondary-assessment\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    // T18 and T19 are constraints involving intervention checks and need to be discussed in a group meeting\n    \n    //used during testing\n    //state that ongoing management plan should go after the entirety of everything listed in after\n    //\"ongoing-mgmt-plan\": {id: \"c2\", before: [ ], beforeOp: \"\", after: [\"bsi\", \"scene-size-up\", \"primary-survey\", \"history-taking\",\"secondary-assessment\"], afterOp: \"and\", type: \"commonSense\"},\n    // have two second args in below because some of Observer logs have one of these ids and some have the other\n    //\"assess-injury-mechanism\": {id: \"c7\", before: [\"required-action-consider-stabilization-of-spine\", \"required-action-considers-stabilize-spine\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"commonSense\"},\n    //\"intv-control-severe-bleeding-technique-direct-pressure\": {id: \"c8\", before: [\"intv-control-severe-bleeding-technique-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n    //\"intv-control-severe-bleeding-technique-tourniquet\": {id: \"c9\", before: [\"intv-control-severe-bleeding-technique-2nd-tourniquet\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"both\"},\n     \n}\n\n//constraints that depend on whether certain conditions hold within a scenario\n//based on the scenario and the constraint ids listed under the scenario in\n//scenarioConstraintIDs, the constaints defined here with the ids for the current\n//scenario will be added to the general constraints about for temporal constraint testing\n\n// Used convention of appended -c and a one up number just to indicate it is a conditional constraint.  No software\n// requires this convention for the ids so it can be changed\n\nexport const conditionalConstraints = {\n    // first is a hold over from testing for M2CA\n    \"assess-major-bleeding\": {id: \"c1\", before: [\"airway\",\"breathing\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"intv-transport\" : {id: \"T2-c1\", before: [\"into-establish-IV\", \"intv-control-shock-technique-administer-iv-boluses\"], beforeOp: \"and\", after: [], afterOp: \"\", type: \"policy\"}, \n    \"secondary-assessment\": {id: \"T6-c1\", before: [\"intv-transfer\", \"ongoing-mgmt-plan\"], beforeOp: \"\", after: [], afterOp: \"\", type: \"policy\"},\n    \"pulse-checks\": {id: \"T12-c1\", before: [\"airway\"], beforeOp: \"or\", after: [], afterOp: \"\", type: \"policy\"}\n    \n    \n}\n\n\n// used to simulate conditional constraints, i.e. we hardcode which conditional constraint ids as\n// defined under conditionalConstraints (above) are relevant to each scenario\n\n// although one could put global constraint ids under scenarios here, it would be redundant and may cause software\n// issues\nexport const scenarioConstraintIDs = {\n    \"M2CA\": [\"c1\", \"T6-c1\"],\n    \"B4CA\": [],\n    \"B7CA\": [],\n    \"SC8CP\": [\"T2-c1\",\"T6-c1\", \"T12-c1\"],\n    //\"\": [],\n    //\"\": []\n}\n\n\n//below are examples of interventions in which status should be checked.  The key intvStatusNeeded\n//is true or false.  If true it means should have requested status of this intervention.  If vitals key is\n//not empty then should have checked all of these vitals as well.  Will only check entries after an intervention\n//up until something other than an intervention check is done\n\n//updates wrt SC8CP-combined-goals-4-4\nexport const intvChecks = {\n    \"intv-nasopharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-oropharyngeal-airway\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-orotracheal-intubation\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-ventilation-technique-bag-valve-mask\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\" ]},\n    \"intv-sedation-assisted-intubation\": {intvStatusNeeded: false, vitalsNeeded: [\"R\", \"Spo2\", \"BP\", \"Skin\"]},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},  \n    //\"\": {intvStatusNeeded: true, vitalsNeeded: []},\n    //test cases for now.  First 3 are likely to become relevant for scenarios like M2CA\n    \"intv-control-severe-bleeding-technique-direct-pressure\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []},\n    \"intv-control-severe-bleeding-technique-2nd-tourniquet\": {intvStatusNeeded: true, vitalsNeeded: []}, \n    //\"intv-control-shock-technique-administer-iv-boluses\": {intvStatusNeeded: false, vitalsNeeded: [\"BP\"]},\n        \n    }\n\n","/* Bogus data for testing Collin's algorithm\nI made the scenario M2CA since that scenario has some corresponding log analysis files that can be used\nfor testing\nIds need to be added to correspond to those in the analysis log*/\n\nexport const M2CA_PhaseIE = {\n    Action: {\n      id: \"top\",\n      label: \"Top most node -level 0\",\n      feedbackAbsent: \"Nothing done. Start scenario again.\", /*feedback if the action was not performed*/\n      feedbackOutOfOrder: \"\", /*feedback if the action was done late (e.g., if the action is Scene Size-up \n        and it was done after Primary Survey)*/\n      feedbackError: \"All wrong. Please start scenario again.\", /*feedback if the action was performed incorrectly (e.g. wrong Ventilation rate)*/\n      subActions: [ /*array with the corresponding subactions (to form the tree)*/\n        {\n          id: \"scene-size-up\",\n          label: \"Child1 -level1\",\n          feedbackAbsent: \"absent -Child1 level 1\",\n          feedbackOutOfOrder: \"late -Child1 level 1\",\n          feedbackErrors: \"wrong -Child1 level 1\",\n          subActions: [\n            {\n                id: \"assess-scene-safety\",\n                label: \"Child1 of Child1 -level 2\",\n                feedbackAbsent: \"absent -Child1 of Child1 -level2\",\n                feedbackOutOfOrder: \"late -Child1 of Child1 -level2\",\n                feedbackErrors: \"wrong -Child1 of Child1 -level2\",\n                subActions: [],\n                examine: \"N\",\n                prompts: \"\",\n              },\n              {\n                id: \"required-action-BSI\",\n                label: \"Child2 of Child1 -level 2\",\n                feedbackAbsent: \"absent -Child2 of Child1 -level 2\",\n                feedbackOutOfOrder: \"late -Child2 of Child1 -level 2\",\n                feedbackErrors: \"wrong -Child2 of Child1 -level 2\",\n                subActions: [],\n                examine: \"Y\",\n                prompts: \"prompts -Child2 of Child1 -level2\",\n              },\n          ],\n          examine: \"Y\",\n          prompts: \"prompts -Child1 level 1\",\n        },\n        {\n          id: \"primary-survey\",\n          label: \"Child 2 -level1\",\n          feedbackAbsent: \"absent -Child 2 level1\",\n          feedbackOutOfOrder: \"late -Child 2 level1\",\n          feedbackErrors: \"wrong -Child 2 level1\",\n          subActions: [\n            {\n                id: \"general-impression\",\n                label: \"Child1 of Child2 -level2\",\n                feedbackAbsent: \"absent -Child1 of Child2 -level2\",\n                feedbackOutOfOrder: \"late -Child1 of Child2 -level2\",\n                feedbackErrors: \"wrong -Child1 of Child2 -level2\",\n                subActions: [],\n                examine: \"N\",\n                prompts: \"\",\n              },\n              {\n                id: \"airway\",\n                label: \"Child2 of child2 -level2\",\n                feedbackAbsent: \"absent -Child2 of Child2 -level2\",\n                feedbackOutOfOrder: \"late -Child2 of Child2 -level2\",\n                feedbackErrors: \"wrong -Child2 of Child2 -level2\",\n                subActions: [\n                    {\n                        id: \"airway-is-open\",\n                        label: \"Child1 of (Child2 of Child2) -level3\",\n                        feedbackAbsent: \"absent -Child1 of (Child2 of Child2) -level3\",\n                        feedbackOutOfOrder: \"late -Child1 of (Child2 of Child2) -level3\",\n                        feedbackErrors: \"wrong -Child1 of (Child2 of Child2) -level3\",\n                        subActions: [],\n                        examine: \"N\",\n                        prompts: \"\",\n                      },\n                      {\n                        id: \"airway-is-clear-substances\",\n                        label: \"Child2 of (Child2 of Child2) -level3\",\n                        feedbackAbsent: \"absent -Child2 of (Child2 of Child2) -level3\",\n                        feedbackOutOfOrder: \"late -Child2 of (Child2 of Child2) -level3\",\n                        feedbackErrors: \"wrong -Child2 of (Child2 of Child2) -level3\",\n                        subActions: [],\n                        examine: \"Y\",\n                        prompts: \"prompts -Child2 of (Child2 of Child2) -level3\",\n                      }\n                ],\n                examine: \"N\",\n                prompts: \"\",\n              },\n              {\n                id: \"breathing\",\n                label: \"Child3 of Child2 -level2\",\n                feedbackAbsent: \"absent -Child3 of Child2 -level2\",\n                feedbackOutOfOrder: \"late -Child3 of Child2 -level2\",\n                feedbackErrors: \"wrong -Child3 of Child2 -level2\",\n                subActions: [],\n                examine: \"N\",\n                prompts: \"\",\n              } \n          ],\n          examine: \"N\",\n          prompts: \"\",\n        },\n        {\n          id: \"Manage a potential head and/or spinal injury\",\n          label: \"Child 3 -level1\",\n          feedbackAbsent: \"absent -Child 3 level1\",\n          feedbackOutOfOrder: \"late -Child 3 level1\",\n          feedbackErrors: \"wrong -Child 3 level1\",\n          subActions: [],\n          examine: \"N\",\n          prompts: \"\",\n        },\n        {\n          id: \"ongoing-mgmt-plan\",\n          label: \"Child 4 -level1\",\n          feedbackAbsent: \"absent -Child 4 level1\",\n          feedbackOutOfOrder: \"late -Child 4 level1\",\n          feedbackErrors: \"wrong -Child 4 level1\",\n          subActions: [\n            {\n                id: \"reassess-vital-signs\",\n                label: \"Child1 of Child4 -level 2\",\n                feedbackAbsent: \"absent -Child1 of Child4 -level2\",\n                feedbackOutOfOrder: \"late -Child1 of Child4 -level2\",\n                feedbackErrors: \"wrong -Child1 of Child4 -level2\",\n                subActions: [],\n                examine: \"Y\",\n                prompts: \"prompts -Child1 of Child4 -level2\",\n              },\n              {\n                id: \"repeat-primary-survey\",\n                label: \"Child2 of Child4 -level 2\",\n                feedbackAbsent: \"absent -Child2 of Child4 -level 2\",\n                feedbackOutOfOrder: \"late -Child2 of Child4 -level 2\",\n                feedbackErrors: \"wrong -Child2 of Child4 -level 2\",\n                subActions: [],\n                examine: \"N\",\n                prompts: \"\",\n              },  \n          ],\n          examine: \"Y\",\n          prompts: \"prompts -Child4 level1\",\n        },\n      ],\n      examine: \"N\", /*Boolean that says whether the action needs to be examined*/\n      prompts: \"\" /*prompts to hint the student as to how to reflect on the action*/\n    },\n  }","import { formatAsMinSecs } from \"../utils\"\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport {colorTypes, iconTypes, assessmentEntries, phaseStatusList} from \"@meddbriefer/feedback-data\"\nimport { scenarioConstraintIDs, conditionalConstraints, globalConstraints } from \"@meddbriefer/feedback-data\"\n\n   \nexport const pushNew = (elt,array) => {\n    if (!array.includes(elt)) {\n        array.push(elt)\n    }\n}\n\nexport const getPhaseStatus = (statuses) => {\n    //for collecting first unique item statuses and then\n    //unique phase statuses\n    let itemStatuses = []\n    let phaseStatuses = []\n\n    //get a unique list of item status values\n    statuses.forEach(status => {\n        pushNew(status,itemStatuses)\n        /* if (!itemStatuses.includes(status)){\n            itemStatuses.push(status)\n        } */\n    })\n    \n    //turn the item status values into phase level status values\n    let res\n    for (const [key, val] of Object.entries(phaseStatusList)) {\n        res = val.filter(value => itemStatuses.includes(value))\n        //if there is an intersection, save the key (i.e. is unique)\n        if (res.length !== 0)\n            pushNew(key,phaseStatuses)\n            /* if (!phaseStatuses.includes(key)){\n                phaseStatuses.push(key)} */\n        }\n\n    if (phaseStatuses.length === 1){return phaseStatuses[0]}  // to be absent or good, all entries must be good or absent\n    else {return \"errors\"}  //otherwise they are not all good to that translates to errors\n       \n    }\n\n\n\n// functions that extract info from above or create the feedback from the above \n\n//returns a list of all the state values associated with the input status (e.g. status is one of \"Problem\", \"Good\", \"Caution\")\nexport const getStatesForStatus = (status) => {\n    let stateList = []\n    for (const [state, entry] of Object.entries(assessmentEntries)) {\n        let stateStatus = entry[0]\n        if (stateStatus === status){\n            stateList.push(state)}\n        }\n    //console.log(\"In getStatesForStatus\", stateList)\n    return (stateList)}\n        \n\n//returns the entry under that state\nconst getAssessmentEntry = (currentEntry,aIndex) => {\n    let assessmentEntry = \"\"\n    if (currentEntry.type === \"header\"){\n        assessmentEntry = assessmentEntries[currentEntry.displayColor] \n        if (!assessmentEntry) {assessmentEntry = assessmentEntries[currentEntry.status]}\n    }\n    else{\n        if (!assessmentEntries[currentEntry.status]){\n            assessmentEntry = assessmentEntries[\"default\"]}\n        else{assessmentEntry = assessmentEntries[currentEntry.status]}}\n    if (assessmentEntry){\n        return assessmentEntry[aIndex]}\n}\n\n//returns the html icon to use in condition 1 for the state\nexport const getAssessmentIcon = (currentEntry) => {  \n    let val = iconTypes[getAssessmentEntry(currentEntry,0)]\n    return val;\n}\n\n//returns the html color to use in condition 1 for the state\nexport const getColor = (currentEntry) => {\n    return colorTypes[getAssessmentEntry(currentEntry,0)];\n}\n\n//add protexted spaces after a . except for the very last .  \n//Otherwise html reduces continguous regular spaces to a single space.\n//Need this for text strings that will appear in one array entry because\n//of substitution\nconst fixStrSp = (textString) => {\n    if (!!textString){\n        let textArray = textString.split(\" \");\n        let lenTextArray = textArray.length;\n        textArray.forEach((item, i) => {\n            let newItem = item.trim()\n            if (newItem[item.length-1] === \".\" && i < lenTextArray-1){\n                //add protected space to the string\n                newItem = newItem + \"\\xa0\\xa0\"}\n            textArray[i] = newItem \n        })\n        let newString\n        for (let item of textArray){\n            if (!!newString){\n            newString = newString + \" \" + item;}\n            else{newString = item}\n\n     }\n        //console.log(newString, textArray)\n        return newString}\n    else {return \"\"}\n}\n\nconst generateIntvStatusFB = (currentEntry) => {\n    let checked = []\n    let notChecked = []\n    let fb\n    for (let entry of currentEntry.intvStatus){\n        if (entry.foundCk){\n            checked.push(entry.label)}\n        else {notChecked.push(entry.label)}\n    }\n    if (notChecked.length > 0){\n        fb = \"Remember to check the effect of this action by asking for: \" + notChecked + \".\"\n        if (checked.length > 0){\n            fb = fb + \" That is in addition to what you did ask for: \" + checked + \".\"\n        }\n    }\n    return fb\n}\n\nlet fbSource = \"json\"  //values are \"db\" or \"json\"\n\nfunction getFBField(currentEntry, field){\n    let result\n    switch(fbSource){\n        case \"json\":\n            switch(field){\n                case \"assessmentFB\":  //get from c2 ds field feedbackAbsent\n                result = \"[To be retrieved from C2 DS]\" //TBD\n                break\n                case \"incorrectAnswersFB\":  //get from c2 ds field feedbackErrors\n                    result = \"[To be retrieved from C2 DS]\" //TBD\n                    break\n                default:   //have the why and contraindicatedWhy fields from problem structure\n                    if (!!currentEntry[field])\n                    //replace eos spacing with protected spaces in the substitution string\n                    {result = fixStrSp(currentEntry[field]) }  \n            }\n            break\n        default:\n            if (!!currentEntry[field])\n            //replace eos spacing with protected spaces in the substitution string\n            {result = fixStrSp(currentEntry[field]) }\n    }\n    return result\n}\n\n\nexport const getFeedback = (currentEntry) => {\n    if (!!currentEntry.intvStatus && currentEntry.intvStatus.length > 0){\n        //add our generated feedback string to the currentEntry\n        currentEntry.intvStatusFB = generateIntvStatusFB(currentEntry)\n    }\n    let feedbackTemplate = fixStrSp(getAssessmentEntry(currentEntry,1)).trim()\n    let fb\n    //Find any @ actions in the template and substitute with the indicated entry field\n    let feedbackArray = feedbackTemplate.split(\" \");\n    //Process all @ substitutions first since +eos does one forward action\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let newString = item.substring(1)\n        //trim off excess blanks before and after each word\n        feedbackArray[i] = feedbackArray[i].trim()\n        switch(firstChar){\n            case \"@\":\n                fb = getFBField(currentEntry, newString)\n                if (!!fb){\n                    feedbackArray[i] = fb}\n                else {\n                    feedbackArray[i] = \"[missing: \" + newString + \"]\"\n                }\n                break\n            case \"?\":\n                fb = getFBField(currentEntry,newString)\n                if (!!fb)\n                //replace eos spacing with protected spaces in the substitution string\n                    { feedbackArray[i] = fb }\n                else {\n                    feedbackArray[i] = \"\"  \n                    if (feedbackArray[i-1]  === \"+bos\"){\n                        feedbackArray[i-1] = \"\"\n                        if (feedbackArray[i-2][feedbackArray[i-2].length-1] !== \".\"){\n                            feedbackArray[i-2] = feedbackArray[i-2] + \".\\xa0\"}\n                    }\n                    if (feedbackArray[i+1]  === \"+eos\"){feedbackArray[i+1] = \"\"}\n                }\n                break  \n            default:\n        }\n    })\n    //Now address the + actions in the template\n    feedbackArray.forEach((item, i) => {\n        let firstChar = item.charAt(0)\n        let previousString = \"\"\n        switch(firstChar){\n        case \"+\":\n            let afterPlusChar = item.substring(1)\n            switch(afterPlusChar){\n            case \"eos\":\n                //removes existing/redundant . if present so can be certain putting in single . \n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence and a protected space.  When stiched back into\n                //a single string a protected space will be added between each substring\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\"  //get rid of the command since was applied\n                break\n            case \"bos\":\n                //removes existing/redundant . if present so can put in single .\n                previousString = feedbackArray[i-1].trim();\n                if (previousString[previousString.length-1] === \".\"){\n                    previousString = previousString.slice(0,-1);}\n                //now add end of sentence .\n                feedbackArray[i-1] = previousString + \".\\xa0\"\n                feedbackArray[i] = \"\" //get rid of the command since was applied\n                //Captitalize the beginning of the sentence\n                let nextString = feedbackArray[i+1].trim()\n                feedbackArray[i+1] = nextString.charAt(0).toUpperCase() + nextString.slice(1);\n                break\n            default:\n            }\n            break\n        default:\n    }}\n    )\n    //stitch back into a single string\n    let feedbackString\n    for (let item of feedbackArray){\n        if (!!feedbackString) {\n            if (item !== \"\"){\n                feedbackString = feedbackString + \"\\xa0\" + item;}} \n        else {if (item !== \"\"){feedbackString = item}}\n    }\n    //console.log(feedbackString)\n    return feedbackString\n}\n\n//built by the function initializeConstraints\nvar scenarioConstraints = {}\n\n// adds on scenario specific constraints where the constraint is only applicable if certain patient\n// conditions hold.  Since assessment callouts are text and have no associated representation, we\n// can yet implement true conditional constraints.\nexport const initializeConstraints = (scenarioName) => {\n    // look up applicable conditional constraints from const structure scenarioConstraintIDs \n    let constraintIDs = scenarioConstraintIDs[scenarioName] \n    scenarioConstraints = globalConstraints\n    for (const [key, val] of Object.entries(conditionalConstraints)) {\n            if (constraintIDs.includes(val.id)){\n                scenarioConstraints[key] = val\n            }\n        }\n}\n\n\n\n//gets one constraint since each id/label would be a key\n//in the constraints definitions\nexport const getConstraint = (item) => {\n    let id = item.id\n    let label = item.label\n    let constraints = scenarioConstraints[id] \n    if (!constraints){constraints = scenarioConstraints[label]}\n    return constraints \n}\n\n\n// This section is for looking up items in the analysis log\n\nexport const getEvents = (events,field,val) => {\n    return events.filter(entry => entry[field] === val)\n}\n\nexport const getEventsByIdTime = (events,id,timestamp) => {\n    return getEvents(getEvents(events,\"timestamp\",timestamp),\"id\",id)\n}\n\n// This ends the section for looking up items in the analysis log\n\n\n\n//This starts section for saving/loading the debriefing log\n    \nconst _ = require(\"lodash\"); \n\nexport const saveAnalysisLog = (log, actions, hierAssessResults, hierProblemResults, constraintsViolated) => {\n    console.log(\"In savingDebriefingLog\")\n    const docRef = db.collection(\"debriefing-feedback-logs\").doc(log.id)\n    let data = {\n        userName: log.userName,\n        ObserverFileCreater: log.userName,\n        label: log.label,\n        ObserverFileName: log.label,\n        commenter: \"\",\n        scenarioID: log.scenarioID,\n        scenarioName: log.scenarioName,\n        schemaVersion: log.schemaVersion,\n        timestamp: Date().toLocaleString(),\n        hierAssessResults: hierAssessResults,\n        hierProblemResults: hierProblemResults,\n        constraintsViolated: constraintsViolated\n    }\n\n    let newActionsList = [];\n    let newObj = {};\n    let filterUnknown = false;\n\n    //included for debugging puposes only\n    actions.forEach(function (logObj, index){\n        for (let [key, val] of Object.entries(logObj)) {\n            if (undefined === val) {\n                console.log(\"filtered out from events; index: \", index, \" key: \", key, \" value: \", val)\n                filterUnknown = true;}\n             }\n        }\n    )\n        \n    if (filterUnknown) {\n        actions.forEach(function (logObj, index) {\n            newObj = _.pickBy(logObj, function (value, key) {\n                return !(value === undefined);\n            });\n            newActionsList.push(newObj)\n        })\n        data[\"events\"] = newActionsList\n    }\n    else (data[\"events\"] = actions);\n\n\n    //data[\"events\"] = formattedActions;\n    //console.log(JSON.stringify(data, null, 4))\n    docRef.set(data) \n}\n\n//not in use\n\nexport const retrieveDebriefing = (log) => { \n    //console.log(log.events) \n    return (log.events)  \n}  \n\n//This ends section for saving/loading the debriefing log\n\n\n\nexport const getTimestamp = (currentEntry) => {\n    if (currentEntry.status === \"criticalActionHeader\") {\n        return \"\";\n    }\n    if (currentEntry.timestamp === -1) {\n        return \"\\xa0\\xa0\";  // formatAsMinSecs would convert this to 59:59\n    }\n    return formatAsMinSecs(currentEntry.timestamp);\n}\n\n\n","export const formatAsMinSecs = (seconds) => {\n    return new Date(seconds * 1000).toISOString().substr(14, 5)\n}","import { MDB_TYPES, CHECKLIST_STEP_TYPES, OPTION_TYPES } from \"@meddbriefer/scenario-data/constants\";\n\n// input: list of objects and a fieldName\n// returns: an object who's attributes are the distinct values for that fieldName mapped to the subset\n// of list items which share that field value\nexport const groupByKey = (listOfObjs, fldName) => listOfObjs.reduce(\n    (hash, obj) => ({ ...hash, [obj[fldName]]: (hash[obj[fldName]] || []).concat(obj) }),\n    {}\n)\n\nexport const getChecklistItemsByType = (scenario, itemType) => {\n    return scenario.checkListMetaData.filter(e => e.type === itemType)\n}\n\nexport const getChecklistItems = (scenario) => {\n  return scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(MDB_TYPES.PHASE, MDB_TYPES.SUB_PHASE))  \n}\n\nexport const getChecklistHierarchy = (scenario) => {\n    const phases = getChecklistItemsByType(scenario, MDB_TYPES.PHASE)\n    const subPhases = getChecklistItemsByType(scenario, MDB_TYPES.SUB_PHASE)\n    // filters out items which are display only\n    const clSteps = scenario.checkListMetaData.filter(e => CHECKLIST_STEP_TYPES.includes(e.type))\n    // get the options which are associated with some certain types of steps (decisions, assess w/options)\n    const options = scenario.checkListMetaData.filter(e => OPTION_TYPES.includes(e.type))\n    // map the options to their stepId\n    const stepOptions = groupByKey(options, \"parentID\")\n    // if a step has options, add them to that step\n    clSteps.forEach(step => {\n        if (step.id in stepOptions) {\n            step.options = stepOptions[step.id]\n        }\n    })\n    // figure out which checklist items belong to phases or subphases and group them by\n    // the their corresponding phase/subphase ids\n    const phChecklistSteps = groupByKey(clSteps.filter(e => undefined === e.subPhase), \"phase\")\n    const spChecklistSteps = groupByKey(clSteps.filter(e => !!e.subPhase), \"subPhase\")\n    // assign subphase steps to the appropriate subphase\n    subPhases.forEach(sp => {\n        sp.items = spChecklistSteps[sp.id]\n    })\n    // map subphases to their phase\n    const phSubphases = groupByKey(subPhases, \"phase\")\n    // phases have either items or subphases -not both. assign the appropriate stuff\n    // to each phase\n    phases.forEach(ph => {\n        if (ph.id in phChecklistSteps) {\n            ph.items = phChecklistSteps[ph.id]\n        } else {\n            ph.subPhases = phSubphases[ph.id]\n        }\n    })\n    return phases\n}","import { getPhaseStatus, pushNew} from \"./debriefingUtils\"\nimport {leafStatusList, M2CA_PhaseIE} from \"@meddbriefer/feedback-data\"\n\nlet allAssessResults = []\nlet allProblemResults = []\n\n\n\nconst getEntriesUnderHeader = (headerID,events,level,populate) => {\n    let header = mergeHeaderStatuses(headerID,events)\n    if (!!header) { \n        let results = [header]\n        let itemIDs = []\n        let filtered = []\n        if (populate){\n            let eventItems\n            if (level === 2){\n                eventItems = events.filter(e => (e.inPhase === headerID && e.type !== \"header\"))}\n            if (level === 1){\n                eventItems = events.filter (e => (e.phaseID === header.id && e.type === \"header\" && e.subtype === \"assessmentSubHeader\"))\n                //need to filter out duplicate subphases because may be some in the original events list\n                for (const item of eventItems){\n                    if (!itemIDs.includes(item.id)){\n                        itemIDs.push(item.id)\n                        filtered.push(item)}   \n                    }\n                eventItems = filtered\n                }\n            results = results.concat(eventItems)}\n       return results}\n    else {return false}\n }\n\n//merges header for a phase or subphase that is temporally split\nconst mergeHeaderStatuses = (headerID, events) => {\n    let overallStatus = \"unk\"\n    let headerStatuses = []\n    let headerItems = events.filter(e => e.type === \"header\" && e.id === headerID)\n    let header = headerItems[0]    \n    for (const item of headerItems){\n        //pushNew(item.phaseOrderStatus, headerStatuses)\n        pushNew(item.status, headerStatuses)}\n    if (headerStatuses.length > 0) {\n        if (headerStatuses.length === 1){overallStatus = headerStatuses[0]}\n        else {overallStatus = \"errors\"}  //must be all good or all absent for either of those to hold\n    }\n    if (!!header) {header.status = overallStatus}\n    return header \n}\n\n    // after phaseOrderStatus updated need to add that result to subphases status value\nconst updateTopHeaders = (summary) => {\n    let statuses = [\"good\"]\n    let newStatus\n    // eslint-disable-next-line no-unused-vars\n    for (const [key, entry] of Object.entries(summary)) {\n        if (entry[0].subtype === \"assessmentHeader\" && entry[0].status === \"good\") {\n            for (const item of entry.slice(1)) {\n                if (!!item.phaseOrderStatus){\n                    pushNew(item.phaseOrderStatus, statuses)}\n            }\n            if (statuses.length === 1) { newStatus = statuses[0] }\n            else { newStatus = \"errors\" }\n            if (!!newStatus){entry[0].status = newStatus}\n        }\n    }\n}\n\nfunction translateEvent(event) {\n    if ([\"irrelevant\", \"unnecessary\"].includes(event.status)) {\n        return {}}\n    else {\n        let newEvent = {}\n        //regularize some field names across headers and checklist events\n        if (event.labelID) {\n            newEvent.id = event.labelID}\n        else { newEvent.id = event.id }\n        if (event.type === \"header\") {\n            newEvent.subtype = event.id}\n        if (!!event.expertPhase) {\n            newEvent.inPhase = event.expertPhase}\n\n        //now copy over these fields\n        [\"label\", \"status\", \"phaseOrderStatus\", \"phase\", \"subPhase\", \"labelID\", \"phaseID\", \"probLabel\", \"answerCorrect\", \"answerDetails\", \"timestamp\", \"type\"].forEach(fld => {\n            if (!!event[fld]) {\n                newEvent[fld] = event[fld]}\n        })\n\n        //regularize status values in the case of good and absent\n        //did not regularize status values for errors yet, not sure if\n        //the details matter to condition 2\n        if (leafStatusList[\"good\"].includes(newEvent.status)) {\n            newEvent.status = \"good\"}\n        if (leafStatusList[\"absent\"].includes(newEvent.status)) {\n            newEvent.status = \"absent\"}\n        return newEvent\n    }\n}\n\n    \nexport const summarizeAnalysis = (finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated) => {\n    allAssessResults = []\n    allProblemResults = []\n    let hierAssessResults = {}\n    let hierProblemResults = {}\n    finalActions.forEach(event => {\n        if (event.type !== \"intervention\" && event.type !== \"answer\"){\n            allAssessResults.push(translateEvent(event))}\n        else {allProblemResults.push(translateEvent(event))}\n\n    }) \n    problems.forEach(prob => {\n        //let intvHeaderIndex = 1\n        let entries = allProblemResults.filter(e => (e.probLabel === prob.probLabel && e.type !== \"header\"))\n        let statuses = entries.map(e => e.status)\n        let status = getPhaseStatus(statuses)\n        let headerObject = {\n            \"id\": prob.probLabel,\n            \"probLabel\": prob.probLabel,\n            \"status\": status,\n            \"phaseOrderStatus\": \"good\",\n            \"subtype\": \"interventionHeader\",\n            \"type\": \"header\"\n        //    \"numericalID\": intvHeaderIndex++/2000,\n        //    \"displayColor\": \"green\",\n        //    \"why\": \"\",\n        //    \"protocol\": \"\"\n        };\n        if (entries){\n            hierProblemResults[prob.probLabel] = [headerObject].concat(entries)}\n\n    })\n\n    let subLevel = requiredPhaseAndSubPhases\n    let topLevel = requiredPhaseNames.filter(e => !subLevel.includes(e))\n    \n    //need to update status in headers for lower level first since those\n    //values will percolate upwards\n\n    subLevel.forEach(headerID  => {\n        let entries = getEntriesUnderHeader(headerID,allAssessResults,2,true)\n        //console.log(\"header = \", header, \"entries = \", entries)\n        if (entries){\n            hierAssessResults[headerID] = entries}})\n\n    topLevel.forEach(headerID => {\n        let entries = getEntriesUnderHeader(headerID,allAssessResults,1,true)\n        if (entries){\n            hierAssessResults[headerID] = entries}})\n        \n            \n    // store phase level contraint feedback at the header level for condition 2 \n    // (Note that for condition 1 it was stored during the analysis at the first\n    // event entry for a phase and is prefaced by misOrderedPhase in status so that\n    // it alone won't count as an error later for condition 2)\n    let entryToModify \n    let origAction\n    let section\n    let actions = {\n        ...hierAssessResults,\n        ...hierProblemResults}\n    constraintsViolated.forEach(constraint => {\n        origAction = finalActions.filter(e => ((!!e.labelID && e.labelID === constraint.arg1.id) || (e.id === constraint.arg1.id)))[0]\n\n        if (origAction.type === \"header\"){\n            section = actions[origAction.labelID]\n            entryToModify = section[0]}\n        else {\n            if (origAction.type === \"intervention\"){\n                section = actions[origAction.probLabel]\n            }\n            else {\n                section = actions[origAction.workingPhase]} \n            entryToModify = section.filter(e => e.id === constraint.arg1.id)[0]\n        }\n        if (!!entryToModify){\n            if (constraint.type === \"phase\"){\n                entryToModify.phaseOrderStatus = \"misOrdered\"\n                if (!entryToModify.arg2){\n                    entryToModify.arg2 = [constraint.arg2.id]}\n                else {entryToModify.arg2 = entryToModify.arg2.concat([constraint.arg2.id])}}\n            else{\n                if (!entryToModify.arg2){\n                    entryToModify.arg2 = [constraint.arg2.id]}\n                else {entryToModify.arg2 = entryToModify.arg2.concat([constraint.arg2.id])}}}\n    })\n    updateTopHeaders(hierAssessResults)\n\n    console.log(\"top-level-analysis: \", summarize_topLevel(hierAssessResults, hierProblemResults))\n\n    return [hierAssessResults, hierProblemResults]\n\n}\n\nlet topHier\nlet level2Hier\nlet scenarios =\n{\"M2CA\": M2CA_PhaseIE,\n\"SC8CP\": M2CA_PhaseIE}\n\n//called during initialization in analyseEvents\n//changes with each scenario what data structure should be parsed\nexport function get2HierLevelIDs (scen){\n  topHier = []\n  level2Hier = []\n  let phaseIE = scenarios[scen.name]\n  let top = phaseIE.Action\n  for (let action of top.subActions){\n      topHier.push(action.id)\n      // eslint-disable-next-line no-unused-vars\n      for (let subaction of action.subActions) {\n          if ((subaction.subActions).length !== 0){level2Hier.push(subaction.id)}}\n  } \n  console.log(\"top:\", topHier, \"level2:\", level2Hier)\n}\n\nfunction summarize_topLevel(assess,probs) {\n    let c2Input = {}\n    let top = []\n    let statuses = []\n    let status\n    let val\n    let table = {\n        ...assess,\n        ...probs}\n    let headerObject = {\n        \"id\": \"top\",\n        \"probLabel\": \"top\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\"}\n    top.push(headerObject)\n    topHier.forEach(key => {\n        val = table[key]\n        if (!!val){\n            c2Input[key] = val\n            pushNew(val[0].status, statuses)\n            top.push(val[0])}\n    })\n    if (statuses.length === 1) { status = statuses[0] }\n            else { status = \"errors\" }\n    top[0].status = status\n    level2Hier.forEach(key => {\n        val = table[key]\n        if (!!val){\n            c2Input[key] = val}\n    })\n    c2Input[\"top\"] = top\n\nreturn c2Input\n}","import { MDB_TYPES, ANALYSIS_TYPES } from '@meddbriefer/scenario-data/constants.js';\nimport { getPhaseStatus, initializeConstraints, getConstraint, getStatesForStatus, saveAnalysisLog, getEventsByIdTime, pushNew, //pushNew\n} from \"./debriefingUtils\"\nimport { intvChecks, exceptionDefs } from \"@meddbriefer/feedback-data/analysisData\"\nimport { getChecklistItemsByType, getChecklistHierarchy, groupByKey } from './scenarioDataAccesors';\nimport { summarizeAnalysis, get2HierLevelIDs} from './summarizeAnalysis';\n//import { foo } from \"@meddbriefer/feedback-data\"\n\n//console.log(foo())\n\nconst problemStates = getStatesForStatus(\"Problem\")\nconst cautionStates = getStatesForStatus(\"Caution\")\nlet hierAssessResults \nlet hierProblemResults \nlet constraintsViolated \nlet insertInterventionHeader = false  //setting to true helps during debugging analysis, shows headers for problems\n//index of subphase names and value is phase id to which belongs\nlet subPhases = {}\n// list of all subphase IDs\nlet requiredSubphases\nlet requiredPhaseNames\nlet requiredPhaseAndSubPhases\nlet scenario\nexport var itemByID\nexport var itemByLabel\n// sts 1/23/22 - added as global\nlet checklistHierarchy\n\nfunction initGlobals(scen) {\n    scenario = scen\n    initializeConstraints(scen.name)\n    get2HierLevelIDs(scen)\n    itemByID = initializeItemLookupByID(scen)\n    itemByLabel = initializeItemLookupByLabel(scen)\n    requiredPhaseNames = getChecklistItemsByType(scen, MDB_TYPES.PHASE).map(e => e.id).concat([\"Unknown\"])\n    requiredSubphases = getChecklistItemsByType(scen, MDB_TYPES.SUB_PHASE).map(e => e.id)\n    checklistHierarchy = getChecklistHierarchy(scen)\n    requiredPhaseAndSubPhases = findPhaseSubphasesOrdered(checklistHierarchy)\n    checklistHierarchy.forEach(ph => {\n        if (undefined === ph.subPhases) {\n            subPhases[ph.id] = ph.label} \n        else {\n            ph.subPhases.forEach(sp => {\n                subPhases[sp.id] = ph.label})}})\n    subPhases[\"Unknown\"] = \"Unknown\"\n    hierAssessResults = {}\n    hierProblemResults = {}\n    constraintsViolated = []\n}\n\n//This starts section for accessing checklist and intervention components by id or label\nconst initializeItemLookupByID = (scenario) => {\n    let checklistLookupByID = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")\n    let intvLookupByID \n    if (!!scenario.interventions){\n        intvLookupByID = groupByKey(scenario.interventions,\"id\")}\n    else {intvLookupByID = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"id\")}\n    let result = Object.assign(checklistLookupByID, intvLookupByID)\n    return result}\n\nconst initializeItemLookupByLabel = (scenario) => {\n        let checklistLookupByLabel = groupByKey(scenario.checkListMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")\n        let intvLookupByLabel\n        if (!!scenario.interventions){\n            intvLookupByLabel = groupByKey(scenario.interventions,\"label\")}\n        else {intvLookupByLabel = groupByKey(scenario.intvMetaData.filter(e => ANALYSIS_TYPES.includes(e.type)),\"label\")}\n        let result = Object.assign(checklistLookupByLabel, intvLookupByLabel)\n        return result}\n\n\nconst findPhaseSubphasesOrdered = (phases) => {\n    let result = []\n    phases.forEach(ph => {\n        if (!!ph.subPhases){\n            let subPhIds = ph.subPhases.map(e => e.id)\n            //not currently useful to collect parent phases unless there were no subphases\n            //if parent phase included subphases and steps then it should be in this result\n            //result = result.concat(ph.id)\n            result = result.concat(subPhIds)\n        }\n        else {result = result.concat(ph.id)}})\n    return result\n}\n\nconst collectScenAssessments = (problems) => {\n    let assessments = []\n    problems.forEach(prob => {\n        if (prob.assessments !== \"\"){\n            assessments = assessments.concat(prob.assessments)}})\n    return assessments\n}\n\n//will need to update to comply with any relevant constraints on phases and subphases\n//currently looks for missing phases/subphases and inserts them into the analysis list\n//based on where last preceding phase appeared\nconst insertMissingSubphases = (phases,phaseNames) => {\n    let priorPh\n    requiredPhaseAndSubPhases.forEach((phase, i) => {\n        if (!phaseNames.includes(phase)) {\n            //find last index for phase before and splice that    \n            if (i === 0){\n                priorPh = requiredPhaseAndSubPhases[0]\n            }\n            else {priorPh = requiredPhaseAndSubPhases[i-1]}\n\n            let insertionIndex = 0\n            if (priorPh !== phase){\n                insertionIndex = phaseNames.lastIndexOf(priorPh)  //if prior phase was missing it will have been inserted earlier\n                insertionIndex = insertionIndex + 1}\n            \n            phaseNames.splice(insertionIndex, 0, phase); //insert it where it should have appeared\n            phases.splice(insertionIndex, 0, []); //add the empty array for phase objects\n        }});\n    return[phases,phaseNames]\n}\n\n\n//as vital requests and intervention requests are made, update that it was requested\n//if it is one that we are tracking for post intervention success.  \nconst updateVital = (vitalEntries, timestamp) => {\n    let updatedEntries = []\n    vitalEntries.forEach(vitalEntry => {\n        if (vitalEntry.timestamp < timestamp){\n            vitalEntry[\"foundCk\"] = true}\n        updatedEntries.push(vitalEntry)\n    })\nreturn updatedEntries\n}\n\n//initial review of observer log to add annotations to what was found in the observer log.  Filters out things not useful to\n//analysis or is not yet being analyzed in the codep.  It also\n// pulls together interventions and prompt answers into one event and adds fields to each event that will fill in in later analysis,\n// fills in problem information for interventions found in observer log and\n// sets up the phases and phaseNames structures for events in the observation log and initiates\n// record of what have encountered so far in the observations in order to recognize what is missing in later stages of analysis\nconst annotateInputEvents = (events,problems) => {\n    let confirmedEvents = [];\n    let interventionsConfirmed = [];  //needed for vital checking\n    //instead of a multi-dimensional array, am using an array of phase and subphase names e.g. \"BSI\", \"prinary\" ...\n    let phaseNames = [];\n    let phases = []; //and another array with the actual content for each phase.  I can search phaseNames for the index into phases\n    let phaseObjects = [];\n    let trackForStatus = {};  //save correct interventions that were done that require status checks later\n    \n\n    // phases entry of that name and then use that index to retrieve the appropriate phase entried to\n    //add on the missing items (assessment or intervention) for that phase\n    let priorPhase = \"\";\n    let parentPhase = \"\"\n    let parentIndex = 0\n    let phaseIndex = 0;\n    let newPhaseStart = true\n    let assessmentTypes = [\"assessment\", \"required-action\", \"decision-option\", \"assessment-option\"]\n\n    // created annotated object for each event\n    events.forEach((event, i) => {\n        // Each eventObj is one of the lines in the displayed base log\n        // Set up fields for extra annotations for this event after analyzing each event\n        let eventObj = {\n            \"comment\": \"\",\n            \"numericalID\": i,\n            \"status\": \"\",\n            \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n            \"contraindicatedWhy\": \"\",\n            \"minimalWhy\": \"\",\n            \"why\": \"\",\n            \"answerCorrect\": true,\n            \"answerDetails\": {},\n            \"expertPhase\": \"\",  //filled in only for interventions\n            \"workingPhase\": \"\",  //is subphase or if no suphase then the phase\n            \"suggestedPhase\": \"\", //mostly for interventions so don't override info on when was originally done\n            \"protocol\": \"\",\n            \"protocolRelationship\": \"\",\n            \"probLabel\": \"\",\n            \"solutionIds\": [],\n            \"assessments\": \"\",\n            \"required\": false,\n            \"actionDescription\": \"\",\n            \"assessmentFB\": \"\",\n            \"incorrectAnswersFB\": \"\",\n            \"orderingFB\": \"\",\n            \"processingState\": \"good\" // values of good/bad used to filter out events not needed for analysis or displaying\n        };\n\n        // copy over the event fields that exist in the input log from observer UI (which is type dependent)\n        const EVENT_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"vitalType\", \"vital\", \"value\", \"type\", \"prompt\", \"promptID\", \"intervention\", \"timestamp\", \"probLabel\"];\n        EVENT_FIELDS.forEach(fldName => {\n            if (!!event[fldName]) {\n                eventObj[fldName] = event[fldName];\n            }\n        });\n\n        //copy event fields if defined to initialize some of the above annotation fields\n        if (!!event.label) { eventObj.actionDescription = event.label; }\n        if (!!event.type) { eventObj.status = event.type; }\n        // prefer subPhase if available\n        if (!!event.subPhase) { eventObj.workingPhase = event.subPhase; }\n        else {\n            if (!!event.phase) { eventObj.workingPhase = event.phase; }}\n        eventObj.expertPhase = eventObj.workingPhase;\n\n        //if current phase same as prior then keep on with the current phase\n        // otherwise initialize for a new phase but don' let an intervention\n        // or intervention answer set a new phase since this info in event is\n        // not reliable  \n            \n        if (priorPhase !== eventObj.workingPhase || parentPhase !== eventObj.phase){ \n            if (priorPhase !== \"\" && assessmentTypes.includes(eventObj.type)) {  \n                //have a non initial phase change and we have an assessment type (i.e. we can't base phase changes on interventions)\n                newPhaseStart = true\n                phases[phaseIndex] = phaseObjects;\n                if (phaseIndex !== parentIndex){\n                    phases[parentIndex] = phases[parentIndex].concat(phaseObjects);  \n                }\n                phaseIndex++\n                \n                //if upcoming parent phase is different than current parent phase then set up\n                //for a new parent phase\n                if (eventObj.phase !== parentPhase){ \n                    parentPhase = eventObj.phase\n                    parentIndex = phaseIndex\n                    // if the upcoming is truly a parent with subphases \n                    // then add an extra entry for the new parent phase \n                    if (eventObj.phase !== eventObj.workingPhase) {\n                        //create the new parent phase\n                        phases[parentIndex] = []\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++\n                    }}}\n            else {\n                if (priorPhase === \"\" && assessmentTypes.includes(eventObj.type)){\n                // first item in events so initialize\n                    parentPhase = eventObj.phase\n                    // if the event parent phase is not the same as the subPhase\n                    // then we need to save that parent phase in phases and phaseNames\n                    if (parentPhase !== eventObj.workingPhase) {\n                        parentPhase = eventObj.phase\n                        phaseNames[parentIndex] = parentPhase\n                        phaseIndex++;}}\n                \n                else{ \n                    if (priorPhase === \"\"){\n                        //did an intervention before doing any assessments\n                        //so make up an initial phase of unknown\n                        parentPhase = \"Unknown\"\n                        eventObj.workingPhase = parentPhase\n                        eventObj.phase = parentPhase\n                        eventObj.subPhase = \"\" }\n                    else {newPhaseStart = false}}}\n\n                \n            \n            //now setup for collecting for the current phase if not skipping new phase start\n            if(newPhaseStart){\n                priorPhase = eventObj.workingPhase;\n                phaseObjects = [];\n                phaseNames[phaseIndex] = priorPhase;\n                phases[phaseIndex] = []}\n            else {newPhaseStart = true}\n            }\n        \n\n        let eventType = eventObj.type;\n        // List of types in log that are currently processed.  Rest are filtered out.\n        let processedTypes = [\"assessment\", \"required-action\", \"intervention\", \"answer\", \"obtain-vital-sign\", \"decision-option\", \"assessment-option\"];\n\n        //skip over adding anything not of these types to the debriefing display for now\n        if (!processedTypes.includes(eventType)) {\n            eventObj.processingState = \"bad\";\n        }\n\n        // when get an answer for an intervention prompt, grade the response.  The intervention itself is later in the event log, so\n        // accumulate the answers and grading and then when an intervention is later found we can use the intervention\n        // event itself and move all the answer results into it\n        let prioreventObj = [];\n        if (eventType === \"answer\") {\n            //make sure we have answer info for this promptID\n            let correctAnswerLabel = getCorrectAnswerLabel(event.promptID, true);\n            let givenAnswerLabel = getAnswerLabel(event.id, true);\n            //if we don't have answer info for this prompt ID then just ignore this entry\n            if (!correctAnswerLabel) {\n                eventObj.processingState = \"bad\"}\n            else {\n                //currently returns correct answer-id if has answered incorrectly or false if answered correctly\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, true);\n                //store details of this answer and its grading\n                let answerDetails = {\"correctAnswer\": correctAnswerLabel, \"givenAnswer\": givenAnswerLabel, \"correct\": !wrongAnswer}\n                \n                //have answer to prior question for this intervention \n                //(i.e. there is more than one question associated with this intervention)\n                if (confirmedEvents.includes(eventObj.intervention)) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    //add the answer student gave to the action description\n                    eventObj.actionDescription = prioreventObj.actionDescription + \", \" + givenAnswerLabel;\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        if (prioreventObj.incorrectAnswersFB === \"\") {\n                            eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                            }\n                        else {eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB + \", and \" + correctAnswerLabel;\n                            }}\n                    else {\n                        eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                        eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    }}\n                //first answer for this intervention\n                else { \n                    //put the answer student gave in the action description\n                    //responding to first question for the intervention\n                    if (wrongAnswer) {\n                        eventObj.answerCorrect = false;\n                        eventObj.incorrectAnswersFB = \"You should have responded: \" + correctAnswerLabel;\n                    }\n                    else { eventObj.incorrectAnswersFB = \"\"; }\n                    //pushNew(eventObj.intervention,confirmedEvents)\n                    confirmedEvents.push(eventObj.intervention)\n                }\n                //storing the prompt/answer details \n                eventObj.answerDetails[event.promptID] = answerDetails}}\n\n        if (eventType === \"intervention\") {\n            prioreventObj = phaseObjects.slice(-1)[0]; //slice returns an array rather than the last object in array\n            //check to find if prior phaseObjects contains an answer and if it does then consolidate that answer\n            //event into the associated intervention\n            if (prioreventObj && prioreventObj.type === \"answer\"){\n                if (prioreventObj.intervention === eventObj.id) {\n                    prioreventObj = phaseObjects.pop();\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                    eventObj.answerCorrect = prioreventObj.answerCorrect;\n                    eventObj.answerDetails = prioreventObj.answerDetails;\n                    eventObj.incorrectAnswersFB = prioreventObj.incorrectAnswersFB;\n                    eventObj.actionDescription = eventObj.actionDescription + \".\\xa0\\xa0\" + prioreventObj.actionDescription}\n                else {\n                    prioreventObj = phaseObjects.pop();  //discard this answer, it is for an intervention that was not done\n                    confirmedEvents.pop()\n                    confirmedEvents.pop()\n                 }}\n        }\n\n        if (eventObj.processingState === \"good\") {\n\n            if (eventObj.type === \"obtain-vital-sign\"){\n                //if it is an intervention status check then the vital field contains\n                //the intervention id and otherwise the vital label\n                let vital = eventObj.vital \n                let type = \"\"\n                if (eventObj.vitalType === \"intervention-status\"){\n                    if (interventionsConfirmed.includes(vital)){\n                        type = \"intv\"}\n                    else {type = \"noIntv\"}\n                    }\n                else {type = \"vital\"}\n                \n                //update trackForStatus relative to this \"vital\"\n                let vitalEntry = trackForStatus[vital]  \n                //set the status for this particular vital (i.e. makes sense to ask for it or not)\n                switch (type){\n                    case \"intv\": \n                        eventObj.status = \"patientIntvCheck\"\n                        if (vitalEntry && (vitalEntry.timestamp < eventObj.timestamp)){\n                            vitalEntry[\"foundCk\"] = true\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    case \"noIntv\":\n                        eventObj.status = \"intvCheckWNoIntvFound\"\n                        break\n                    case \"vital\":\n                        eventObj.status = \"patientVitalCheck\" \n                        if (vitalEntry){\n                            vitalEntry = updateVital(vitalEntry,eventObj.timestamp)\n                            trackForStatus[vital] = vitalEntry}\n                        break\n                    default: eventObj.status = \"unexpectedPatientIntvCheck\"}\n\n\n                    \n            }\n            // add additional annotations per type\n            if (eventObj.type === \"intervention\") {\n                // iterate through all problem actions looking how to format the\n                // data structue for the current \"event\"\n                problems.forEach((prob, j) => {\n                    // We're going through intervention actions in the order required/needed and then other since\n                    // it is possible but unlikely to have multiple matches and we want the last one to win.\n                    // Also, we are assuming minimal is always a subset of goodintv\n                    const PROBLEM_ACTION_FIELDS = [\"why\", \"probLabel\", \"protocolRelationship\", \"probLabel\"];\n                    \n                    // check for this action to be an intervention for a problem\n                    prob.allActions?.forEach((action, k) => {\n                        if (action.id === eventObj.id) {\n                            //get the full action\n                            //see if this is an event whose status should be checked by the student\n                            //and initialize its tracking.  Not yet limiting to event id when\n                            //defining what needs to be tracked in the structure intvChecks\n                            //so also checking event label\n                            let statusChecking  //the entry retrieve from intvChecks\n                            let intv = eventObj.id\n                            statusChecking = intvChecks[eventObj.label]\n                            if (!statusChecking){\n                                statusChecking = intvChecks[eventObj.id]}\n\n                            if (!!statusChecking){\n                                let initialEntry = {\"intervention\": intv, \"timestamp\": eventObj.timestamp, \"foundCk\": false}\n                                //put the intervention on the list if there is a direct status check possible for it\n                                if (statusChecking.intvStatusNeeded){\n                                    trackForStatus[intv] = Object.assign({}, initialEntry)}\n                                //if any vitals are listed for this intervention as a way of checking its status then\n                                //put those on the statusChecking list.  Anytime a vital is checked after the timestamp\n                                //it will count towards checking the status of the intervention\n                                statusChecking.vitalsNeeded.forEach(vital => {\n                                    if (!trackForStatus[vital]){trackForStatus[vital] = [Object.assign({}, initialEntry)]}\n                                    else {trackForStatus[vital].push(Object.assign({}, initialEntry))}})}\n                                \n                            // fill out problem related fields in the action event\n                            if (!!action.assessments) {eventObj.assessmentsNeeded = action.assessments}\n                            if (!!action.phase) {\n                                eventObj.when = action.phase\n                                eventObj.suggestedPhase = action.phase};\n                            if (!!prob.protocols) {eventObj.protocol = prob.protocols}\n                            if (eventObj.answerCorrect) {\n                                eventObj.status = \"goodIntv\";}\n                            else { eventObj.status = \"incorrect-answers\"; }\n                            //eventObj.probLabel = prob.probLabel;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!action[fldName]) {\n                                    eventObj[fldName] = action[fldName];\n                                }});\n                            if (!!action[\"id-label\"]) { eventObj[\"label\"] = action[\"id-label\"]; }  //dealing with name changes in incoming data so software stays the same\n                        }});\n\n                    // check for this action to be a contraindication for a problem solution\n                    prob.allContras?.forEach((contra, j) => {\n                        if (contra.id === eventObj.id) {\n                            eventObj.status = prob.protocolRelationship;\n                            PROBLEM_ACTION_FIELDS.forEach(fldName => {\n                                if (!!contra[fldName]) {\n                                    eventObj[fldName] = contra[fldName];\n                                }});\n                            if (!!prob.probLabel) { eventObj.probLabel = prob.probLabel; }\n                        }}) \n                    })}\n\n            if (eventObj.type === \"decision-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"decision-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n\n            if (eventObj.type === \"assessment-option\"){\n                let wrongAnswer = evalForIncorrectAnswer(event.promptID, event.id, false);\n                if (wrongAnswer){\n                    eventObj.status = \"assessment-option-incorrect\"\n                    eventObj.answerCorrect = false\n                    eventObj.incorrectAnswerFB = \"You should have responded \" + getCorrectAnswerLabel(event.promptID, false);\n                    }}\n            // add the formatted object to our list of formatted objects for the current phase and the id to our set of confirmed ids\n            if (eventObj.type === \"intervention\"){\n                confirmedEvents.push(eventObj.id + \"+\" + eventObj.probLabel)\n                interventionsConfirmed.push(eventObj.id)\n            }\n            else {confirmedEvents.push(eventObj.id)}\n            phaseObjects.push(eventObj)}});\n\n    // store the last phase processed\n    phases[phaseIndex] = phaseObjects;\n    if (phaseIndex !== parentIndex){\n        phases[parentIndex] = (phases[parentIndex]).concat(phaseObjects)};\n    return [phases,phaseNames,confirmedEvents,trackForStatus]\n}\n\n//start support functions for constraint checking\n\nconst findNameNumID = (names, entries, item, occurrence) => {\n    let result = undefined\n    let index = undefined\n    for (let i = 0; i < names.length; i++) {\n        if (item.id === names[i]) {\n            result = entries[i]\n            if (occurrence === \"start\") {\n                break}}}\n    if (!!result) {\n        if (result.numericalID === -1) {\n            if (occurrence === \"start\") {\n                index = result.numericalIDStart}\n            else { index = result.numericalIDEnd }}\n        else { index = result.numericalID }}\n\n    return index\n}\n\nlet unknownItem = {id: \"Unknown\", label: \"Unknown\"}\n\nconst getItem = (val) => {\n    if (val === \"Unknown\"){return unknownItem}\n    let item = itemByID[val]\n    if (!item){\n        item = itemByLabel[val]}\n    if (item){return item[0]}\n}\n\nconst findObjByNumerialID = (numericalID,phases,phaseNames) => {\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            for (let entry of phaseObjects){\n                if (entry.numericalID === numericalID){\n                    return entry}\n            }}}}\n\n\nconst storeMisOrderedArgs = (numericalID, arg2, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (!objToModify.arg2){\n            objToModify.arg2 = [arg2.id]}\n        else {objToModify.arg2 = objToModify.arg2.concat([arg2.id])}}\n}\n\nconst storeMisOrderedFB = (numericalID, FB, constraintType, phases, phaseNames) => {\n    let objToModify = findObjByNumerialID(numericalID, phases, phaseNames)\n    if (!objToModify) {console.log(\"no object found for numericalID = \", numericalID)}  //just for debugging\n    else {\n        if (objToModify.orderingFB !== \"\") {\n            objToModify.orderingFB = objToModify.orderingFB + \".\\xa0\\xa0\" + FB}\n        else { objToModify.orderingFB = FB }\n        let status\n        \n        let appendString = \"\"\n        if (constraintType === \"phase\"){\n            appendString = \"misOrdered-phase-\"}\n        if (constraintType === \"item\"){\n            appendString = \"misOrdered-\"}\n        if (!(objToModify.status.includes(appendString)))\n                {status = appendString + objToModify.status \n                objToModify.status = status}}\n}\n\n\n//flattens out the phases and phaseNames data structures so that all phase and subphase\n//names have their own entry and each item under a phase or subphase has its own entry.\n//Collect and return unique names because phase and subphase names can appear multiple times in the \n//phases and phaseNames ds.  Having a unique list of names means that a constraint will only be checked once.\n\n\nconst collectEntriesToCheckConstraints = (phases, phaseNames) => {\n    let listOfNames = []\n    let listOfEntries = []\n    let uniqueListOfNames = []\n    let counter = -1\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let phaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let startIndex = phaseObjects[0].numericalID\n        let endIndex = phaseObjects[phaseObjects.length-1].numericalID\n\n        //handle phases and subphases first\n    \n        if (requiredPhaseNames.includes(phaseName) || requiredSubphases.includes(phaseName)) {\n            listOfEntries.push({ id: phaseName, numericalID: counter, numericalIDStart: startIndex, numericalIDEnd: endIndex })\n            listOfNames.push(phaseName)\n            if (!uniqueListOfNames.includes(phaseName)){uniqueListOfNames.push(phaseName)}}\n\n        //can't be an else to above because a phase can have entries but a subphase cannot\n        \n        if (phaseObjects.length > 0 && !hasSubPhases(phaseName)){\n            let phaseObjectNames = phaseObjects.map(obj => obj.id)\n            listOfEntries = listOfEntries.concat(phaseObjects)\n            uniqueListOfNames = uniqueListOfNames.concat(phaseObjectNames)\n            listOfNames = listOfNames.concat(phaseObjectNames)\n        }\n    }\nreturn [listOfNames, uniqueListOfNames, listOfEntries]\n\n}\n\nconst saveFailedConstraint = (lateArg, otherArg, constraintID) => {\n    let type\n    if ([\"phase\", \"sub-phase\"].includes(lateArg.type)){\n        type = \"phase\"}\n    else {type = \"item\"}\n    constraintsViolated.push({constraintID: constraintID, arg1: lateArg, op: \"before\", arg2: otherArg, type: type}) \n    return type\n}\n\nconst addToListOfFeedback = (parPhFB, last, label, repeating) => {\n    //feedback for nonphase\n    if (repeating){\n        if (last) {\n            parPhFB = parPhFB + \" and \"\n        }\n        else {parPhFB = parPhFB +  \", \"}}\n    parPhFB = parPhFB + label.toLowerCase()\n    return parPhFB\n}\n\n\n\nconst checkAgainst2ndArgs = (arg1st,args2nd,op,direction,constraintID,entryNames,entries,phases,phaseNames) => {\n    let endNum1st = findNameNumID(entryNames, entries, arg1st, \"end\")\n    let startNum1st = findNameNumID(entryNames, entries, arg1st, \"start\")\n    let label1st = arg1st.label\n    let phFB = \"\"\n    let par1PhFB = \"\"\n    let par2PhFB = \"\"\n    let repeating\n    let constraintType\n    if (args2nd.length > 0) {\n        let counter = 0\n        let violations = 0\n        for (let arg of args2nd) {\n            let last = false\n            let arg2nd = getItem(arg)\n            if (!!arg2nd) {\n                counter++\n                if (counter === args2nd.length){\n                    last = true}\n                let label2nd = arg2nd[\"label\"]\n                let startNum2nd = findNameNumID(entryNames, entries, arg2nd, \"start\")\n                let endNum2nd = findNameNumID(entryNames, entries, arg2nd, \"end\")\n                \n                switch (direction){\n                case \"before\":\n                    if (!!endNum1st && !!startNum2nd) {\n                        if (!(endNum1st < startNum2nd)) {  //if failed constraint i.e. arg1 is late\n                            //result = collectFB (constraintID, counter, arg1st, arg2nd, startNum1st, startNum2nd, endNum1st, endNum2nd, label1st, label2nd, last, constraintType, phases, phaseNames)\n                            //feedback for item\n                            violations++\n                            if (par1PhFB === \"\"){\n                                if (startNum1st === endNum1st) { \n                                    par1PhFB = \"You should have done \"\n                                    par1PhFB = addToListOfFeedback(par1PhFB, last, label1st, false)}     \n                                //feedback for phase\n                                else { \n                                    par1PhFB = \"You should have completed \"\n                                    par1PhFB = addToListOfFeedback(par1PhFB, last, label1st, false)}} \n                            if (startNum2nd === endNum2nd) {\n                                if (par2PhFB === \"\"){\n                                        par2PhFB = par2PhFB + \" before you did \"}  //feedback for item\n                                    if (violations > 1){repeating = true}\n                                    else {repeating = false}\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label2nd, repeating)}\n                            else { \n                                if (par2PhFB === \"\"){\n                                    par2PhFB = par2PhFB + \" before starting \"}  //feedback for phase\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par2PhFB = addToListOfFeedback(par2PhFB, last, label2nd, repeating)}\n                            storeMisOrderedArgs(startNum1st, arg2nd, phases, phaseNames)\n                            constraintType = saveFailedConstraint(arg1st, arg2nd, constraintID)\n                        }\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                case \"after\":  //for after just reverse 1st and 2nd args\n                    if (!!startNum1st && !!endNum2nd) {\n                        if (!(startNum1st > endNum2nd)) { //if failed constraint  i.e. arg2 is late  \n                            violations++                         \n                            if (startNum1st === endNum1st){\n                                //feedback for item \n                                if (par1PhFB === \"\")                              \n                                    {par1PhFB = \"You should have done \"}\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par1PhFB = addToListOfFeedback(par1PhFB, last, label2nd, repeating)}\n                            //feedback for phase \n                            else{\n                                if (par1PhFB === \"\")                               \n                                    {par1PhFB = \"You should have completed \"}\n                                if (violations > 1){repeating = true}\n                                else {repeating = false}\n                                par1PhFB = addToListOfFeedback(par1PhFB, last, label2nd, repeating)}\n                            if (par2PhFB === \"\"){\n                                if (startNum2nd === endNum2nd){     \n                                    par2PhFB = par2PhFB + \" before you did \"\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label1st, false)}\n                                else {                                 \n                                    par2PhFB = par2PhFB + \" before starting \" //feedback for nonphase\n                                    par2PhFB = addToListOfFeedback(par2PhFB, last, label1st, false)}}\n                            storeMisOrderedArgs(startNum2nd, arg1st, phases, phaseNames)   //feedback for phase\n                            constraintType = saveFailedConstraint(arg2nd, arg1st, constraintID)}\n                        else {\n                            if (op === \"or\") {\n                                return}}}\n                    break\n                default: break\n                }\n            }     \n        }        \n        phFB = par1PhFB + par2PhFB\n        if (phFB !== \"\") {\n            storeMisOrderedFB(startNum1st, phFB, constraintType, phases, phaseNames)}    \n    }\n}\n\n\n\nconst checkConstraintsForArg = (arg1st, constraint, phases, phaseNames, entryNames, entries) => {\n    \n    let args2nd = constraint.before\n    let op = constraint.beforeOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"before\",constraint.id,entryNames,entries,phases,phaseNames)\n\n    args2nd = constraint.after\n    op = constraint.afterOp\n    checkAgainst2ndArgs(arg1st,args2nd,op,\"after\",constraint.id,entryNames,entries,phases,phaseNames)}\n    \n    \n  //end support functions for constraint checking              \n                        \n\n\n//To DO: filter constraints in/out based on findings available for this scenario\n\n//main function for constraint checking \nconst checkAgainstKB = (phases, phaseNames) => {\n\n    let result = collectEntriesToCheckConstraints(phases, phaseNames)\n    let entryNames = result[0]\n    let uniqueEntryNames = result[1]\n    let entries = result[2]\n    uniqueEntryNames.forEach(firstArg => {\n        let firstArgItem = getItem(firstArg)\n        if (!!firstArgItem) {        \n            let constraint = getConstraint(firstArgItem)  //will find only one constraint per 1st arg\n            if (!!constraint) {\n                checkConstraintsForArg(firstArgItem, constraint, phases, phaseNames, entryNames, entries)}}})            \n    //only expect to change objects in phases\n    return [phases, phaseNames]\n}\n\n\n//main function for dealing with missing assessment steps\n\nconst checkForMissingAssessments = (problems,events,confirmedEvents,phaseNames,phases) => {\n    let neededScenAssessments = collectScenAssessments(problems)\n    let indexCounter = events.length;\n    var checklistSteps = scenario.checkListMetaData.filter(md => [MDB_TYPES.ASSESS, MDB_TYPES.REQUIRED].includes(md.type));\n\n    // before evaluating assessment steps, deal with exceptional cases where one or more steps is not\n    // necessary for a given scenario.  Because GCS value is a string and not a formatted object\n    // we can't reliably parse out values and units to do more general checks so can only set what\n    // steps should not be assessed for a particular scenario.  Requires info on feedback to give as\n    // well.\n    // Get any exceptional steps associated with the current scenario\n    var exceptions = [];\n    for (let exceptionDef of exceptionDefs) {\n        if (exceptionDef.scenarioName === scenario.name) {\n            exceptions = exceptionDef.exceptions;\n            break;\n        }\n    }\n\n    exceptions.forEach((exception, j) => {\n        // remove the step from the checklist as it is not required\n        checklistSteps = checklistSteps.filter(entry => entry.id !== exception[0]);\n\n        // if the step was done during the observation then mark it as an issue\n        if (confirmedEvents.includes(exception[0])) {\n            // it could appear in any phase so check all phases and mark\n            // each instancs as unnecessary\n            phases.forEach((phaseObjects, j) => {\n                phaseObjects.forEach((action, i) => {\n                    if (action.id === exception[0]) {\n                        action.why = exception[1];\n                        action.status = \"notNecessary\";\n                    }\n                });\n            });\n        }\n\n    });\n\n    // iterate through all checklist steps for ones for which we don't have formated objects\n    checklistSteps.forEach((cls, i) => {\n        if (!confirmedEvents.includes(cls.id)) {\n            // add so we don't check for the missing checklist item again\n            confirmedEvents.push(cls.id);\n            let phaseObject = {\n                \"comment\": \"\",\n                \"numericalID\": indexCounter,\n                \"status\": \"missingRequiredAssessment\",\n                \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                \"expertPhase\": \"\",\n                \"workingPhase\": \"\",\n                \"contraindicatedWhy\": \"\",\n                \"minimalWhy\": \"\",\n                \"why\": \"\",\n                \"probLabel\": \"\",\n                \"protocol\": \"\",\n                \"actionDescription\": \"\",\n                \"assessmentFB\": \"\",\n                \"timestamp\": -1\n            };\n\n            //copy over the step fields that exist (type dependent)\n            const STEP_FIELDS = [\"id\", \"label\", \"finding\", \"phase\", \"subPhase\", \"type\", \"prompt\"];\n            STEP_FIELDS.forEach(fldName => {\n                if (!!cls[fldName]) {\n                    phaseObject[fldName] = cls[fldName];\n                }\n            });\n            if (!!cls.subPhase) { phaseObject.workingPhase = cls.subPhase; }\n            else { if (!!cls.phase) { phaseObject.workingPhase = cls.phase; } }\n            phaseObject.when = phaseObject.workingPhase;\n            phaseObject.expertPhase = phaseObject.workingPhase;\n\n            if (!!phaseObject.label) { phaseObject.actionDescription = phaseObject.label; }\n            \n            //let findings = scenario.assessmentFindings[cls['id']]\n            //if (!!findings & findings !== \"Unremarkable\" & findings !== \"Stable\"){\n\n            if (neededScenAssessments.includes(cls['id'])){\n                phaseObject.assessmentFB = \"Thus you missed finding: \" + scenario.assessmentFindings[cls['id']]}\n            if (phaseObject.type === \"required-action\"){\n                phaseObject.status = \"missingRequiredAssessment\"\n            }\n            insertInPhaseInOrder(phaseNames, phases, phaseObject, i);\n            indexCounter++;\n        }\n    });\n    return[confirmedEvents, phaseNames, phases, indexCounter]\n}\n\n//support functions for updating and searching the phaseNames and phases data structures\nconst insertInPhaseInOrder = (phaseNames, phases, object, objIndex) => {\n    let phase\n    phase = object.when;  //what phase should it be added to\n    let phaseIndex = phaseNames.lastIndexOf(phase); //get the index for the last instance of the phase\n    let phaseObjects = phases[phaseIndex];  //get the objects associated with that phase\n    if (!phaseObjects) { phaseObjects = []; }\n    phaseObjects.splice(objIndex - 1, 0, object);  //insert it at the place indicated by input objIndex\n    phases[phaseIndex] = phaseObjects;\n};\n\nconst getEndSubPhase = (inPhaseId, phaseNames) => {\n    let subPhases = getSubPhases(inPhaseId);\n    let subPhaseName;\n    let reversedSubPhases = [...subPhases].reverse();\n    for (let subPhase of reversedSubPhases) {\n        subPhaseName = phaseNames.find(id => id === subPhase.id);\n        if (!!subPhaseName) { break; }\n    }\n    return subPhaseName;\n};\n\nconst getEndSubPhaseIndex = (inPhaseId, phaseNames) => {\n    let subPhaseName = getEndSubPhase(inPhaseId, phaseNames);\n    let index = phaseNames.lastIndexOf(subPhaseName);\n    //console.log(subPhaseName,index)\n    return index;\n};\n\n// sts 01/23/22\nconst getSubPhases = (phaseId) => {\n    return checklistHierarchy.find(phase => phase.id === phaseId).subPhases\n    // let mainPhases = findPhases();\n    // let phaseEntry = mainPhases.find(phase => phase.id === phaseId);\n    // return (phaseEntry.subPhases);\n};\n\nconst hasSubPhases = (phaseId) => {\n    let phase = checklistHierarchy.find(phase => phase.id === phaseId)\n    if (!!phase && !!phase.subPhases){\n        return true}\n    else {return false}\n}\n\n  \n//given a numerical id, what is its parent phase or subphase\n//find the header under which the input numericalID appears\nconst findHeaderFor = (numericalID, log) => {\n    let candidateHeader = {};\n    let foundHeader = {};\n    for (let entry of log) {\n        if (entry.id === \"problemHeader\") {\n            candidateHeader = entry;\n        }\n        else {\n            if (entry.numericalID === numericalID) {\n                foundHeader = candidateHeader;\n                break;\n            }\n        }\n    }\n    return (foundHeader);\n};\n\n//rearrange the problem data structure for use during analysis\n\nconst setupProblems = (defs, sols, actions) => {\n    let problems = [];\n    for (let problemDef of defs) {\n        let problem = {};\n        \n\n        //new interface\n        if (!!sols && !!actions){\n            let solutionIDs = problemDef.solutions;\n            let probSols = sols.filter(sol => sol.problemID === problemDef.id)\n            problem.probLabel = problemDef.label;\n            problem.id = problemDef.id\n            problem.lifeThreat = problemDef.lifeThreat\n            problem.vitals = problemDef.vitals\n            problem.allActions = []\n            problem.allContras = []\n            let assessments = problemDef.assessments\n            problem.assessments = assessments.map(obj => obj.assessmentID)\n            problem.solutions = []\n            for (let solID of solutionIDs){\n                let sol = probSols.filter(sol => sol.id === solID)[0]\n                let solution = Object.assign({}, sol)\n                solution.actions = []\n                solution.otherActions = []\n                let actEntries\n                let actIDs = sol.actions\n                actEntries = actions.filter(act => actIDs.includes(act.id))\n            \n                for (let entry of actEntries){\n                    let act = Object.assign({}, entry)\n                    act.id = act.interventionID\n                    let item = itemByID[act.id]\n                    act.probLabel = problem.probLabel\n                    if (!!item){\n                        act[\"id-label\"] = item[0].label}\n                    else {act[\"id-label\"] = act.id}\n                    switch (act.protocolRelationship){\n                        case \"contraindicated\":\n                        case \"irrelevant\":\n                        case \"unnecessary\":\n                            solution.otherActions.push(act)\n                            pushNew(act, problem.allContras)  //need to be able to annotate an action without deciding yet on which solution under\n                            break\n                        case \"required\":\n                        case \"minimal\":\n                        case \"optional\":\n                            solution.actions.push(act)\n                            pushNew(act, problem.allActions)  //need to be able to annotate an action without deciding yet on which solution under\n                            break\n                        default:\n                            break}\n                }\n                problem.solutions.push(solution)\n            }\n        }\n        // old interface and not modified yet for multiple solutions\n        else {\n            let solutionID = problemDef.solutions[0];\n            let solution = Object.assign({})\n            problem.probLabel = problemDef.problem;\n            problem.lifeThreat = problemDef.lifeThreat\n            problem.allActions = []\n            problem.allContras = []\n            solution.actions = solutionID.actions;\n            solution.minimalWhy = solutionID.minimalWhy;\n            solution.protocols = solutionID.protocols\n            problem.assessments = problemDef.assessments;\n            problem.solutions = []\n            solution.otherActions = solutionID.contraindications;\n            solution.actions.forEach(act => {\n                pushNew(act, problem.allActions)  //need to be able to annotate an action without deciding yet on which solution under\n                act.probLabel = problem.probLabel\n                if (act.minimal){act.protocolRelationship = \"minimal\"}\n                if (act.optional){act.protocolRelationship = \"optional\"}\n                if (!act.minimal && !act.optional){act.protocolRelationship = \"required\"}})\n            solution.otherActions.forEach(act => {  //need to be able to annotate an action without deciding yet to which solution under\n                    pushNew(act, problem.allContras)\n                    act.protocolRelationship = \"contraindicated\"})\n        \n            problem.solutions.push(solution)\n            //not in new interface\n            problem.allProblemProtocols = problemDef.protocol;\n            \n            }\n        problems.push(problem);\n        \n    }\n    return (problems);\n    //console.log(problems)\n};\n\n// this approximates the placement for a missing intervention based on ordering of interventions\n// in the problems definitions, what appears in the log that is just before and just after\n// the item to be inserted, and what is marked as required that is in the log just before and after.  An approach that\n// utilizes partial ordering constraints would be better.  Also it is not clear what to do for really badly ordered\n// actions on the part of the student.  Note that it only looks for two anchor points before and two anchor points after\n// rather than all potential anchor points.  Also it does not deal with a phase that is split into multiple time periods\n// within a log. It looks for the best placement in the last phase found.\n\n//input orderedArrayObjects is the interventions for a problem as ordered in the problem def\n// objIndex is the index in orderedArrayObjects for the intervention object that needs to be inserted in phases\nconst insertInPhaseRelativeToSuggestedOrder = (phaseNames, phases, object, orderedArrayObjects, objIndex) => {\n    // if expertPhase in object is a phase then find the last subphase and insert there instead of at the beginning\n    let phaseIndex = -1;\n    //console.log(object);\n    // if it is a subphase or a phase with no subphases then get the last entry for a proposed initial insertion point\n    // object.expertPhase is the phase recommended for this action to appear\n    if (object.expertPhase === \"\"){\n        /* let errorMsg = 'No phase specified in the problem defs for object: ' + object.actionDescription;\n        throw new Error(errorMsg) */\n        //just use the next to last phase if none is specified\n        object.expertPhase = requiredPhaseNames[requiredPhaseNames.length - 2]}\n        \n\n    if (requiredSubphases.includes(object.expertPhase) || !getSubPhases(object.expertPhase)) {\n        phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    }\n    // if it is a phase then get the last entry of the last suphase within it for a proposed intial insertion point\n    else {\n        phaseIndex = getEndSubPhaseIndex(object.expertPhase, phaseNames);}\n        \n    //update object when field which is mostly to see what gets computed for the insertion point\n    object.when = phaseNames[phaseIndex];\n        \n    \n\n    let objectsBefore = orderedArrayObjects.slice(0, objIndex - 1);\n    let objectBefore = orderedArrayObjects[objIndex - 1];\n    // console.log(\"Objects before in def\", {...objectsBefore})\n    let requiredObjectBefore = [...objectsBefore].reverse().find(entry => entry.required);\n    let objectAfter = orderedArrayObjects[objIndex + 1];\n    let objectsAfter = orderedArrayObjects.slice(objIndex + 1);\n    let requiredObjectAfter = objectsAfter.find(entry => entry.required);\n    //let phaseIndex = phaseNames.lastIndexOf(object.expertPhase);\n    let phaseObjects = [...phases[phaseIndex]]; //trying for a deep copy of the array mainly for debug via console.log\n\n    //console.log(phaseObjects)\n    let indexBefore = -1;\n    let indexAfter = -1;\n    let indexRequiredBefore = -1;\n    let indexRequiredAfter = -1;\n    let insertionIndex = false;\n    if (objectBefore) { indexBefore = phaseObjects.findIndex(entry => entry.id === objectBefore.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    if (requiredObjectBefore) { indexRequiredBefore = phaseObjects.findIndex(entry => entry.id === requiredObjectBefore.id); }\n    if (requiredObjectAfter) { indexRequiredAfter = phaseObjects.findIndex(entry => entry.id === requiredObjectAfter.id); }\n    if (objectAfter) { indexAfter = phaseObjects.findIndex(entry => entry.id === objectAfter.id); }\n    // There is a more compact way to do the below but this made\n    // it easier for me to get the logic right\n    // insert according to required before first as we want to follow something that was required\n    if (indexRequiredBefore !== -1) {\n        insertionIndex = indexRequiredBefore + 2;\n        // but if the just before object is greater then insert relative to it\n        if (indexBefore > indexRequiredBefore) { insertionIndex = indexBefore + 2; }\n    }\n    //if no required before and not required after then insert relative to\n    //required item after in actions definition\n    if (!insertionIndex && indexRequiredAfter !== -1) {\n        insertionIndex = indexRequiredAfter + 1;\n        // unless the just after is smaller then override and insert relative to it\n        if (indexAfter < indexRequiredAfter) { insertionIndex = indexAfter + 1; }\n    }\n    //otherwide if have a just before insert relative to it\n    if (!insertionIndex && indexBefore !== -1) {\n        insertionIndex = indexBefore + 2;\n    }\n    //otherwise if have a just after insert relative to it\n    if (!insertionIndex && indexAfter !== -1) {\n        insertionIndex = indexAfter + 1;\n    }\n    //otherwise put at end of phase\n    if (!insertionIndex) {\n        insertionIndex = phaseObjects.length + 2;\n    }\n    insertInPhaseInOrder(phaseNames, phases, object, insertionIndex);\n\n};\n\nconst determineHLcolor = (lowerColor, higherColor) => {\n    let newColor = higherColor\n    if (lowerColor === \"red\") {\n        newColor = \"red\"\n    }\n    if (lowerColor === \"yellow\" && newColor !== \"red\") {\n        newColor = \"yellow\"\n    }\n    return newColor\n}\n\n//to display the log using the phase structures accumulated\n// i.e. puts the phases data together in the order in which\n// should be displayed in debriefing log\nconst organizeLogDisplay = (phaseNames, phases) => {\n    let displayObjects = [];\n    let entryIndex = 1;\n    let headerIndex = 1;\n    let problemHeaderColor = \"green\"\n    let subPhaseColor = \"green\"\n    let subPhaseStatuses = []\n    let phaseStatuses = []\n    let newPhaseObjects = []\n    let headerObj = {\n        \"id\": \"assessmentHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"protocol\": \"\"\n    };\n    let subHeaderObj = {\n        \"id\": \"assessmentSubHeader\",\n        \"status\": \"\",\n        \"phaseOrderStatus\": \"good\",\n        \"type\": \"header\",\n        \"numericalID\": 1,\n        \"displayColor\": \"\",\n        \"why\": \"\",\n        \"label\": \"\",\n        \"labelID\": \"\",\n        \"phaseID\": \"\",\n        \"protocol\": \"\"\n    };\n    \n    let priorHLPhaseItem = \"\"\n    let endEntry = false\n    for (let phaseIndex = 0; phaseIndex < phaseNames.length; phaseIndex++) {\n        let iPhaseObjects = phases[phaseIndex];\n        let phaseName = phaseNames[phaseIndex];\n        let process = true\n        \n        if (requiredPhaseNames.includes(phaseName) && hasSubPhases(phaseName)) {\n            process = false}\n\n        if (iPhaseObjects.length > 0 && process) {\n                //for this set of objects, find the worst scoring item\n            let phaseObjects = phases[phaseIndex];\n            subPhaseColor = \"green\"\n            for (let phaseObject of phaseObjects) {\n                if (phaseObject.type !== \"intervention\"){\n                    subPhaseStatuses.push(phaseObject.status)}\n                //else {hierProblemResults.push(phaseObject)} \n                if (problemStates.includes(phaseObject.status)) {\n                    subPhaseColor = \"red\";     \n                }\n                // Red has a higher priority than yellow so will allow to override it\n                if (cautionStates.includes(phaseObject.status) && subPhaseColor !== \"red\") {\n                    subPhaseColor = \"yellow\";    \n                }               \n                phaseObject.numericalID = entryIndex++;\n                //entryIndex++;\n            };\n\n            let subheader = Object.assign({}, subHeaderObj)\n            let localPhaseName = phaseNames[phaseIndex]\n            let localPhaseItem = getItem(localPhaseName)\n            subheader.label = localPhaseItem.label\n            subheader.labelID = localPhaseItem.id\n            subheader.status = getPhaseStatus(subPhaseStatuses)\n            subheader.displayColor = subPhaseColor\n            let highLevelPhase = subPhases[localPhaseName]\n            let highLevelPhaseItem = getItem(highLevelPhase)\n            subheader.phaseID = highLevelPhaseItem.id\n\n            //Note that the inserted headers will have their own numerical id and\n            //am dividing by 1000 for headers so their numerical id will be unique\n            //to headers.  Am assuming we would never have more than 1000 events\n            //observed.  Will use the numerical ids for testing before and after\n            //constraints.       \n            \n            if (priorHLPhaseItem === \"\") {\n                priorHLPhaseItem = highLevelPhaseItem\n                problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n            }\n            \n            if (phaseIndex === phaseNames.length - 1) {\n                //this closes out the prior phase and the new subphase \n                let header = Object.assign({}, headerObj)\n                if (highLevelPhase !== priorHLPhaseItem.label){    //ending with start of a new phase\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    newPhaseObjects = []}\n\n                header = Object.assign({}, subheader)\n                header.label = highLevelPhaseItem.label\n                header.labelID = highLevelPhaseItem.id\n                header.id = \"assessmentHeader\"\n                header.numericalID = headerIndex++ / 1000 \n                displayObjects.push(header)\n                      \n                if (highLevelPhase === subheader.label) { \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(...phaseObjects)}\n                else {\n                    subheader.numericalID = headerIndex++ / 1000 \n                    displayObjects.push(...newPhaseObjects)\n                    displayObjects.push(subheader)\n                    displayObjects.push(...phaseObjects)}          \n                endEntry = true;\n            }\n\n            //save the accumulated high-level phase if the phase changes \n            if (!endEntry) {\n                if (highLevelPhase !== priorHLPhaseItem.label) {\n                    let header = Object.assign({}, headerObj)\n                    header.label = priorHLPhaseItem.label\n                    header.labelID = priorHLPhaseItem.id\n                    header.status = getPhaseStatus(phaseStatuses)\n                    phaseStatuses = []\n                    header.displayColor = problemHeaderColor;\n                    header.numericalID = headerIndex++ / 1000\n                    displayObjects.push(header)\n                    displayObjects.push(...newPhaseObjects)\n                    //reinitialize for the new phase   \n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects = [...phaseObjects]\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects = [subheader]\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    priorHLPhaseItem = highLevelPhaseItem\n                    problemHeaderColor = determineHLcolor(subPhaseColor, \"green\")\n                }\n                else {\n                    problemHeaderColor = determineHLcolor(subPhaseColor, problemHeaderColor)\n                    phaseStatuses.push(...subPhaseStatuses)\n                    subPhaseStatuses = []\n                    if (highLevelPhase === subheader.label) {\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                    else {\n                        subheader.numericalID = headerIndex++ / 1000\n                        newPhaseObjects.push(subheader)\n                        newPhaseObjects.push(...phaseObjects)\n                    }\n                }\n            }\n        \n        }\n    }\n    return displayObjects;\n}\n\n\n\n\nconst evalForIncorrectAnswer = (promptID, answerID, isIntervention) => {\n        //check each prompt and if is the appropriate one then\n        let answers = undefined\n        if (isIntervention) {\n            answers = scenario.associations[promptID];\n        }\n        else { answers = scenario.checkListCorrectness[promptID]; }\n\n        if (answers === undefined) { console.log(\"didn't find answers for \", promptID); return (false) }  //can't grade if answers not found in spec\n\n        if (Array.isArray(answers)) {\n            //returns bool regarding whether answerID NOT in answers\n            return !(answers.find(ansId => ansId === answerID));\n\n        }\n        else {\n            return !(answers === answerID);\n        }\n};\n\n\nconst getCorrectAnswerLabel = (promptID, isIntervention) => {\n    let answers\n    let metaData\n    if (isIntervention){\n        answers = scenario.associations[promptID];\n        metaData = scenario.intvMetaData}\n    else {answers = scenario.checkListCorrectness[promptID];\n        metaData = scenario.checkListMetaData}\n    let answerLabels = false;\n    if (Array.isArray(answers)) {\n        answers.forEach((answer, j) => {\n            metaData.forEach((entry, i) => {\n                if (entry.id === answer) {\n                    if (answerLabels === false) {\n                        answerLabels = entry.label;\n                    }\n                    else { answerLabels = answerLabels + \", \"; }\n                    return;\n                }\n            });\n        });\n    }\n\n    else {\n\n        metaData.forEach((entry, i) => {\n            /* //needed to find out what the types are for debugging\n            let answertypes = []\n            if (!answertypes.find(type => type === entry.type)){\n                answertypes.push(entry.type)} */\n\n            if (entry.id === answers) {\n                answerLabels = entry.label;\n            }\n        });\n    }\n    //answerLabels = answerLabels.charAt(0).toLowerCase() + answerLabels.slice(1);\n    /* if (answerLabels){\n        answerLabels = \"'\" + answerLabels + \"'\";} */\n    return answerLabels\n};\n\nconst getAnswerLabel = (answerID, isIntervention) => {\n    let metaData\n    if (isIntervention){\n        metaData = scenario.intvMetaData}\n    else {metaData = scenario.checkListMetaData}\n    let answerLabel = \"\";\n    metaData.forEach((entry, i) => {\n            if (entry.id === answerID) {\n                answerLabel = entry.label;\n            }\n        });\n    return (answerLabel || false) ;\n}\n\n// create structure for tracking whether interventions are checked\nconst insertMissingIntvChecks = (events, statusTracking) => {\n    let toUpdate\n    for (const [key, entry] of Object.entries(statusTracking)) {\n        if (Array.isArray(entry)){\n            for (let obj of entry) {\n                let newObj = {\"label\": key, \"foundCk\": obj[\"foundCk\"]}\n                toUpdate = getEventsByIdTime(events,obj[\"intervention\"],obj[\"timestamp\"])\n                for (let intv of toUpdate) {\n                    if (!intv[\"intvStatus\"].includes(newObj)){\n                       intv[\"intvStatus\"].push(newObj)}\n                }}}\n        else {\n            let newObj = {\"label\": \"intervention status\", \"foundCk\": entry[\"foundCk\"]}\n            toUpdate = getEventsByIdTime(events,key,entry[\"timestamp\"])\n            toUpdate.forEach(intv => {\n                if (!intv[\"intvStatus\"].includes(newObj)){\n                    intv[\"intvStatus\"].push(newObj)}})}\n    }\n    return events\n}\n\nconst insertMissingInterventions = (problems,confirmedEvents,indexCounter,phaseNames,phases) => {\n    problems.forEach(prob => {\n        const solutions = prob.solutions\n        let sol\n        for (let elt in solutions) {\n            //find the best fitting solution  TBD\n            sol = solutions[elt]\n            break}\n\n        let actions = sol.actions\n        prob.actions = actions  //the chosen solution\n            // now we just have to examine action ids to see what is missing\n        actions.forEach((action, k) => {\n            if (!confirmedEvents.includes(action.id + \"+\" + prob.probLabel)) {\n                confirmedEvents.push(action.id + \"+\" + prob.probLabel);\n                let phaseObject = {\n                    \"comment\": \"\",\n                    \"numericalID\": indexCounter,\n                    \"status\": \"\",\n                    \"intvStatus\": [], //will be an array what patient status checks were and weren't done\n                    \"required\": true,\n                    \"when\": \"\",\n                    \"suggestedPhase\": \"\",\n                    \"expertPhase\": \"\",\n                    \"probLabel\": \"\",\n                    \"minimalWhy\": \"\",\n                    \"assessmentsNeeded\": \"\",\n                    \"protocol\": \"\",\n                    \"protocolRelationship\": \"\",\n                    \"actionDescription\": \"\",\n                    \"type\": \"intervention\",\n                    \"timestamp\": -1\n                };\n\n                //copy over the step fields that exist (type dependent)\n                const ACTION_FIELDS = [\"id\", \"phase\", \"why\", \"protocolRelationship\"];\n                ACTION_FIELDS.forEach(fldName => {\n                    if (!!action[fldName]) {\n                        phaseObject[fldName] = action[fldName];\n                    }\n                });\n\n                const SOLUTION_FIELDS = [\"minimalWhy\", \"protocols\", \"strictActionOrdering\"];\n                SOLUTION_FIELDS.forEach(fldName => {\n                    if (!!sol[fldName]) {\n                        phaseObject[fldName] = sol[fldName];\n                    }\n                });\n\n                //copy over the step fields that exist (type dependent)\n                const PROBLEM_FIELDS = [\"probLabel\"];\n                PROBLEM_FIELDS.forEach(fldName => {\n                    if (!!prob[fldName]) {\n                        phaseObject[fldName] = prob[fldName];\n                    }\n                });\n\n                //initialize some fields above that come from problem and action if they are defined\n                if (!!prob.assessments) { phaseObject.assessmentsNeeded = prob.assessments }\n                if (!!prob.protocols) { phaseObject.protocol = prob.protocols }\n                if (!!action[\"id-label\"]) { phaseObject.label = action[\"id-label\"]; }\n                if (!!action[\"id-label\"]) { phaseObject.actionDescription = action[\"id-label\"]; }\n                let phaseVal\n                if (!!action.subPhase) { phaseVal = action.subPhase }\n                if (!!action.phase && !phaseVal) { phaseVal = action.phase }\n                if (phaseVal) {\n                    phaseObject.when = phaseVal;\n                    phaseObject.expertPhase = phaseVal;\n                    phaseObject.suggestedPhase = phaseVal;\n                }\n\n                phaseObject.status = \"missing\" + capitalizeFirstLetter(phaseObject.protocolRelationship)\n                //assume actions are in the suggested order to solve a problem\n                if (![\"optional\", \"unnecessary\", \"irrelevant\"].includes(phaseObject.protocolRelationship)) {\n                    insertInPhaseRelativeToSuggestedOrder(phaseNames, phases, phaseObject, actions, k);\n                    indexCounter++;\n                }\n            }\n\n\n        })\n    });\nreturn [indexCounter,phaseNames,phases]}\n\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }\n\n//the main function for analyzing the observation log\nfunction analyzeEvents(scen, log) {\n    let events = log.events;\n    console.log(\"in analyzeEvents\")\n    // sts 1/23/22 moved the setting of the following into initGlobals()\n    // setScenario(scenario)\n    // setupSubphasePhaseLookup()\n    // findSubphases();\n    initGlobals(scen)\n\n    //preprocess some of data from problems/solutions\n    //and for now just flatten it some to set it up to\n    //look more like the original problem actions in scenario\n    // assumes there is just one solution per problem for now.\n    let problemDefs = scenario.problems;\n    let problemActions = scenario.actions;\n    let problemSolutions = scenario.solutions;\n    let problems = setupProblems(problemDefs, problemSolutions, problemActions);\n    \n    //In the remainder, just dealing with the first solution for each problem\n    //so if we ever have more than one solution for a problem this code needs to\n    //be updated.  Would need to consider the additional solutions to decide which\n    //solution is the best fit for the observer student\n\n\n    let formattedActions = [];\n    let annotatedResults = annotateInputEvents(events,problems)\n    //phaseNames and phases are two arrays synchronized be array indices\n    //phases contains just the steps under the phase (thus could be a phase or subphase in observer interface)\n    //phaseNames contains the label for each phase in phases.  Makes it a bit easier to search phaseNames to get the\n    //indice for last instance of a phase label and access its objects\n    let phases = annotatedResults[0];  \n    let phaseNames = annotatedResults[1]; \n    let confirmedEvents = annotatedResults[2]\n    let intvsTracking = annotatedResults[3]\n    \n\n    /* //now create some similar structures for the parents of the above phases\n    //so have all the associated event objects in parents and parentNames\n    //for easy lookup\n    let parentResults = collectParentPh(phaseNames)\n    let parents = parentResults[0]  //events under this parent\n    let parentNames = parentResults[1] */\n\n    //update relative to constraints and comprises definitions\n    //for now it just compares two constraint args of the same type\n    //for what currently exists\n    let kbUpdates = checkAgainstKB(phases,phaseNames)\n    phases = kbUpdates[0]\n    phaseNames = kbUpdates[1]\n    \n    //add missing phase names to phaseNames\n    //as do insertions should consider the temporal ordering constraints\n    \n    let updatedPhases = insertMissingSubphases(phases, phaseNames)\n    phases = updatedPhases[0]\n    phaseNames = updatedPhases[1]\n\n\n    // check for missing checklist steps\n    //as do insertions should consider the temporal ordering constraints\n    let postAssessmentReview = checkForMissingAssessments(problems,events,confirmedEvents,phaseNames,phases)\n    confirmedEvents = postAssessmentReview[0]\n    phaseNames = postAssessmentReview[1]\n    phases = postAssessmentReview[2]\n    let indexCounter = postAssessmentReview[3]\n\n\n\n    // this section could be moved into a separate function so that\n    // the parts of the main analysis are clearer\n\n    // start insert missing interventions\n\n    let postInterventionReview = insertMissingInterventions(problems,confirmedEvents,indexCounter,phaseNames,phases)\n    indexCounter = postInterventionReview[0]\n    phaseNames = postInterventionReview[1]\n    phases = postInterventionReview[2]\n    // search for missing interventions for each action\n    // Doing this separately from the earlier actions loop because\n    // we wanted to add in missing assessment steps first\n    // since interventions depend on appropriate assessments having \n    // been done\n\n\n\n   // end insert missing interventions\n    \n    \n    // put together the phases into a single array ordered as directed by phases\n    \n    formattedActions = organizeLogDisplay(phaseNames, phases);\n    //console.log(\"formattedActions after organizeLogDisplay = \", formattedActions)\n\n    // Now that it is all rejoined into a single list, do some updating with additional\n    // analysis results\n\n    formattedActions = insertMissingIntvChecks(formattedActions, intvsTracking)\n    \n    \n    let priorProb = \"N/A\";\n\n    let finalActions = [];\n    //console.log(\"formattedActions = \", formattedActions)\n\n    formattedActions.forEach((eventObj, j) => {\n        let intvHeaderIndex = 1\n\n        if (insertInterventionHeader && eventObj.type === \"intervention\" && eventObj.probLabel && !(priorProb === eventObj.probLabel)) {\n            priorProb = eventObj.probLabel;\n            let headerObject = {\n                \"id\": \"interventionHeader\",\n                \"status\": \"good\",\n                \"phaseOrderStatus\": \"good\",\n                \"labelID\": eventObj.probLabel,\n                \"type\": \"header\",\n                \"numericalID\": intvHeaderIndex++/3000,\n                \"displayColor\": \"green\",\n            //    \"why\": \"\",\n                \"probLabel\": eventObj.probLabel,\n                \"protocol\": \"\"\n            };\n            finalActions.push(headerObject);\n        }\n        finalActions.push(eventObj);\n    });\n\n    // start overall analysis to determine if all actions to solve a problem are present\n\n    // now we analyze all that we've found in the log to see whether\n    // all the actions were done for each problem and reset\n    // the status if not all are there but should be counted\n    // as minimal for the feedback.\n    let pActions = []; //here we will store the actual problem actions that student did\n    let pNames = []; //here we will store the problem names for the above with same order\n    let pIndex = 0;\n    let pActIndex = -1;\n\n    //console.log(\"finalActions before minimal check = \", finalActions)\n\n    finalActions.forEach((action, j) => {\n        if (action.type === \"intervention\") {\n            //good interventions can have these status values\n            if (!!action.status && action.status.includes(\"goodintv\", \"incorrect-answers\", \"minimal\", \"misOrdered-goodintv\", \n            \"misOrdered-incorrect-answers\", \"misOrdered-incorrect-answers\", \"minimal\", \"misOrdered-minimal\", \n            \"misOrdered-minimal-incorrect-answers\",\n            \"misOrdered-phase-incorrect-answers\", \"misOrdered-phase-minimal-incorrect-answers\", \"misOrdered-phase-minimal\")) {\n                if (!pNames.includes(action.probLabel)) {\n                    pActIndex = pIndex;\n                    pNames[pActIndex] = action.probLabel;\n                    pIndex++;}\n                else { pActIndex = pNames.indexOf(action.probLabel); }\n                let actions = pActions[pActIndex];\n                if (!actions) { actions = []; }\n                actions.push(action);\n                pActions[pActIndex] = actions;\n            }\n        }\n    });\n\n    // If all the minimal were found but not all the action were, then we\n    // need to re-mark the action objects created for the minimal events\n    // to be minimal instead of goodintv.  It isn't\n    // appropriate to give this feedback if all actions are present.\n    // Waited until now so that all the events are in one list instead of\n    // a list per phase,\n    let processedIds = formattedActions.map(event => event.id);\n    let pIds = problems.map(a => a.probLabel);\n    pNames.forEach((pEntry, j) => {\n        //get the action definition for this problem\n        let pIndex = pIds.indexOf(pEntry);\n        let prob = problems[pIndex];\n        let actionNeeded = prob.actions.filter(obj => obj.protocolRelationship === \"required\").map(obj => obj.id);\n        //collect statuses for these actions\n\n        let minimalNeeded = prob.actions.filter(obj => obj.protocolRelationship === \"minimal\").map(obj => obj.id);\n        if (minimalNeeded) { //no point in doing anything else if no minimals were defined\n            let foundActions = pActions[j];\n            let found = foundActions.map(a => a.id);\n            let allActionFound = true;\n            let allMinimalFound = true;\n            for (let item of actionNeeded) {\n                if (!found.includes(item)) {\n                    allActionFound = false;\n                    break;\n                }\n            }\n            for (let item of minimalNeeded) {\n                if (!found.includes(item)) {\n                    allMinimalFound = false;\n                    break;\n                }\n            }\n            let numericalIDsChanged = [];\n            if (!allActionFound && allMinimalFound) {\n                minimalNeeded.forEach((foundId, j) => {\n                    let pIndex = processedIds.indexOf(foundId);\n                    let object = formattedActions[pIndex];\n\n                    //find object to modify\n                    object.minimalWhy = prob.minimalWhy;\n                    switch (object.status){\n                        case \"incorrect-answers\":\n                            object.status = \"minimal-incorrect-answers\"\n                            break\n                        case \"goodintv\":\n                            object.status = \"minimal\"\n                            break\n                        case \"misOrdered-goodintv\":\n                            object.status = \"misOrdered-minimal\"\n                            break\n                        case \"misOrdered-incorrect-answers\":\n                            object.status = \"misOrdered-minimal-incorrect-answers\"\n                            break\n                        case \"misOrdered-phase-goodintv\":\n                            object.status = \"misOrdered-phase-minimal\"\n                            break\n                        case \"misOrdered-phase-incorrect-answers\":\n                            object.status = \"misOrdered-phase-minimal-incorrect-answers\"\n                            break\n                        default: \n                            break}\n\n                    numericalIDsChanged.push(object.numericalID);\n                    formattedActions[pIndex] = object;\n                });\n                //redo color for header if needed\n                let header = {};\n                numericalIDsChanged.forEach((numericalID, z) => {\n                    header = findHeaderFor(numericalID, formattedActions);\n                    if (header && header.displayColor === \"green\") { header.displayColor = \"yellow\"; }\n                });\n\n            }\n        }\n        prob.actions = []  //clear out this working field from problems definitions\n\n    });\n\n    // end of overall analysis\n\n    //create summaries for condition 2\n    let summaryResults = summarizeAnalysis(finalActions, problems, requiredPhaseAndSubPhases, requiredPhaseNames, constraintsViolated)\n    hierAssessResults = summaryResults[0]\n    hierProblemResults = summaryResults[1]\n\n    \n    //save analysis and summaries for condition 2 to db\n\n    console.log(\"Phase Assessment Status Results\", hierAssessResults)\n    console.log(\"Intervention Status Results\", hierProblemResults)\n    console.log(\"Constraint Violation Results\", constraintsViolated)\n    //console.log(\"Final Analysis:\", finalActions);\n\n\n    // save final analysis in a file\n    saveAnalysisLog(log, finalActions, hierAssessResults, hierProblemResults, constraintsViolated);\n\n    //else {checkOnOverwriting(log, finalActions)}\n\n\n    return (finalActions);\n\n}\n\n\nexport {analyzeEvents}","import React, { useContext } from 'react';\n\nimport {\n    Button,\n    Nav,\n    Navbar,\n    NavbarBrand,\n    NavbarText,\n} from \"reactstrap\";\n\nimport { AuthContext } from \"@meddbriefer/mdb-auth\"\n\n// {/* <Button color=\"primary\" onClick={prefsToggler}>\n//     Preferences\n// </Button> */}\n\n\nconst MDBNavBar = ({title, leftNav = null, rightNav = null }) => {\n\n    const { isAuthenticated, userName, signOutUser } = useContext(AuthContext)\n\n    return (\n        <Navbar color=\"dark\" dark>\n\n            <NavbarBrand href=\"#\">\n                MedDBriefer\n            </NavbarBrand>\n\n            {!!leftNav &&\n                <Nav>\n                {leftNav}\n                </Nav>\n            }\n\n            {!!title &&\n                <NavbarText tag=\"h3\">{title}</NavbarText>\n            }\n\n            <Nav>\n                {isAuthenticated &&\n                <>\n                    <NavbarText>\n                        Welcome, {userName} &nbsp;\n                    </NavbarText>\n                    <Button\n                        color=\"danger\"\n                        onClick={signOutUser}\n                    >\n                        Sign Out\n                    </Button>\n                </>\n                }\n                {!!rightNav &&\n                    rightNav\n                }\n            </Nav>\n\n        </Navbar>\n    )\n}\n\nexport default MDBNavBar;\n","import React, { useState, useEffect } from 'react';\nimport { Button, Table } from 'reactstrap';\nimport MDBNavBar from \"./MDBNavBar\"\nimport { getAssessmentIcon, getColor, getFeedback, getTimestamp, saveAnalysisLog} from \"./debriefingUtils\"\n\n\n\nconst DisplayBaseDebriefing = ({log, actions, scenario, context}) => {\n    const [showCommentColumn, setShowCommentColumn] = useState(false);\n    // eslint-disable-next-line\n    //const [events, setEvents] = useState(log.events);\n    const [formattedActions, setFormattedActions] = useState(undefined);\n\n// const Debriefing = ({ log, metaData, criticalActions, associations }) => {\n    /* const toggleCommentColumn = () => {\n        setShowCommentColumn(!showCommentColumn);\n    } */\n    \n\n    const saveAnalysisLogLocally = () => {\n        saveAnalysisLog(log,formattedActions)\n    }\n\n    const toggleComments = () => {\n        setShowCommentColumn(!showCommentColumn)\n    }\n\n    const dispHeaderRow = (entry) => {\n        return (\n            <>\n                {entry.id ===  \"assessmentHeader\"  || entry.id === \"assessmentSubHeader\"\n                    ? <td colSpan=\"4\" className={getColor(entry)}>\n                        <b>{entry.label}</b>\n                    </td>\n                    : <td colSpan=\"10\" className={\"black\"} >\n                        <div><em>\n                        &nbsp;&nbsp;&nbsp;Intervention Group: {entry.probLabel}</em></div>\n                    </td>}\n            </>\n        )\n    }\n    \n    function getLabel(entry) {\n        return(\n            <>\n            {entry.type === \"obtain-vital-sign\"\n                ? vitalLabel(entry)\n                : regularLabel(entry)\n            }\n            </>\n    \n        )\n    }\n    \n    function getStatusLabel(entry){\n        let metaData = scenario.intvMetaData\n        let metaEntry = metaData.find(me => (entry.vital === me.id))\n        return(<>{metaEntry.label}</>)\n    }\n    \n    function vitalLabel(entry){\n        return(\n            <>\n            {entry.vitalType === \"intervention-status\"\n                ? <>Requested intervention status for: {getStatusLabel(entry)}, <p>Found: <i>{entry.value}</i></p></>\n                : <>Requested vital: {entry.vital}, <p>Found: <i>{entry.value}</i></p></>\n            }\n            </>\n        )\n    }\n    \n    function regularLabel(entry) {\n        return(\n            <>\n            {entry.subPhase && entry.type !== \"intervention\"\n                ? <><b>{entry.subPhase}:</b> {entry.actionDescription}.  {findingsData(entry)}</>\n                : <>{phaseLabel(entry)}</>\n        }\n            </>\n        )\n    }\n    \n    function phaseLabel(entry){\n        return(\n            <>\n            {entry.type === \"intervention\"\n                ? <><b>Intervention:</b> {entry.actionDescription}. {findingsData(entry)} </>\n                : <>{entry.actionDescription}.  {findingsData(entry)}</>\n                }\n            </>\n        )\n    }\n        \n    function findingsData(entry){\n        return(\n            <>\n            {entry.finding\n            ?<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Findings: <i>{entry.finding}</i></p>\n            :<></>\n        }\n            </>\n        )\n    \n    }\n    \n    \n     function saveComment(val) {\n        let orig = val.target.defaultValue;\n        let comment = val.target.value;\n        let entryID = val.target.id;\n        if (orig !== comment){\n            let entry = formattedActions.find(entry => (entry.id === entryID))\n            // if (entry) { entry.comment = comment }}\n            const newEntry = Object.assign({}, entry, {comment: comment})\n            updateFormattedAction(newEntry)\n        }\n    }\n    \n    const dispDataRow = (entry) => {\n        return (\n            <>\n                <td>{entry.numericalID}</td>\n                <td>{getTimestamp(entry)}</td>\n                <td className={getColor(entry)}>\n                    <span className=\"material-icons-outlined\">{getAssessmentIcon(entry)}</span>\n                    {getLabel(entry)}\n                </td>\n                <td>{getFeedback(entry)}</td>\n\n                {showCommentColumn && <td><textarea rows=\"2\" cols=\"50\" defaultValue={entry.comment} onBlur={saveComment} id={`${entry.id}`}/></td>}\n            </>\n        )\n    }\n\n    \n    const updateFormattedAction = (record) => {\n        const index = formattedActions.findIndex(rec => rec.id === record.id)\n        setFormattedActions([\n            ...formattedActions.slice(0, index),\n            record,\n            ...formattedActions.slice(index+1)\n        ])\n    }    \n\n\n    async function displayIt () {\n        \n        \n        if (context === \"review\"){\n            //console.log(\"displaying for review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(true)        \n        }\n        else {\n            //console.log(\"displaying for non-review\")\n            //setFormattedActions(actions)\n            setShowCommentColumn(false)\n              }\n\n        setFormattedActions(actions)\n    \n        \n    }\n\n    \n   \n\n\n// eslint-disable-next-line\nuseEffect(\n    () => {\n        displayIt()\n        // eslint-disable-next-line\n    }, [] // empty list means this code will only be run on initial render\n)\n\n\n\nif (undefined === formattedActions) {\n    return (<h3>processing</h3>)\n}\n\nreturn (\n        <>\n            {context === \"review\"\n                ? <><MDBNavBar\n                    title={`Review of: ${log.label}`}\n                    leftNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={saveAnalysisLogLocally}>Save Debriefing Log\n                        </Button>}\n                    rightNav={\n                        <Button\n                            color=\"primary\"\n                            onClick={toggleComments}>Toggle Comments\n                        </Button>}\n                     /></>\n                : <><MDBNavBar\n                    title={`Analysis for: ${log.label}`}\n                    /></>\n            }\n            <form>\n            <div style={{ overflowY: \"auto\", maxHeight: \"700px\" }}>\n                <Table borderless size=\"sm\">\n                    <thead>\n                        <tr>\n                            <th className=\"table-header\"> ID </th>\n                            <th className=\"table-header\"> Timestamp </th>\n                            <th className=\"table-header\"> Action Description </th>\n                            <th className=\"table-header\"> Feedback </th>\n                            {showCommentColumn && <th className=\"table-header\"> Comments </th>}\n                        </tr>\n                    </thead>\n                    <tbody className=\"scrolling\">\n                        {formattedActions.map((currentEntry, index) => (\n                            <tr key={index}>\n                                {currentEntry.type === \"header\"\n                                    ? dispHeaderRow(currentEntry)\n                                    : dispDataRow(currentEntry)\n                                }\n                            </tr>\n                        ))}\n                    </tbody>\n                </Table>\n            </div>\n        </form>\n        </>\n\n    )\n}\n\nexport {saveAnalysisLog}  \nexport default DisplayBaseDebriefing\n","import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID } from '@meddbriefer/scenario-data/index'\nimport {analyzeEvents} from './analyzeEvents'\nimport DisplayBaseDebriefing from './DisplayBaseDebriefing';\n\n\n\nfunction AnalyzeDebriefing ()  {\n    const { logID } = useParams()\n    const [observerLog, setObserverLog] = useState (undefined)\n    const [log, setLog] = useState(undefined)\n    const [scenario, setScenario] = useState(undefined)\n    const [analyzed, setAnalyzed] = useState(false)\n    const [loaded, setLoaded] = useState(false)\n\n    // eslint-disable-next-line\n    \n    // Set to true once all performed actions have been displayed in the log\n    // const [finishedPerformedActions, setFinishedPerformedActions] = useState(false);\n\n    //console.log (\"logID:\", logID)\n\n    function checkOnOverwriting() {\n        if (window.confirm (\"Are you sure you want to overwrite the existing analysis?  Any prior comments previously added will be lost.\")){\n            analyzeEventsHook(scenario, observerLog) \n            \n        }\n\n    }\n\n    async function analyzeEventsHook(scenario, log) {\n      analyzeEvents(scenario, log)}\n\n    \n    async function processEvents ()  {\n        //console.log(\"in processEvents to process a new observer file\")\n        if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n            {analyzeEventsHook(scenario, observerLog)\n            setAnalyzed(true)} \n        else {checkOnOverwriting()} \n        setAnalyzed(true)\n        return (true)    \n    }\n\n    useEffect(\n        () => {\n          getLog(db,logID)\n            .then(observerLogData => {  \n              //console.log(\"retrieve observerLogData\", observerLogData) \n              setObserverLog(observerLogData)    \n            })\n            .catch(error => alert('error fetching observer log', error))   \n        // eslint-disable-next-line\n    }, []\n      )\n    \n      useEffect(\n        () => {\n          !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n            .then(scenData => {\n              console.log(\"retrieve scenario:\", scenData)\n              setScenario(scenData)\n            })\n    \n        }, [observerLog]\n      )\n    \n      useEffect(\n        () => {\n          !!scenario && processEvents()\n          //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n    \n      useEffect(\n        () => {\n          !!analyzed && getDebriefLog(db, logID)\n            .then(logData => {\n              //console.log(\"retrieve Debriefing result:\", logData)\n              setLog(logData)  \n            })\n            .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n    \n      useEffect(\n        () => {\n          !!log && setLoaded(true) \n        }, [log]\n      )\n    \n      if (!loaded) {\n        return (<h3>Loading</h3>)\n      }\n    \n\n\n    return (\n        <DisplayBaseDebriefing\n        log={log}\n        actions={log.events}\n        scenario={scenario}\n        context={\"initial-analysis\"}\n        />\n    )\n}\n\nexport default AnalyzeDebriefing","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { getLog , getPublishedScenarioByID } from \"@meddbriefer/scenario-data/index\"\nimport AnalyzeDebriefing from '../components/AnalyzeDebriefing'\n\nconst Log = () => {\n\n  const { logID } = useParams()\n  const [ log, setLog ] = useState(null)\n  const [ scenario, setScenario] = useState(null)\n  const [loaded, setLoaded] = useState(false)\n\n  useEffect(\n    () => {\n      getLog(db,logID)\n        .then(logData => {\n          setLog(logData)\n        })\n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      //!!log && getScenarioByName(db, log.scenarioName, \"V2\")\n      !!log && getPublishedScenarioByID(db, log.scenarioID)\n        .then(scenData => {\n          setScenario(scenData)\n          console.log(\"scenario\", scenData)\n        })\n\n    }, [log]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && setLoaded(true)\n    }, [scenario]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n  return ( \n      <AnalyzeDebriefing \n        log={logID} \n      /> \n    )\n\n\n}\n\nexport default Log;\n","import { useEffect, useState } from 'react'\nimport { useParams } from 'react-router-dom'\nimport { db } from \"@meddbriefer/mdb-firebase\"\nimport { analyzeEvents } from '../components/analyzeEvents'\nimport { getDebriefLog, getLog, verifyDocument, getPublishedScenarioByID} from \"@meddbriefer/scenario-data/index\"\nimport DisplayBaseDebriefing from '../components/DisplayBaseDebriefing'\n\n\n\nfunction DisplayDebriefing () {\n\n  const { logID } = useParams()\n  const [observerLog, setObserverLog] = useState(undefined)\n  const [log, setLog] = useState(undefined)\n  const [scenario, setScenario] = useState(undefined)\n  const [analyzed, setAnalyzed] = useState(false)\n  const [loaded, setLoaded] = useState(false)\n\n  \n  \n  async function processLog () {\n    //console.log(\"in processLog to display existing analysis\")\n    if (! await verifyDocument(db, \"debriefing-feedback-logs\", logID))\n          {analyzeEvents(scenario, observerLog) \n          }\n    setAnalyzed(true)\n    return (true)\n  }\n  \n\n  //get observer log first\n\n  useEffect(\n    () => {\n      getLog(db, logID)\n        .then(observerLogData => {  \n          //console.log(\"retrieve observerLogData\", observerLogData) \n          setObserverLog(observerLogData)    \n        })\n        .catch(error => alert('error fetching observer log', error))   \n    }, [logID]\n  )\n\n  useEffect(\n    () => {\n      !!observerLog && getPublishedScenarioByID(db, observerLog.scenarioID, \"V2\")\n        .then(scenData => {\n          console.log(\"scenario:\", scenData)\n          setScenario(scenData)\n        })\n\n    }, [observerLog]\n  )\n\n  useEffect(\n    () => {\n      !!scenario && processLog()\n      //console.log(\"check on existing analysis\")\n        // eslint-disable-next-line\n        }, [scenario]\n      )\n      \n  useEffect(\n      () => {\n        !!analyzed && getDebriefLog(db,logID)\n          .then(logData => {\n            //console.log(\"retrieve Debriefing result:\", logData)\n            setLog(logData)  \n          })\n          .catch(error => alert('error fetching debriefing log', error))\n        // eslint-disable-next-line\n        }, [analyzed]\n      )\n\n  useEffect(\n    () => {\n      !!log && setLoaded(true) \n    }, [log]\n  )\n\n  if (!loaded) {\n    return (<h3>Loading</h3>)\n  }\n\n\n  return (\n    <DisplayBaseDebriefing\n      log={log}\n      actions={log.events}\n      scenario={scenario}\n      context={\"review\"} />\n  )\n\n\n}\n\nexport default DisplayDebriefing;\n","import React from \"react\"\n\nimport MDBNavBar from \"./MDBNavBar\"\n\nconst UnauthedLayout = (props) => {\n\n    return (\n        <>\n            <MDBNavBar\n                title=\"MedDBriefer Authentication\"\n            />\n            { props.children }\n        </>\n    )\n}\n\nexport default UnauthedLayout","import React from \"react\"\n\nimport {\n    HashRouter as Router,\n    Switch,\n} from \"react-router-dom\"\n\nimport { AuthProvider, PrivateRoute } from \"@meddbriefer/mdb-auth\"\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nimport \"./styles.css\";\n\nimport LogList from \"./routes/LogList\"\nimport Log from \"./routes/Log\"\nimport DisplayDebriefing from \"./routes/DisplayDebriefing\"\n\n\nimport UnauthedLayout from \"./components/UnauthedLayout\"\n\nconst App = (props) => {\n\n    return (\n        <AuthProvider>\n            <Router>\n\n                <Switch>\n                    <PrivateRoute\n                        exact path=\"/logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={Log}\n                    />\n                    <PrivateRoute\n                        exact path=\"/debriefing-feedback-logs/:logID\"\n                        authFlowLayout={UnauthedLayout}\n                        component={DisplayDebriefing}\n                    />\n                    {/*default (catchall) route*/}\n                    <PrivateRoute\n                        exact match=\"/\"\n                        authFlowLayout={UnauthedLayout}\n                        component={LogList}\n                    />\n                </Switch>\n            </Router>\n        </AuthProvider>\n    )\n}\n\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}